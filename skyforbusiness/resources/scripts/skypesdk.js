/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);
                name = name.split('/');
                lastIndex = name.length - 1;

                // Node .js allowance:
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                name = baseParts.concat(name);

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("vendor/almond", function(){});

/*!
 * Skype Developer Platform
 * (c) 2015 Microsoft Corporation.  All rights reserved.
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        Web.version = '0.2.3'; // see semver.org
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            Settings.isUnitTested = !!window.SkypeWebTests;
            Settings.logRequests = true;
            Settings.logEvents = true;
            Settings.logMedia = true;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/**
 * Various utilities and the property model implementation.
 *
 * This file implements various utility functions and a few
 * things that constitute the property model:
 *
 *      - Task
 *      - Event
 *      - Property
 *      - Collection
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            
            //#region Imports (from the global namespace)
            var global = window.ttt ? window.ttt.window : window;
            var setTimeout = global.setTimeout;
            var clearTimeout = global.clearTimeout;
            var Date = global.Date;
            var Math = global.Math;
            var console = global.console;
            global = null;
            //#endregion
            var isUnitTested = !!window.SkypeWebTests;
            var sIsAsync = Symbol('async'); // = true in async functions
            // Uses Object.setPrototypeOf to replace the prototype of
            // created properties and collection, which are functions.
            // This trick reduces the memory usage, but might be unsafe.
            Utils.replacePrototype = true;
            var debug;
            (function (debug) {
                function log() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    /* istanbul ignore next */
                    if (!isUnitTested) {
                        try {
                            console.log.apply(console, args);
                        }
                        catch (err) {
                        }
                    }
                }
                debug.log = log;
            })(debug = Utils.debug || (Utils.debug = {}));
            /** Just a function that does nothing. */
            Utils.noop = function () { };
            //#region Exception
            /**
             * Constructs an exception object with custom parameters.
             *
             * The constructed exception inherits from the native Error object
             * all its properties, including the captured stack trace, and adds
             * to it the "code" member and a few custom members that usually
             * include the "reason" which points to another exception object.
             *
             * To throw an exception with a code use:
             *
             *      throw Exception("InvalidArgument");
             *
             * To throw an exception with a code and a custom message use:
             *
             *      throw Exception.call("An invalid argument passed.", "InvalidArgument");
             *
             * To throw an exception with custom parameters use:
             *
             *      throw Exception("SomethingFailed", {
             *          reason: err,
             *          tag: 123
             *      });
             *
             * @param {String} code - An error code, e.g. "InvalidArgument"
             * @param {Object} [params] - An optional set of values associated with the error.
             *
             * @returns {Error}
             */
            function Exception(code, params) {
                params = extend({ code: code }, params);
                // since IE9 does not support the 'strict' mode and the function is invoked as baseless function call,
                // 'this' will refer to window object in IE9 in this case. To support IE9, check whether 'this' refers window object first.
                return extend(Error(this === window || !this || this == '' ? code : this), params);
            }
            Utils.Exception = Exception;
            //#endregion
            //#region Common Exceptions
            function EWrongType(value, type) {
                var text = value + ' is not a ' + type;
                return Exception.call(text, 'WrongType', { value: value });
            }
            Utils.EWrongType = EWrongType;
            function EWrongArgType(name, value, type) {
                var text = '`' + name + '` = ' + value + ' is not a ' + type;
                return Exception.call(text, 'WrongArgType', { arg: name, value: value });
            }
            Utils.EWrongArgType = EWrongArgType;
            function EDoesNotEqual(lhs, rhs) {
                var text = lhs + ' != ' + rhs;
                return Exception.call(text, 'DoesNotEqual', { lhs: lhs, rhs: rhs });
            }
            Utils.EDoesNotEqual = EDoesNotEqual;
            function EInvalidArgument(name, reason) {
                var text = '`' + name + '` is invalid: ' + reason;
                return Exception.call(text, 'InvalidArgument', { arg: name, reason: reason });
            }
            Utils.EInvalidArgument = EInvalidArgument;
            function EInvalidState(state, expected) {
                var text = 'Invalid state: ' + state + ' (expected ' + expected + ')';
                return Exception.call(text, 'InvalidState', { actual: state, expected: expected });
            }
            Utils.EInvalidState = EInvalidState;
            function EKeyMissing(key, obj) {
                var text = 'the `' + key + '` property is missing';
                return Exception.call(text, 'KeyMissing', { key: key, object: obj });
            }
            Utils.EKeyMissing = EKeyMissing;
            function EAlreadyExists(item) {
                return Exception('AlreadyExists', { item: item });
            }
            Utils.EAlreadyExists = EAlreadyExists;
            function EDoesNotExist(item) {
                return Exception('DoesNotExist', { item: item });
            }
            Utils.EDoesNotExist = EDoesNotExist;
            function ENotSupported(reason) {
                return Exception('NotSupported', { reason: reason });
            }
            Utils.ENotSupported = ENotSupported;
            //#endregion
            //#region assertions    
            function assert(condition, message, params) {
                if (!condition) {
                    if (!isUnitTested)
                        debugger;
                    throw Exception(message || 'AssertionFailed', params);
                }
            }
            Utils.assert = assert;
            var assert;
            (function (assert) {
                function is(object, type) {
                    if (type instanceof RegExp)
                        assert(type.test(object), 'DoesNotMatchPattern', { value: object, pattern: type });
                    else if (type && !Utils.is(object, type)) {
                        debugger;
                        throw EWrongType(object, type);
                    }
                }
                assert.is = is;
                function args(args, spec) {
                    foreach(spec, function (type, name) {
                        var value = args && args[name];
                        if (!Utils.is(value, type)) {
                            debugger;
                            throw EWrongArgType(name, value, type);
                        }
                    });
                }
                assert.args = args;
            })(assert = Utils.assert || (Utils.assert = {}));
            function check(condition, message, params) {
                if (!condition)
                    throw Exception(message || 'RuntimeCheckFailed', params);
            }
            Utils.check = check;
            var check;
            (function (check) {
                function equals(a, b) {
                    if (a != b)
                        throw EDoesNotEqual(a, b);
                }
                check.equals = equals;
                function state(actual, expected) {
                    if (isArray(expected)) {
                        if (indexOf(expected, actual) == -1)
                            throw EInvalidState(actual, expected);
                    }
                    else if (actual != expected)
                        throw EInvalidState(actual, expected);
                }
                check.state = state;
                function belongs(key, object) {
                    if (!(key in object))
                        throw EKeyMissing(key, object);
                }
                check.belongs = belongs;
            })(check = Utils.check || (Utils.check = {}));
            //#endregion
            //#region Symbol
            /**
             * The idea is taken from the ES6 Symbol.
             *
             * A symbol is a string-like object that can be used as a key
             * to access an object's member. Its main difference from a plain
             * string is that the object's member can be accessed only if
             * a reference to the symbol is available:
             *
             *      var myObj = {};
             *      var mySym = Symbol("a descriptive name to simplify debugging");
             *      myObj[mySym] = secret;
             *
             * To a very good extent a symbol can be simulated by a random string.
             * At runtime a symbol is just a random string with a hint in it.
             * While executing unit tests a symbol is the same string that was
             * given to its constructor.
             *
             */
            function Symbol(name) {
                return isUnitTested ? name : name + ':' + random();
            }
            Utils.Symbol = Symbol;
            //#endregion
            //#region various utils
            function setPrototypeOrExtend(obj, proto) {
                if (Utils.replacePrototype) {
                    if (obj.__proto__)
                        obj.__proto__ = proto; // jshint ignore:line
                    else if (Object.setPrototypeOf)
                        Object.setPrototypeOf(obj, proto);
                    else
                        extend(obj, proto);
                }
                else {
                    extend(obj, proto);
                }
            }
            //#region defer
            /**
             * defer(fn, args...) invokes fn(args...) at the next event loop cycle
             * if the code is run in a browser during runtime, or invokes fn(args...)
             * right away if the code is invoked by a unit test.
             *
             * A more efficient way to do so is to use `postMessage` which may not be
             * supported on all browsers that SkypeWeb supports.
             */
            function defer(callback /* args... */) {
                var self = this;
                var args = [].slice.call(arguments, 1);
                /* istanbul ignore else */
                if (isUnitTested) {
                    callback.apply(self, args);
                }
                else {
                    setTimeout(function () {
                        callback.apply(self, args);
                    }, 0);
                }
            }
            //#endregion
            //#region sleep
            /**
             * Returns a promise that gets resolved after the given delay.
             *
             * @param {Number} delay - The delay in seconds, e.g. 1.5 means 1500 milliseconds.
             * @returns {Promise}
             * @example
             *
             *      sleep(1.5).then(function () {
             *          alert("1.5 seconds has left.");
             *      });
             */
            function sleep(delay) {
                assert(delay >= 0);
                var task = Task(delay + ' sec timeout', {
                    cancel: function (reason) {
                        clearTimeout(id);
                        task.reject(reason);
                    }
                });
                var id = setTimeout(function () { return task.resolve(); }, (delay * 1000) | 0);
                return task.promise;
            }
            Utils.sleep = sleep;
            //#endregion
            //#region repeat
            /**
             * Repeats an asynchronous function.
             *
             * Repeats a function asynchronously until the returned promise is canceled or
             * a non-recoverable error is encountered. The control over what errors can be
             * recovered can be handled (for async functions only!) by providing a failure
             * handler and preventing the exception from bubbling up which will make it
             * eligible for the next repeat cycle. The logic of `repeat` is functionally
             * equivalent to:
             *
             *      while (true)
             *          await fn();
             *
             * @param {Function} fn - The async function to repeat until canceled/error.
             * @returns {Promise}
             */
            function repeat(fn) {
                // With the await keyword the repeat function can be rewritten as:
                //
                //  function repeat(fn) {
                //      await fn();
                //      await repeat(fn);
                //  }
                //
                // The last statement is a proper tail call and doesn't need to create an
                // extra frame on the stack or it's asynchronous equivalent - a new promise
                // in the chain of promises. If the n-th call to repeat returns a promise p(n)
                // and fn always succeeds, repeat creates an endless chain of promises attached
                // one to another:
                //
                //  p(0) <- p(1) <- p(2) <- ... <- p(n - 1) <- p(n) <- fn()
                //
                // It can be seen that all intermediate promises from p(1) to p(n - 1) can be
                // removed from the chain:
                //
                //  p(0) <- p(n) <- fn()
                //
                // This eliminates the memory leak. This optimization consists of two simpler
                // optimizations:
                //
                //  (p0 <- p1 <- p2) => (p0 <- p2 -> p1) => (p0 <- p2), (p1)
                //
                // The first step removes the intermediate promise p1 by lifting p0 by one level
                // and the second step discovers that nobody will ever invoke p1.then, so p1 is
                // simply detached from p2. Then p1 gets gc'd. To make the second step possible,
                // p1 - the last promise returned from inside .then - needs to be marked somehow.
                return async(fn)().then(function () {
                    return extend(repeat(fn), { locked: true });
                });
            }
            Utils.repeat = repeat;
            //#endregion
            //#region repeatAndExit
            /**
             * Adds to repeat(...) a convenient way to return a value.
             *
             * The only way to terminate an async repeat(...) loop is to
             * throw an exception. In some cases it's useful to end an async loop
             * with a result. This function solves this by wrapping the result
             * into an exception to terminate the loop and unwrapping it at the end
             * to resolve the promise.
             *
             *      repeatAndExit(function (exit) {
             *          return ucwa.send("GET", "/status").then(function (rsp) {
             *              if (rsp.status == 409)
             *                  exit(rsp);
             *              return sleep(10);
             *          });
             *      }).then(function (rsp) {
             *          console.log(rsp); // status = 409
             *      });
             *
             * Unlike the repeat function, repeatAndExit invokes the given async function
             * with one argument - a specially constructed `exit` function that throws a
             * specially constructed exception, which is caught by repeatAndExit and used
             * to resolve the promise.
             *
             */
            function repeatAndExit(fn) {
                var res = [];
                function exit(result) {
                    res[0] = result;
                    throw res;
                }
                return repeat(bind(fn, exit)).catch(function (err) {
                    if (err === res)
                        return err[0];
                    else
                        throw err;
                });
            }
            Utils.repeatAndExit = repeatAndExit;
            //#endregion
            //#region repeatDelayed
            /**
             * A specialized version of repeat(...) that handles delaying execution cycles
             * by sleeping a supplied amount. The logic of `repeatDelayed` is functionally
             * equivalent to:
             *
             *      while (true) {
             *          await fn();
             *          await sleep(delay);
             *      }
             *
             * @param {Function} fn - The function to repeat until canceled/error.
             * @param {Number} delay - The amount to delay in seconds until next execution cycle.
             *
             * @returns {Promise}
             */
            function repeatDelayed(fn, delay) {
                // repeatDelayed(fn, 0) is equivalent to repeat(fn)
                assert(isNumber(delay) && delay > 0);
                // this will check whether fn is a function
                fn = async(fn);
                return repeat(function () {
                    return fn().then(bind(sleep, delay));
                });
            }
            Utils.repeatDelayed = repeatDelayed;
            //#endregion
            //#region getOption
            function getOption(values, name, defaultValue) {
                return name in values ? values[name] : defaultValue;
            }
            Utils.getOption = getOption;
            //#endregion
            //#region bind
            /**
             * This is a polyfill for Function#bind that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not extend prototypes of the global constructors such as Function.
             */
            function bind(fn) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var that = this;
                // use the native Function#bind if it's available
                return fn.bind ? fn.bind.apply(fn, [that].concat(args)) : function () {
                    return fn.apply(that, args.concat([].slice.call(arguments, 0)));
                };
            }
            Utils.bind = bind;
            //#endregion
            //#region indexOf
            /**
             * This is a polyfill for Array#indexOf that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not extend prototypes of the global constructors such as Array.
             */
            function indexOf(a, v) {
                var i;
                if (a.indexOf) {
                    return a.indexOf(v);
                }
                else {
                    for (i = 0; i < a.length; i++) {
                        // an expression comparing objects is only true
                        // if the operands reference the same object
                        if (a[i] == v)
                            return i;
                    }
                    return -1;
                }
            }
            Utils.indexOf = indexOf;
            //#endregion
            function removeAt(array, index) {
                array.splice(index, 1);
            }
            function insertAt(array, index, value) {
                array.splice(index, 0, value);
            }
            //#region keys
            /**
             * This is a polyfill for Object.keys that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not override global function, such as Object.keys.
             */
            function keys(obj) {
                var names;
                if (Object.keys) {
                    names = Object.keys(obj);
                }
                else {
                    names = [];
                    foreach(obj, function (val, key) {
                        names.push(key);
                    });
                }
                return names;
            }
            Utils.keys = keys;
            //#endregion
            //#region all
            /**
             * Checks whether a condition is satisfied for a set of items.
             */
            function all(items, condition) {
                // `foreach` could be used here with a `throw` statement
                // to simulate a `break` in a regular `for` loop, but there
                // reasons to not do this:
                //
                //  1. at the moment `all` doesn't need to support arrays
                //  2. throw/break will be executed in almost every call to `all`
                //  3. `throw` would significantly degrade performance
                // 
                for (var name in items)
                    if (!condition(items[name], name))
                        return false;
                return true;
            }
            Utils.all = all;
            //#endregion
            //#region extend
            /**
             * Copies properties from one object to another.
             * It overwrites existing properties.
             *
             * @example Returns {a:1, b:2}
             *
             *      extend({a:1}, {b:2});
             *
             * @example Returns {a:1, b: 3}
             *
             *      extend({a:1}, {a:2, b:3});
             *
             * @example Does nothing, because x.toString already exists.
             *
             *      var x = {};
             *      extend(x, {toString:function(){}});
             */
            function extend(res) {
                var args = []; /* ...srcs, mode = "override" */
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var src, i, name, mode = args[args.length - 1];
                res = res || {};
                mode = isString(mode) ? mode : '';
                for (i = 0; i < args.length; i++) {
                    src = args[i] || {};
                    if (src !== mode) {
                        for (name in src) {
                            if (mode != 'append' || !(name in res))
                                res[name] = src[name];
                        }
                    }
                }
                return res;
            }
            Utils.extend = extend;
            //#endregion
            //#region namespace
            /**
             * Creates or extends a namespace.
             *
             * @param {String} path - e.g. "Skype.Web.Utils"
             * @param {Object} [members] - Members to be added to the namespace.
             * @param {Object} [root=window]
             *
             * @returns {Object} - The created namespace.
             */
            function namespace(path, members, root) {
                var i, ns = root || window, names = path.split('.');
                for (i = 0; i < names.length; i++)
                    ns = ns[names[i]] || (ns[names[i]] = {});
                for (i in members) {
                    assert(!(i in ns), path + '.' + i + ' already exists');
                    ns[i] = members[i];
                }
                return ns;
            }
            Utils.namespace = namespace;
            //#endregion
            //#region guid (an RFC 4122 compliant implementation)
            function guid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = Math.random() * 16 | 0;
                    var v = c == 'x' ? r : r & 3 | 8;
                    return v.toString(16);
                });
            }
            Utils.guid = guid;
            //#endregion
            //#region random    
            /**
             * Returns a random number in the form of a hex string.
             */
            function random() {
                return Math.random().toString(16).slice(2);
            }
            Utils.random = random;
            //#endregion
            //#region setHiddenProperty
            /**
             * It's typically used with Symbol:
             *
             *      var sName = Symbol('name');
             *      var myObj = {};
             *      setHiddenProperty(myObj, sName, 'Alice');
             *
             * In ES6 a function like this isn't needed and a simple
             * assignment does the job.
             */
            function setHiddenProperty(obj, sym, val, readOnly) {
                if (readOnly === void 0) { readOnly = false; }
                try {
                    Object.defineProperty(obj, sym, {
                        value: val,
                        enumerable: false,
                        writable: !readOnly
                    });
                }
                catch (err) {
                    obj[sym] = val;
                }
            }
            Utils.setHiddenProperty = setHiddenProperty;
            //#endregion
            //#region trim
            function trim(s) {
                return s.trim ? s.trim() : s.replace(/^\s+|\s+$/gm, '');
            }
            Utils.trim = trim;
            //#endregion
            //#region foreach
            /**
             * Invokes a callback for each element in the array
             * or in the object.
             *
             * @example It prints 0->11 1->22 2->33
             *
             *      foreach([11, 22, 33], function (value, index) {
             *          console.log(index + "->" + value);
             *      });
             *
             * @example It prints a->1 b->2 c->3
             *
             *      foreach({a:1, b:2, c:3}, function (value, key) {
             *          console.log(key + "->" + value);
             *      });
             */
            function foreach(items, callback) {
                assert(isArray(items) || isDictionary(items));
                assert(isFunction(callback));
                var retVal, i, key;
                if (isArray(items)) {
                    for (i = 0; i < items.length; ++i)
                        callback(items[i], i);
                }
                else {
                    for (key in items) {
                        retVal = callback(items[key], key);
                        assert(retVal === void 0);
                    }
                }
            }
            Utils.foreach = foreach;
            //#endregion
            //#region filter
            /**
             * Creates a subset with all items that pass the test implemented by the
             * callback. For an array argument this subset is a new array, for a dictionary
             * argument is a new dictionary.
             *
             * @example
             *      var res = filter([11, 22, 33], function (value) {
             *          return value > 20;
             *      });
             *      // res is [22, 33]
             *
             * @example
             *      var res = filter({a:1, b:2, c:3, d:4}, function (value, key) {
             *          return value > 3 || key < 'b';
             *      });
             *      // res is {a:1, d:4}
             */
            function filter(items, callback) {
                assert(isArray(items) || isDictionary(items));
                assert(isFunction(callback));
                var res;
                if (isArray(items)) {
                    res = [];
                    foreach(items, function (val, key) {
                        if (callback(val, key))
                            res.push(val);
                    });
                }
                else {
                    res = {};
                    foreach(items, function (val, key) {
                        if (callback(val, key))
                            res[key] = val;
                    });
                }
                return res;
            }
            Utils.filter = filter;
            //#endregion
            //#region values
            /**
             * Given a dictionary returns an array of dictionary values.
             */
            function values(items) {
                assert(isDictionary(items));
                var vals = [];
                foreach(items, function (value) {
                    vals.push(value);
                });
                return vals;
            }
            Utils.values = values;
            //#endregion
            //#region size
            /**
             * Returns the size of a collection (array or dictionary).
             */
            function size(items) {
                assert(isArray(items) || isDictionary(items));
                return isArray(items) ? items.length :
                    keys(items).length;
            }
            Utils.size = size;
            //#endregion
            //#region contains
            /**
             * Determines whether a collection (array or dictionary) contains an element
             * that satisfies a given condition
             */
            function contains(items, callback) {
                assert(isArray(items) || isDictionary(items));
                assert(isFunction(callback));
                var i;
                if (isArray(items)) {
                    for (i = 0; i < items.length; ++i) {
                        if (callback(items[i], i))
                            return true;
                    }
                }
                else {
                    for (i in items) {
                        if (callback(items[i], i))
                            return true;
                    }
                }
                return false;
            }
            Utils.contains = contains;
            //#endregion
            //#region find
            /**
             * Determines whether a collection (array or dictionary) contains an element
             * that satisfies a given condition and returns this element or null if no
             * such element is found
             */
            function find(items, callback) {
                assert(isArray(items) || isDictionary(items));
                assert(isFunction(callback));
                var i, res = {};
                if (isArray(items)) {
                    for (i = 0; i < items.length; ++i) {
                        if (callback(items[i], i))
                            return items[i];
                    }
                }
                else {
                    for (i in items) {
                        if (callback(items[i], i)) {
                            res[i] = items[i];
                            return res;
                        }
                    }
                }
                return null;
            }
            Utils.find = find;
            //#endregion
            //#region findIndex
            /**
             * Determines whether an array contains an element that satisfies a given
             * condition and returns the index of this element or -1 if no such element
             * is found. It is basically the combination of find and indexOf.
             */
            function findIndex(items, callback) {
                assert(isArray(items));
                assert(isFunction(callback));
                var i;
                for (i = 0; i < items.length; ++i) {
                    if (callback(items[i], i))
                        return i;
                }
                return -1;
            }
            Utils.findIndex = findIndex;
            //#endregion
            //#region freeze
            /**
             * Freezes the object (makes the object immutable)
             *
             * @param {Object} obj - an object to freeze
             * @returns {Object} obj - the object passed to this function
             */
            function freeze(obj) {
                return Object.freeze ? Object.freeze(obj) : obj;
            }
            Utils.freeze = freeze;
            //#endregion
            //#region enums
            /**
             * Creates a string enumeration.
             *
             * @param {arguments} - a collection of strings.
             * @returns {object} -  an object which has property names-values equal to each string
             *                      in the arguments collection
             *
             * @example
             *      var se = StringEnum('red', 'green', 'blue');
             *      assert(se.red === 'red');
             *      var yellow = se.yellow; will throw
             */
            function StringEnum() {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i - 0] = arguments[_i];
                }
                var obj = {}, name, i;
                for (i = 0; i < values.length; i++) {
                    name = values[i];
                    obj[name] = name;
                }
                return freeze(obj);
            }
            Utils.StringEnum = StringEnum;
            /**
             * Creates an enumeration.
             *
             * @param {arguments} - a collection of strings.
             * @returns {object} - an object which has property names equal to argument strings
             *      and property values equal to argument string positions
             *
             * @example
             *      var se = Enum('red', 'green', 'blue');
             *      assert(se.red === 0);
             *      var yellow = se.yellow; will throw
             *
             * or an enumeration can be set explicitly by using
             * @param {object} - a dictionary of name-value pairs
             * @returns {object} - the frozen parameter object
             *
             * @example
             *   var se = Enum({red: 1, green: 5, blue: 8});
             *   assert(se.green == 5);
             *
             * @remark use the companion function enumName to get the enum name from its value
             */
            function Enum() {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i - 0] = arguments[_i];
                }
                var obj, i;
                if (values.length == 1 && isDictionary(values[0])) {
                    obj = arguments[0];
                }
                else {
                    obj = {};
                    for (i = 0; i < values.length; i++)
                        obj[values[i]] = i;
                }
                return freeze(obj);
            }
            Utils.Enum = Enum;
            /**
             * Returns enum name from its value
             */
            function enumName(enumObj, enumVal) {
                for (var name in enumObj) {
                    if (enumObj[name] == enumVal)
                        return name;
                }
                return '';
            }
            Utils.enumName = enumName;
            //#endregion
            //#region map
            /**
             * This is an implementation of Array::map compatible with ECMAScript 5.
             *
             * @param {Array|Object} array
             * @param context
             * @param {Function} callback(value, index, array)
             *
             *      A function that takes the name and value of a source object
             *      property, and returns the result of a certain operation on that value.
             */
            function map(array, callback, context) {
                var mapped, i;
                if (isArray(array)) {
                    mapped = [];
                    for (i = 0; i < array.length; i++)
                        mapped.push(callback.call(context, array[i], i, array));
                }
                else if (isDictionary(array)) {
                    mapped = {};
                    for (i in array)
                        mapped[i] = callback.call(context, array[i], i, array);
                }
                return mapped;
            }
            Utils.map = map;
            //#endregion
            //#region inherit
            /**
             * Creates an object with the given prototype
             * and optionally extends it with a set of properties.
             * As a nice side effect the created object will be
             * displayed in a debugger with the right type name,
             * i.e. inherit(ABC.prototype, { x: 1 }) will be displayed
             * as ABC { x: 1 }.
             */
            function inherit(proto, props, mode) {
                var key, descriptors = {};
                proto = proto || {};
                props = props || {};
                for (key in props) {
                    if (!(key in proto) || mode != 'append')
                        descriptors[key] = {
                            value: props[key],
                            writable: true,
                            enumerable: true,
                            configurable: true
                        };
                }
                // not supported in IE 8, but there are already
                // many things here that don't work in IE 8
                return Object.create(proto, descriptors);
            }
            Utils.inherit = inherit;
            //#endregion
            //#region clone
            /**
             * Returns an exact copy of the given object.
             * The copy has no relationships with the original
             * object, so if the original object gets modified,
             * the copy doesn't change.
             *
             */
            function clone(object) {
                return object && JSON.parse(JSON.stringify(object));
            }
            Utils.clone = clone;
            //#endregion
            //#region is
            function isObject(x) {
                // IE8 thinks that {}.toString(undefined) == '[object Object]'
                return x && Object.prototype.toString.call(x) == '[object Object]';
            }
            Utils.isObject = isObject;
            function isDictionary(x) {
                return isObject(x);
            }
            Utils.isDictionary = isDictionary;
            function isArray(x) {
                return Object.prototype.toString.call(x) == '[object Array]';
            }
            Utils.isArray = isArray;
            function isArrayOf(a, is) {
                if (!isArray(a))
                    return false;
                for (var i = 0; i < a.length; i++)
                    if (!is(a[i]))
                        return false;
                return true;
            }
            Utils.isArrayOf = isArrayOf;
            function isString(x) {
                return Object.prototype.toString.call(x) == '[object String]';
            }
            Utils.isString = isString;
            function isNumber(x) {
                return Object.prototype.toString.call(x) == '[object Number]';
            }
            Utils.isNumber = isNumber;
            function isFunction(x) {
                return Object.prototype.toString.call(x) == '[object Function]';
            }
            Utils.isFunction = isFunction;
            function isBoolean(x) {
                return Object.prototype.toString.call(x) == '[object Boolean]';
            }
            Utils.isBoolean = isBoolean;
            function isNotEmptyString(x) {
                return isString(x) && x.length > 0;
            }
            Utils.isNotEmptyString = isNotEmptyString;
            function isVoid(x) {
                return x === null || x === undefined;
            }
            Utils.isVoid = isVoid;
            function isInteger(x) {
                return isNumber(x) && (x | 0) == x;
            }
            Utils.isInteger = isInteger;
            function isArrayIndex(x, a) {
                return isInteger(x) && isArray(a) && x >= 0 && x < a.length;
            }
            Utils.isArrayIndex = isArrayIndex;
            function isInRange(min, max, x) {
                return isNumber(x) && x >= min && x <= max;
            }
            Utils.isInRange = isInRange;
            function isAjaxRequest(r) {
                return isObject(r) && isNotEmptyString(r.type) && isNotEmptyString(r.url);
            }
            Utils.isAjaxRequest = isAjaxRequest;
            function isAjaxResponse(r) {
                return isDictionary(r) && ('status' in r);
            }
            Utils.isAjaxResponse = isAjaxResponse;
            function isEmptyObject(x) {
                for (var prop in x)
                    if (x.hasOwnProperty(prop))
                        return false;
                return true;
            }
            Utils.isEmptyObject = isEmptyObject;
            function isAsyncFunction(x) {
                return x && x[sIsAsync];
            }
            Utils.isAsyncFunction = isAsyncFunction;
            function isPromise(x) {
                return x instanceof Promise;
            }
            Utils.isPromise = isPromise;
            function isCollection(x) {
                return x && x.constructor === Collection;
            }
            Utils.isCollection = isCollection;
            function isModel(x) {
                return x instanceof Model;
            }
            Utils.isModel = isModel;
            function isProperty(x) {
                // it's debatable whether a property is a collection;
                // currently a collection looks almost exactly as a
                // property object: it has .get, .changed, .call and other
                // features, but doesn't have .set (but should) and
                // .then (also should)
                return x && x.constructor === Property;
            }
            Utils.isProperty = isProperty;
            function isCommand(x) {
                return x && x.constructor === Command;
            }
            Utils.isCommand = isCommand;
            function is(item, type) {
                var i, types = type.split('|');
                for (i = 0; i < types.length; i++)
                    if (types[i] in is.types && is.types[types[i]](item))
                        return true;
                return false;
            }
            Utils.is = is;
            function isThenable(obj) {
                // take into account promises that may be created
                // by other Promises/A+ compliant libraries, such
                // as Q - this function must recognize them as well
                return obj && isFunction(obj.then);
            }
            Utils.isThenable = isThenable;
            var is;
            (function (is) {
                is.types = {
                    String: isString,
                    NotEmptyString: isNotEmptyString,
                    Function: isFunction,
                    Dictionary: isDictionary,
                    Object: isObject,
                    Array: isArray,
                    Boolean: isBoolean,
                    Void: isVoid,
                    Number: isNumber
                };
            })(is = Utils.is || (Utils.is = {}));
            //#endregion
            //#region deepEqual
            /**
             * Deep comparison of two objects.
             *
             * This function considers two objects as equal if they contain the
             * same list of primitive properties (object properties are compared
             * using strict comparison).
             *
             * This function may be improved in the future when there is a need
             * to compare properties at deeper levels.
             *
             */
            function deepEqual(obj1, obj2) {
                var prop, t1 = typeof obj1, t2 = typeof obj2;
                // strict comparison (this will cover primitive types, including
                // undefined and null)
                if (obj1 === obj2)
                    return true;
                // both have to be object or function before continue
                if (t1 !== t2 || t1 !== 'object' && t1 !== 'function')
                    return false;
                if (obj1 === null || obj2 === null)
                    return obj1 === obj2;
                if (obj1 instanceof Date && obj2 instanceof Date)
                    return +obj1 == +obj2;
                // each property in obj1 must exist in obj2
                for (prop in obj1) {
                    if (!(prop in obj2) || obj1[prop] !== obj2[prop])
                        return false;
                }
                // each property in obj2 must exist in obj1
                for (prop in obj2) {
                    if (!(prop in obj1) || obj1[prop] !== obj2[prop])
                        return false;
                }
                return true;
            }
            Utils.deepEqual = deepEqual;
            //#endregion
            //#region HTML-related utilities
            /**
             * Escapes certain HTML (XML) characters to make a text input
             * usable as a HTML string. Consider the case when e remote party
             * sends a text/plain message with "<script>alert(1)</script>"
             * content and this text needs to be shown in HTML.
             */
            function convertTextToHtml(text) {
                return text
                    .replace(/[<>&;#/]/gm, function (chr) { return '&#' + chr.charCodeAt(0) + ';'; })
                    .replace(/\r\n|\n/gm, function () { return '<br>'; });
            }
            Utils.convertTextToHtml = convertTextToHtml;
            function parseHtml(html) {
                // Since a linebreak <br> is a void element, which doesn't require a closing tag, it violates
                // the parsing pattern for XML node. Have to replace any single linebreak with a space here.
                // Other void elements (such as <hr>, <img>, <input>, etc.), are not considered here, since
                // the lync client doesn't send them.
                var s = html.replace(/<br>/gim, '<br/>');
                if (!/^\s*<html\b[\s\S]*<\/html>\s*$/igm.test(s))
                    s = '<html><body>' + s + '</body></html>';
                return XmlNode(s).selectOne('body');
            }
            /**
             * Extracts text from html. This is done by parsing the given html
             * and merging all text nodes from it. It's useful to get the plain
             * text representation of an html message if the only format known is
             * html.
             *
             */
            function convertHtmlToText(html) {
                return parseHtml(html).text();
            }
            Utils.convertHtmlToText = convertHtmlToText;
            /**
             * Removes everything that can be used in an XSS attack.
             *
             * This is a basic sanitizer based on allow list. It first parses
             * html and css and then removes all not listed html tags, attributes
             * and css styles. This sanitizer is necessary to prevent XSS if
             * the UI developer makes a very common mistake:
             *
             *      document.getElementById(...).innerHTML = message.html();
             *
             * If the message html contains scripts or specially styled html tags,
             * that UI will be subject to XSS attacks.
             *
             * Obviously, there are quite safe html messages that will be corrupted
             * by this sanitizer, but their fraction is assumed to be small and the
             * allow list can be extended any time later.
             *
             */
            function sanitizeHtml(html) {
                var rxSafeTags = /^(body|b|i|u|s|span|table|tr|td|th|br|div|hr|p|h\d|font)$/i;
                var rxSafeAttrs = /^(style|width|height|color)$/i;
                var rxSafeStyles = /^(font(-[a-z]+)?|margin(-[a-z]+)?|line(-[a-z]+)?|color)$/i;
                function removeUnsafeAttrs(root) {
                    var name, attrs = root.attrs;
                    for (name in attrs) {
                        if (!rxSafeAttrs.test(name))
                            delete attrs[name];
                    }
                }
                function removeUnsafeStyles(root) {
                    var styles, name, str = root.attrs.style;
                    if (str) {
                        styles = Style(str);
                        for (name in styles) {
                            if (!rxSafeStyles.test(name))
                                delete styles[name];
                        }
                        root.attrs.style = styles + '';
                    }
                }
                function sanitize(root) {
                    var i, name, nodes = root.nodes;
                    removeUnsafeAttrs(root);
                    removeUnsafeStyles(root);
                    for (i = 0; i < nodes.length; i++) {
                        name = nodes[i].name();
                        if (name && !rxSafeTags.test(name))
                            removeAt(nodes, i--);
                        else
                            sanitize(nodes[i]);
                    }
                    return root;
                }
                try {
                    return html && sanitize(parseHtml(html)).nodes.join('');
                }
                catch (_) {
                    // Someone sent a broken html? This might be an XSS attack.
                    // But in case it's not, present at least the raw html contents
                    // with all html disabled: the message may contain something
                    // important to the user.
                    return disableHtmlInText(html);
                }
            }
            Utils.sanitizeHtml = sanitizeHtml;
            /**
             * Unescapes XML entities, such as &amp; and &#160;.
             * Such escaped entities can be found in XML tags.
             *
             *      unescapeXml('123 &amp; 456') == '123 & 456';
             *
             */
            function unescapeXml(escaped) {
                return escaped.replace(/&(#?\w+);/gm, function (str, num) {
                    return num.charAt(0) == '#' ? String.fromCharCode(+num.slice(1)) : unescapeXml.entities[num];
                });
            }
            var unescapeXml;
            (function (unescapeXml) {
                unescapeXml.entities = {
                    'lt': '<',
                    'gt': '>',
                    'amp': '&',
                    'nbsp': '\xA0',
                    'quot': '"'
                };
            })(unescapeXml || (unescapeXml = {}));
            //#endregion
            //#region disableHtmlInText
            /**
             * An attacker may send a message in the text/plain format with html inside:
             * the html can either aim at injecting a script into the destination page
             * or inject certain tags that would break the layout or show a popup window.
             * The problem applies not only to messages that can be sent in a conversation,
             * but also to all text data, such as a contact's note, a distribution group's
             * title, a conversation's subject and so on: they all can potentially contain
             * harmful html. Many webapps that uses the SDK contain a typical mistake:
             *
             *  document.getElementById("text123").innerHTML = message.text();
             *
             * In this case the attacker will be able to inject a script into such page.
             * To prevent this, the SDK alters all the text that comes from the server and
             * can be displayed in UI in such a way, that the text's appearance isn't affected,
             * but all potential harmful html constructs are disabled.
             *
             */
            function disableHtmlInText(text) {
                // U+2329 and U+232A are misc technical punctuation symbols
                return text && text.replace(/</gm, '\u2329').replace(/>/gm, '\u232a');
            }
            Utils.disableHtmlInText = disableHtmlInText;
            //#endregion
            //#region async
            /**
             * Converts a regular function into an "async" function
             * that always returns a promise. Works similarly to
             * the "async" function from the "Q" library.
             *
             * @param {Function} fn
             * @returns {Function} - This function always returns a promise.
             */
            function async(fn, mode) {
                // async(async(fn)) == async(fn)
                var fna = fn[sIsAsync] ? fn : function () {
                    try {
                        return Task.wait(fn.apply(this, arguments), mode);
                    }
                    catch (err) {
                        return Task().reject(err).promise;
                    }
                };
                setHiddenProperty(fna, sIsAsync, true);
                return fna;
            }
            Utils.async = async;
            //#endregion
            //#endregion various utils
            //#region Event
            /**
             * Encapsulates an event and provides capabilities to trigger the event and observe it.
             *
             * An event object is essentially a list of callbacks that are executed whenever the owner
             * of the event wants so. The event object is split into the event emitter that has all
             * the access to the event and the event observer that provides limited capabilities that are
             * enough to observe the event.
             *
             * @param {Function} [subscribed] - A callback to be executed after the first listener subscribes.
             * @param {Function} [unsubscribed] - A callback to be executed after the last listener unsubscribes.
             * @param {Function} [adding] - A callback to be executed before a new listener subscribes.
             * @param {Function} [added] - A callback to be executed after a new listener subscribes.
             * @param {Function} [removing] - A callback to be executed before a listener unsubscribes.
             * @param {Function} [removed] - A callback to be executed after a listener unsubscribes.
             *
             * @method fire - Invokes all listeners of the event.
             * @method {Boolean} observed - Tells whether the event has at least one listener.
             *
             * @member observer - An object that provides API to observe the event.
             *
             *      If JS allowed to override operators, it would be possible to implement
             *      adding and removing event listeners this way:
             *
             *          myEvent += myListener;
             *          myEvent -= myListener;
             *
             *      An anonymous event listener can unsubscribe itself if it's written with a function name,
             *      which is visible only inside that function:
             *
             *          person.changed = event.observer;
             *          person.changed(function fn() {
             *              console.log("the object has changed");
             *              person.changed.off(fn); // unsubscribe from the event
             *          });
             *
             *      event(123) can be used instead of event.fire(123) and observer(fn) can be used instead of
             *      observer.on(fn). Thus it's possible to redirect events this way:
             *
             *          event1 = Event();
             *          event2 = Event();
             *
             *          event1.observer(event2); // redirect event1 to event2
             *          event2('updated', 'abc', 123); // fire event2 - this triggers event2 as well
             *
             *      To remove an added event listener, one can invoke .dispose:
             *
             *          var changed = Event();
             *          var object = { changed: changed.observer };
             *
             *          var subscription = object.changed(fn); // adds an event listener
             *          subscription.dispose(); // removes the event listener
             *
             */
            function Event(options) {
                var self, opts = options || {}, observer = obs;
                function obs(listener, mode) {
                    // addListener cannot return anything because it modifies
                    // the internal state of the event and thus a call to it
                    // may be delayed and executed later; however the correponding
                    // removeListener call can be executed right away as the only
                    // argument it needs is the callback function which is known
                    observer.on(listener, mode);
                    // LWX/SWX wants to execute a custom function on the target
                    // property or collection after adding an event listener to it
                    if (isFunction(mode))
                        mode(this);
                    return new EventSubscription(observer, listener);
                }
                if (this instanceof Event)
                    self = this;
                else
                    return new Event(options);
                extend(self, opts);
                self._listeners = []; // callback functions
                self._modes = []; // "sync" or "async"
                self._locked = false; // synchronizes access to internal state
                self.observer = observer;
                setPrototypeOrExtend(observer, Event.prototype.observer);
                observer._event = self;
                return self;
            }
            Utils.Event = Event;
            function EventSubscription(event, listener) {
                this.event = event;
                this.listener = listener;
            }
            extend(EventSubscription.prototype, {
                dispose: function () {
                    this.event.off(this.listener);
                }
            });
            Event.prototype = function () { };
            extend(Event.prototype, {
                constructor: Event,
                fire: function () {
                    var self = this;
                    if (self._enqueue(self, self._fire, arguments))
                        return;
                    self._fire.apply(self, arguments);
                    self._dequeue();
                },
                _fire: function () {
                    var i, self = this;
                    for (i = 0; i < self._listeners.length; i++)
                        self._invoke(self._listeners[i], arguments, self._modes[i]);
                },
                _invoke: function (fn, args, mode) {
                    var self = this;
                    /* istanbul ignore if */
                    if (mode == 'async' && !isUnitTested) {
                        defer.call(self, self._invoke, fn, args, 'sync');
                    }
                    else {
                        try {
                            // this=null in event handlers
                            fn.apply(null, args);
                        }
                        catch (error) {
                            // if a handler throws an exception, it should not prevent other handlers
                            // from being invoked; however the thrown exception cannot be handled here,
                            // so it's just suppressed; Event._ie is a way for a unit test to specify
                            // an exception that needs to be ignored
                            Event.uncaught._event.fire(error);
                            /* istanbul ignore if */
                            if (error != Event._ie) {
                                // the error may be caused by a stack overflow and since a try..catch creates
                                // a new stack frame, this error handler cannot use another try..catch
                                if (console && console.log) {
                                    console.log(error && error.stack || error);
                                    console.log(Error().stack);
                                }
                                debugger;
                            }
                        }
                    }
                },
                _enqueue: function (ctx, fn, args) {
                    var self = this;
                    if (self._locked) {
                        self._queue = self._queue || [];
                        self._queue.push([ctx, fn, args]);
                    }
                    else {
                        self._locked = true;
                    }
                    return self._queue && self._queue.length > 0;
                },
                _dequeue: function () {
                    var q, self = this;
                    if (self._queue) {
                        while (q = self._queue.shift())
                            q[1].apply(q[0], q[2]);
                        self._queue = null;
                    }
                    self._locked = false;
                },
                observed: function () {
                    return this._listeners.length > 0;
                },
                observer: {
                    toString: function () {
                        var n = this._event._listeners.length;
                        return '[Event' + (n ? ': ' + n + ' listener' + (n == 1 ? '' : 's') : '') + ']';
                    },
                    /**
                     * Adds an event listener that is invoked synchronously.
                     * The second argument can be set to "async" if the listener
                     * needs to be executed asynchronously. This can be used in special cases.
                     *
                     * @param {Function} listener - A callback to be executed when the event gets fired.
                     *
                     *      To add a listener that will be invoked only once, use anonymous named
                     *      functions that have reference to themselves but aren't accessible outside:
                     *
                     *          event(function fn(message) {
                     *              event.off(fn);
                     *              console.log(message);
                     *          });
                     *
                     *      Note, that fn can be accessed only from inside fn.
                     *
                     * @param {String} [mode="sync"] - Tells how the listener should be invoked.
                     *
                     *      If an object o1 goes to state s1 and fires an event e1 to notify
                     *      about this change, then a handler h1 of this event must observe
                     *      the object in state s1. If o1 fired e1 asynchronously, then h1 could
                     *      catch e1 at the moment when o1 is no longer in state s1. However if s1
                     *      is the final state of o1, then e1 may be fired asynchronously. This is
                     *      the cases for promise objects: the resolved or the rejected states are
                     *      final for them. This is why all events are synchronous by default.
                     */
                    on: function (listener, mode) {
                        var self = this._event;
                        if (self._enqueue(this, this._addListener, [listener, mode]))
                            return;
                        this._addListener(listener, mode);
                        self._dequeue();
                    },
                    _addListener: function (listener, mode) {
                        var self = this._event;
                        assert(isFunction(listener));
                        if (self.adding)
                            self.adding.call(self.context, listener);
                        self._listeners.push(listener);
                        self._modes.push(mode);
                        if (self.added)
                            self.added.call(self.context, listener);
                        if (self._listeners.length == 1 && self.subscribed)
                            self.subscribed.call(self.context);
                    },
                    off: function (listener) {
                        var self = this._event;
                        if (self._enqueue(this, this._removeListener, [listener]))
                            return;
                        this._removeListener(listener);
                        self._dequeue();
                    },
                    _removeListener: function (listener) {
                        var self = this._event;
                        var i = indexOf(self._listeners, listener);
                        if (i >= 0) {
                            self._listeners.splice(i, 1);
                            self._modes.splice(i, 1);
                            if (self._listeners.length == 0 && self.unsubscribed)
                                self.unsubscribed.call(self.context);
                        }
                    }
                }
            });
            var Event;
            (function (Event) {
                Event.uncaught = Event().observer;
                Event._ie;
            })(Event = Utils.Event || (Utils.Event = {}));
            //#endregion
            //#region Task (a Promise/A+ compliant implementation)
            /**
             * An instance of Task represents an asynchronously returned value
             * or an asynchronously thrown exception. Task corresponds to C#'s Task.
             *
             * A task can be resolved or rejected. Resolving a task means returning a value
             * asynchronously; rejecting it - throwing an exception asynchronously.
             *
             * A task is a promise to eventually return the result of an asynchronous operation.
             * If the operation succeeds the function resolves the task supplying the operation result.
             * If the operation fails the function rejects the task providing the failure reason (exception).
             *
             * There is an interesting limitation on the the implementation of Task:
             * it cannot invoke Property::set because this method creates a resolved
             * promise that invokes Property::set that creates a resolved promise...
             * However Task can invoke Property::call because it does not
             * create a promise and returns whatever was in `this` reference.
             *
             * @param {String} [initialStatus] - The initial value for the Task::status property.
             * @param {Function} [cancel] - A function that cancels this particular task.
             * @param {String} [mode="async"] - The way Task::then will attach callbacks.
             *
             * @method resolve(result)
             * @method reject(error)
             * @method {Promise} promise.then - Sets completion callbacks for an async operation.
             *
             *      In many languages this .then method is augmented with the language-level
             *      keyword usually called "await" - it does the very same thing as .then,
             *      except that it allows to write code in a more clear manner. Search for
             *      strawman:async_functions for detailed explanations.
             *
             *      .then is typically used right after invoking an async function, i.e. a
             *      function that returns a promise, to handle the result of the function
             *      after that result becomes available:
             *
             *          ucwa.send("GET", ".../me").then(function (response) {
             *              console.log(response);
             *          });
             *
             *      With the "await" keyword this code snippet can be rewritten as:
             *
             *          console.log(await ucwa.send("GET", ".../me"));
             *
             *      In its most complete form, .then(done, fail, info) accepts 3 callbacks:
             *
             *          - `done` is invoked after the operation succeeds
             *          - `fail` is invoked after the operation fails
             *          - `info` is invoked whenever the operation wants to report progress
             *
             *      A call to .then returns another promise which is resolved or rejected
             *      depending on whether the done/fail handler returns a value or throws
             *      an exception. Note, that the done/fail handler may return another promise
             *      and then that promise will be awaited via a call to its .then method.
             *
             * @method {Promise} promise.catch - Sets an error handler for an async operation.
             *
             *      A call to .catch corresponds to wrapping an "await" into a try..catch.
             *      .catch is typically used as the very last handler of a complete async
             *      flow to handle all possible errors:
             *
             *          ucwa.send("GET", ".../me").catch(function (error) {
             *              console.log(error);
             *          });
             *
             *      With the "await" keyword this code snippet can be rewritten as:
             *
             *          try {
             *              await ucwa.send("GET", ".../me");
             *          } catch (error) {
             *              console.log(error);
             *          }
             *
             *      Note, that if the error handler returns a value, it essentially
             *      handles the error and the new promise returned by .catch is resolved;
             *      if it throws na exception, that promise gets rejected.
             *
             * @method {Promise} promise.finally - An async version of try..finally.
             *
             *      This method is a part of the Promise interface proposed in ES7.
             *      The intent is to simulate the try..finally construct for promises:
             *      a handler attached via .finally gets invoked no matter whether the
             *      promise has been resolved or rejected and the handler cannot read or
             *      alter the result. However if the handler fails, the thrown exception
             *      gets propagated.
             *
             *          ucwa.send("GET", ".../me").finally(function () {
             *              console.log("GET has succeeded or failed");
             *          });
             *
             *      With the "await" keyword this code snippet can be rewritten as:
             *
             *          try {
             *              await ucwa.send("GET", ".../me");
             *          } finally {
             *              console.log("GET has succeeded or failed");
             *          }
             *
             *      Typically .finally is used to add a final handler that will do some
             *      cleanup after the async operation completes.
             *
             * @method promise.cancel(reason) - Cancels the task.
             *
             *      Every complex async operation, such as "sign in" consists of
             *      several stages where every stage is represented by a Task instance.
             *      For example such stages can be "awaiting xframe", "awaiting GET /me",
             *      or "waiting in the throttling queue": all these stages are
             *      essentially instances of Task that get resolved by their owners
             *      in due course.
             *
             *      Owners of these tasks may specify a custom callback that knows
             *      how to cancel this particular task. For instance, in case of
             *      "awaiting xframe" task the cancellation routine would cancel
             *      the timer and possibly remove the xframe from the DOM tree;
             *      in case of "waiting in the throttling queue" the cancellation
             *      routine would remove the request from the queue.
             *
             *      A task may have multiple branches (called "promises") and each branch
             *      has the "cancel" method that attempts to find the current task
             *      and invoke its cancel method. If the current task was given the
             *      cancellation routine, the Task::cancel would succeed and reject the
             *      current task (which results in invoking the "fail" handler of attached
             *      branches and those handlers may initiate other async operations).
             *      If the current task was not given the cancellation routine (because
             *      the owner of this operation was too lazy to implement it), Task::cancel
             *      would just reject the task.
             *
             * @property status - Contains the current status of the task.
             *
             *      The value of status is set by an owner of the task: if it created an instance of Task,
             *      it may update its status. The Task's code does not modify the status and is responsible
             *      only for pipelining its value down the chain of promises created by Task::then method.
             *
             * @property state - It can be "pending", "resolved" or "rejected".
             *
             *      Task::state should not be confused with Task::status.
             *      Task::state reflects the current state of the underlining async operation.
             *      Task::status is a description in a general form (that does not even have
             *      to be a string) that is set by the owner of the task and cannot be used
             *      to determine the state of the task.
             *
             */
            function Task(initialStatus, args) {
                if (!(this instanceof Task))
                    return new Task(initialStatus, args);
                if (!isString(initialStatus)) {
                    args = initialStatus;
                    initialStatus = void 0;
                }
                args = args || {};
                var self = this, _ = {}; // internal state
                _.leafs = []; // tasks created by the .then method        
                _.state = 'pending'; // pending/resolved/rejected
                // TODO: In most cases .status is not used directly.
                // Thus it can be created lazily once someone needs it.
                // The complexity here is caused by the way status propagation
                // works in the tree of tasks created by the .then method.
                _.status = Property({ value: initialStatus });
                if (args.mode)
                    _.mode = args.mode;
                if (args.cancel)
                    _.fnCancel = args.cancel;
                _.promise = new TaskPromise(self);
                extend(self, {
                    _: _,
                    status: _.status,
                    promise: _.promise
                });
            }
            Utils.Task = Task;
            extend(Task.prototype, {
                resolve: function (result) {
                    var self = this, _ = self._;
                    if (_.state == 'resolved' && _.value === result)
                        return self;
                    check.state(_.state, 'pending');
                    _.value = result;
                    _.state = 'resolved';
                    if (_.$state)
                        _.$state._set(_.state);
                    _.promise.result = result;
                    return self._complete();
                },
                reject: function (error) {
                    var self = this, _ = self._;
                    if (_.state == 'rejected' && _.value === error)
                        return self;
                    check.state(_.state, 'pending');
                    _.value = error;
                    _.state = 'rejected';
                    if (_.$state)
                        _.$state._set(_.state);
                    _.promise.error = error;
                    return self._complete();
                },
                _complete: function () {
                    var self = this, _ = self._;
                    _.status(null);
                    for (var i = 0; i < _.leafs.length; i++)
                        _.leafs[i]();
                    _.fnCancel = null; // it holds a ref to the parent task
                    return self;
                }
            });
            function TaskPromise(task) {
                this.task = task;
                Object.defineProperty(this, 'state', {
                    get: this._getState
                });
                Object.defineProperty(this, 'status', {
                    get: this._getStatus
                });
            }
            TaskPromise.prototype = inherit(Promise.prototype, {
                _getState: function () {
                    var _ = this.task._;
                    if (!_.$state) {
                        _.$state = Property({
                            value: _.state,
                            readOnly: true
                        });
                    }
                    return _.$state;
                },
                _getStatus: function () {
                    var _ = this.task._;
                    return _.status.asReadOnly();
                },
                from: function (promise) {
                    var self = this.task, _ = self._;
                    if (this.locked) {
                        this.target.from(promise);
                    }
                    else {
                        _.source = promise;
                        _.source.then(function (res) { return self.resolve(res); }, function (err) { return self.reject(err); }, _.status);
                        _.fnCancel = function (reason) {
                            _.source.cancel(reason);
                        };
                        if (_.source.locked)
                            _.source.target = this;
                    }
                },
                cancel: function (reason) {
                    var self = this.task, _ = self._;
                    check.state(_.state, 'pending');
                    if (_.fnCancel)
                        _.fnCancel(reason);
                    else
                        self.reject(reason);
                },
                then: function (fnDone, fnFail, fnInfo) {
                    var self = this.task, _ = self._;
                    var result, task = Task({ cancel: detach });
                    var exec = _.mode == 'sync' ? handle : bind(defer, handle);
                    function handle() {
                        _.status.changed.off(update);
                        try {
                            if (_.state == 'resolved')
                                result = isFunction(fnDone) ? fnDone(_.value) : _.value;
                            else if (isFunction(fnFail))
                                result = fnFail(_.value);
                            else
                                throw _.value;
                        }
                        catch (error) {
                            task.reject(error);
                            return;
                        }
                        if (isThenable(result))
                            task.promise.from(Task.wait(result));
                        else
                            task.resolve(result);
                    }
                    function update(text, reason) {
                        if (_.state == 'pending') {
                            task.status(text, reason);
                            if (isFunction(fnInfo))
                                fnInfo(text, reason);
                        }
                    }
                    function detach(reason) {
                        if (_.leafs.length < 2) {
                            _.promise.cancel(reason);
                        }
                        else {
                            removeAt(_.leafs, indexOf(_.leafs, exec));
                            _.status.changed.off(update);
                            try {
                                if (isFunction(fnFail))
                                    task.promise.from(Task.wait(fnFail(reason)));
                                else
                                    task.reject(reason);
                            }
                            catch (error) {
                                task.reject(error);
                            }
                        }
                    }
                    if (_.state == 'pending') {
                        _.status.changed(update);
                        _.leafs.push(exec);
                    }
                    else {
                        exec();
                    }
                    return task.promise;
                }
            });
            var Task;
            (function (Task) {
                //#region Task.waitAny
                /**
                 * Awaits the given tasks and stops waiting after the any of them resolves,
                 * then it cancels all pending tasks. For example, waiting for any of a few
                 * requests to succeed (or all of them to fail) can be done like this:
                 *
                 *      Task.waitAny([
                 *          ucwa.send("GET", "/me/name"),
                 *          ucwa.send("POST", "/me/makeAvailable", { data : { ... } })
                 *      ]);
                 *
                 * If JS allowed to overload operators, then this function could be replaced
                 * with the overloaded | operator for the Promise class.
                 *
                 * @param {Promise[]} promises
                 * @returns {Promise} - It gets resolved after any of the given tasks resolve.
                 */
                function waitAny(promises) {
                    var nPending = promises.length;
                    var task = Task({ cancel: cancel });
                    var promise = task.promise;
                    if (nPending == 1)
                        promise = Task.wait(promises[0]);
                    else if (nPending == 0)
                        task.reject(Error());
                    else {
                        foreach(promises, function (p) {
                            p.then(function (res) {
                                nPending--;
                                if (task) {
                                    task.resolve(res);
                                    task = null;
                                    // cancel all other tasks: they are not needed anymore
                                    cancel(Exception('CompetingTaskResolved'));
                                }
                            }, function (err) {
                                nPending--;
                                if (!nPending) {
                                    // all tasks has failed
                                    task.reject(err);
                                    task = null;
                                }
                            }, function () {
                                var texts = map(promises, function (p, i) {
                                    return p.status() || '#' + i;
                                });
                                if (task)
                                    task.status(texts.join(' || '));
                            });
                        });
                    }
                    function cancel(reason) {
                        foreach(promises, function (p) {
                            try {
                                // this will cause the task returned by Task.waitAny to fail
                                p.cancel(reason);
                            }
                            catch (err) {
                            }
                        });
                    }
                    return promise;
                }
                Task.waitAny = waitAny;
                //#endregion
                //#region Task.waitAll
                /**
                 * Creates a promise that gets resolved after all the given
                 * promises succeed and get rejected after any of the given
                 * promises fail.
                 *
                 * If JS allowed to overload operators, then this function could be replaced
                 * with the overloaded & operator for the Promise class.
                 *
                 * @param {Promise[]} promises
                 * @returns {Promise}
                 *
                 *      This promise gets resolved to the array of results
                 *      from the given array of promises.
                 *
                 */
                function waitAll(promises) {
                    var nPending = promises.length;
                    var results = [];
                    var task = Task({ cancel: cancel });
                    var promise = task.promise;
                    var unresolved = {};
                    results.length = promises.length;
                    if (nPending == 0) {
                        task.resolve([]);
                    }
                    else if (nPending == 1) {
                        promise = Task.wait(promises[0]).then(function (r) {
                            return [r];
                        });
                    }
                    else {
                        foreach(promises, function (p, i) {
                            unresolved[i] = promises[i] = Task.wait(p);
                        });
                        refresh();
                        foreach(promises, function (promise, i) {
                            promise.then(function (result) {
                                results[i] = result;
                                delete unresolved[i];
                                refresh();
                                nPending--;
                                if (!nPending) {
                                    task.resolve(results);
                                    task = null;
                                }
                            }, function (error) {
                                delete unresolved[i];
                                nPending--;
                                if (task) {
                                    task.reject(error);
                                    task = null;
                                    cancel(error);
                                }
                            }, refresh);
                        });
                    }
                    function cancel(reason) {
                        for (var i = 0; i < promises.length; i++) {
                            try {
                                if (promises[i].state() == 'pending')
                                    promises[i].cancel(reason);
                            }
                            catch (error) {
                            }
                        }
                    }
                    function refresh() {
                        var ts = map(unresolved, function (p, i) {
                            return p.status() || '#' + i;
                        });
                        if (task)
                            task.status(values(ts).join(' && '));
                    }
                    return promise;
                }
                Task.waitAll = waitAll;
                //#endregion
                //#region Task.wait
                /**
                 * This function simplifies writing functions that expect
                 * promises as arguments. An example of use:
                 *
                 *      var data = ...;
                 *      Task.wait(data).then(function (text) {
                 *          ...
                 *      });
                 *
                 * Then no matter whether "data" was a plain string or a promise
                 * that resolves to a string, the code snippet above will work.
                 *
                 * This function can also be used to cast foreign promises into
                 * our own (native) promises. Consider a sample that creates a ES7 promise
                 * object and casts it to a SkypeWeb's promise:
                 *
                 *      var es7promise = new Promise(function (resolve) {
                 *          setTimeout(resolve, 1500);
                 *      });
                 *
                 *      var promise = Task.wait(es7promise);
                 *      assert.equal(promise.state(), 'pending');
                 *
                 * @param {String} [mode] - either 'sync' or 'async'
                 *
                 * @returns {Promise}
                 */
                function wait(obj, mode) {
                    return isPromise(obj) ? obj :
                        isThenable(obj) ? Promise(bind.call(obj, obj.then)) :
                            Task({ mode: mode }).resolve(obj).promise; // if this is a value
                }
                Task.wait = wait;
            })(Task = Utils.Task || (Utils.Task = {}));
            //#region Promise
            /**
             * This is the proposed in ES7 interface of a Promise to the Task class.
             * This interface is more convenient to use when constructing promise
             * objects inline. An example of use:
             *
             *      Promise(function (resolve, reject, notify) {
             *          notify("waiting for 1.5 seconds");
             *          setTimeout(resolve, 1500); // resolve the promise after 1.5 seconds
             *      }).then(function () {
             *          ...
             *      });
             *
             * This way of constructing promise object doesn't allow to specify
             * the cancellation procedure or to report progress.
             *
             * @param {Function} then
             */
            function Promise(then) {
                var task = Task();
                try {
                    then(function (res) { return task.resolve(res); }, function (err) { return task.reject(err); }, task.status);
                }
                catch (err) {
                    // `then` may throw an exception after
                    // resolving or rejecting the promise
                    if (task.promise.state() == 'pending')
                        task.reject(err);
                }
                return task.promise;
            }
            Utils.Promise = Promise;
            // it's important to not overwrite the original prototype,
            // but to extend it because objects inherited from the original
            // prototype are nicely displayed in the debugger
            extend(Promise.prototype, {
                catch: function (handler) {
                    return this.then(null, handler || Utils.noop);
                },
                finally: function (handler) {
                    return this.then(function (res) { return Task.wait(handler()).then(function () { return res; }); }, function (err) { return Task.wait(handler()).then(function () { throw err; }); });
                }
            });
            //#endregion
            //#region Pattern
            /**
             * A pattern is an object with a parsing function that
             * reads a given input string from a given position,
             * parses it and returns whatever it has parsed with
             * the position where the parsing ended. A composition
             * of such parsing function constitutes an LL(k) recursive
             * descent parser.
             *
             */
            var Pattern = (function () {
                // the "private" modifier tells ts to create a class member with this name
                // and make an assignment in the constructor: this._exec = _exec
                function Pattern(_exec) {
                    this._exec = _exec;
                }
                // this method implements both signatures above; note that
                // the return type is "any" - that's the only common type
                // between T and [T, number]; also note the
                // default value for pos: ts determines the absence of the
                // parameter by comparing it with (void 0), not by checking
                // the number of arguments
                Pattern.prototype.exec = function (str, pos) {
                    if (pos === void 0) { pos = 0; }
                    var r = this._exec(str, pos);
                    if (arguments.length == 2)
                        return r;
                    if (!r || r[1] != str.length)
                        return null;
                    return r[0];
                };
                Pattern.prototype.then = function (fn) {
                    var _this = this;
                    return new Pattern(function (str, pos) {
                        // note, how the arrow function captures `this` from outside
                        var r = _this.exec(str, pos);
                        if (!r)
                            return null;
                        var res = r[0], end = r[1];
                        return [fn(res, str, pos, end), end];
                    });
                };
                Pattern.prototype.text = function () {
                    return this.then(function (res, str, pos, end) { return str.slice(pos, end); });
                };
                Pattern.prototype.select = function (key) {
                    return this.then(function (r) { return r[key]; });
                };
                // ts lacks a way to express the fact that this method
                // can  be called only if T is an array type, i.e. any[]
                Pattern.prototype.merge = function (sep) {
                    if (sep === void 0) { sep = ''; }
                    // ...so I had to trick ts and coerce T to any[]
                    return this.then(function (r) { return r.join(sep); });
                };
                Pattern.prototype.join = function (key, val) {
                    return this.then(function (r) {
                        var map = {};
                        for (var _i = 0, _a = r; _i < _a.length; _i++) {
                            var pair = _a[_i];
                            map[pair[key]] = pair[val];
                        }
                        return map;
                    });
                };
                return Pattern;
            })();
            /** txt = "abc" */
            function txt(text) {
                return new Pattern(function (str, pos) {
                    if (str.slice(pos, pos + text.length) == text)
                        return [text, pos + text.length];
                });
            }
            /** rgx = /[a-z]+/ */
            function rgx(regexp) {
                return new Pattern(function (str, pos) {
                    var m = regexp.exec(str.slice(pos));
                    if (m && m.index == 0)
                        return [m[0], pos + m[0].length];
                });
            }
            /** opt = [something] */
            function opt(p, defvalue) {
                return new Pattern(function (str, pos) { return p.exec(str, pos) || [defvalue, pos]; });
            }
            /** escaped-char = any-char ~ double-quote */
            function exc(pattern, except) {
                return new Pattern(function (str, pos) { return !except.exec(str, pos) && pattern.exec(str, pos); });
            }
            /** seq = abc def ghi ... */
            function seq() {
                var patterns = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    patterns[_i - 0] = arguments[_i];
                }
                return new Pattern(function (str, pos) {
                    var results = [];
                    for (var _i = 0; _i < patterns.length; _i++) {
                        var p = patterns[_i];
                        var r = p.exec(str, pos);
                        if (!r)
                            return;
                        results.push(r[0]);
                        pos = r[1];
                    }
                    return [results, pos];
                });
            }
            /** any = abc | def | ghi | ... */
            function any() {
                var patterns = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    patterns[_i - 0] = arguments[_i];
                }
                return new Pattern(function (str, pos) {
                    for (var _i = 0; _i < patterns.length; _i++) {
                        var p = patterns[_i];
                        var r = p.exec(str, pos);
                        if (r)
                            return r;
                    }
                });
            }
            /** rep = *pattern */
            function rep(pattern) {
                return new Pattern(function (str, pos) {
                    var r, results = [];
                    while (r = pattern.exec(str, pos)) {
                        results.push(r[0]);
                        pos = r[1];
                    }
                    return [results, pos];
                });
            }
            /** sep = [attr *(comma attr)] */
            function sep(pattern, separator) {
                var separated = seq(separator, pattern).select(1);
                var sequence = seq(pattern, rep(separated)).then(function (r) { return [r[0]].concat(r[1]); });
                return opt(sequence, []);
            }
            function quoted(lquote, rquote) {
                var esc = rgx(/\\./).then(function (str) { return str.slice(1); });
                var chr = any(esc, exc(rgx(/./), rquote));
                return seq(lquote, rep(chr), rquote).select(1).merge();
            }
            //#endregion
            //#region DataUri (an RFC 2397 compliant implementation)
            /**
             * Parses or constructs a data uri string compliant with RFC 2397.
             *
             * UCWA server sends instant messages in the data uri format and
             * this class can be involved to parse them.
             *
             * Data URLs have to be parsed because SkypeWeb needs to extract separate
             * attributes from them and this cannot be done with a regular expression.
             *
             * @example
             *
             *      var uri = DataUri('data:text/plain;charset=utf-8,How+are+you%3f');
             *
             *      uri.mime == 'text/plain';
             *      uri.attributes.charset == 'utf-8';
             *      uri.data == 'How are you?';
             *
             */
            function DataUri(string) {
                var parts = DataUri.pattern.exec(string);
                if (!parts)
                    throw new SyntaxError('Invalid data URL: ' + string);
                return parts;
            }
            Utils.DataUri = DataUri;
            var DataUri;
            (function (DataUri) {
                function encodeData(data) {
                    return encodeURIComponent(data).replace(/%20/gm, '+');
                }
                DataUri.encodeData = encodeData;
                function decodeData(data) {
                    return decodeURIComponent(data.replace(/\+/gm, ' '));
                }
                DataUri.decodeData = decodeData;
                ;
            })(DataUri = Utils.DataUri || (Utils.DataUri = {}));
            /**
             * Parsing rules (ABNF) from RFC 2397 and RFC 2045:
             *
             *      dataurl     := "data:" [ mediatype ] [ ";base64" ] "," data
             *      mediatype   := [ token "/" token ] *( ";" parameter )
             *      data        := *urlchar
             *      parameter   := attribute "=" value
             *      attribute   := token ; Matching of attributes is ALWAYS case-insensitive.
             *      value       := token / quoted-string
             *      token       := 1*<any (US-ASCII) CHAR except SPACE, CTLs, or tspecials>
             *      tspecials   :=  "(" / ")" / "<" / ">" / "@" / "," / ";" / ":" / "\" / <"> / "/" / "[" / "]" / "?" / "="
             */
            var DataUri;
            (function (DataUri) {
                var token = rgx(/[^()<>@,;:\\\x22/\[\]?=\s]+/);
                var mime = seq(token, txt('/'), token).merge();
                var data = rgx(/[^\uffff]*/).then(DataUri.decodeData);
                var str = quoted(txt('"'), txt('"'));
                var val = seq(rgx(/\s*=\s*/), any(str, token)).select(1);
                var attr = seq(rgx(/\s*;\s*/), token, opt(val, true));
                DataUri.pattern = seq(txt('data:'), opt(mime), rep(attr).join(1, 2), rgx(/\s*,\s*/), data)
                    .then(function (_a) {
                    var m = _a[1], a = _a[2], d = _a[4];
                    return ({ mime: m, attributes: a, data: d, base64: !!a['base64'] });
                });
            })(DataUri = Utils.DataUri || (Utils.DataUri = {}));
            //#endregion
            //#region Style (CSS)
            /**
             * Parses a CSS style of the following form:
             *
             *      position: fixed;
             *      color: red;
             *      font: Arial 10px;
             *
             */
            function Style(text) {
                if (!(this instanceof Style))
                    return new Style(text);
                var parsed = Style.pattern.exec(text);
                if (!parsed)
                    throw new SyntaxError('Invalid CSS style: ' + text);
                extend(this, parsed);
            }
            Utils.Style = Style;
            /**
             * Parsing rules (ABNF):
             *
             *      style       := kvpair *( ";" kvpair ) ";"?
             *      kvpair      := name ":" 1*value
             *      name        := <dashes are allowed in names>
             *      value       := string / measure / name / color
             *      string      := <single-quoted or double-quoted string>
             *      measure     := number ["%" / "pt" / "px" / "em"]
             *      number      := <floating point number>
             *      color       := "#" 1*hexdigit
             *
             */
            var Style;
            (function (Style) {
                // parsing a style could've been as simple as splitting
                // the input at ";" symbols and then at ":" symbols if
                // css didn't allow quoted and double-quoted strings in
                // style values, i.e. font: "Arial";
                var wsp = rgx(/[\x00-\x20]+/);
                var color = rgx(/#[\da-fA-F]+/i); // in css #f80 = #ff8800
                var number = rgx(/[+-]?\d+([.]\d+)?/); // that's a bit stricter than needed
                var measure = seq(number, opt(rgx(/%|[a-z]+/i))).text(); // ie. 12.3px
                var string = any(quoted(txt('"'), txt('"')), quoted(txt("'"), txt("'")));
                var name = rgx(/[a-z][a-z-]*[a-z]/i); // dashes are allowed only inside the name
                var value = any(measure, string, name, color).text(); // url('...')-like things aren't handled
                var kvpair = seq(name.text(), opt(wsp), txt(':'), opt(wsp), sep(value, wsp));
                var separator = seq(opt(wsp), txt(';'), opt(wsp));
                // another option would be to allow empty styles between semicolons:
                // this would simplify this pattern, but the .join(...) below will have
                // to become more complicated in order to handle empty styles
                var style = seq(sep(kvpair, separator), opt(separator)).select(0);
                // well, .join(...) won't work if the same style name appears twice,
                // which is allowed in css and means that the style definition is
                // split across multiple lines
                Style.pattern = style.join(0, 4);
            })(Style = Utils.Style || (Utils.Style = {}));
            setHiddenProperty(Style.prototype, 'toString', function () {
                var name, lines = [], styles = this;
                for (name in styles)
                    lines.push(name + ':' + styles[name].join(' '));
                return lines.join(';');
            });
            //#endregion
            //#region XmlNode
            /**
             * Reconstitutes a tree of XML nodes from their textual representation.
             *
             * @method {String} name - Returns the tag name of the node.
             * @method {String} text - Returns the text content of the node.
             * @method {String} attr - Returns value of the given attribute.
             *
             * @member {Map<String, String>} attrs - All attributes as a dictionary.
             * @member {XmlNode[]} nodes - All inner nodes.
             *
             * @method {XmlNode} selectOne - Searches for a specific child node.
             *
             */
            function XmlNode(input) {
                if (!(isString(input) || input && input.ast))
                    throw new Error('Invalid argument: ' + input);
                if (!(this instanceof XmlNode))
                    return new XmlNode(input);
                var ast, err;
                try {
                    ast = input.ast || XmlNode.pattern.exec(input); // AST of the XML
                    if (!ast)
                        throw void 0;
                }
                catch (reason) {
                    err = new SyntaxError('Invalid XML: ' + input);
                    err.reason = reason;
                    throw err;
                }
                var attrs = ast.attrs || {};
                var nodes = (ast.nodes || []).map(function (node) {
                    return XmlNode({ ast: isString(node) ? { text: node } : node });
                });
                var join = function (text, node) { return text + node.text(); };
                var name = function () { return ast.name; };
                var text = function () { return ast.text || nodes.reduce(join, ''); };
                this.attrs = attrs;
                this.nodes = nodes;
                this.name = name;
                this.text = text;
            }
            Utils.XmlNode = XmlNode;
            XmlNode.prototype.toString = function () {
                var attrs = '', content = '', root = this, name = root.name();
                foreach(root.attrs, function (val, key) {
                    attrs += ' ' + key;
                    if (!isVoid(val))
                        attrs += '="' + val.replace(/\x22/gm, '&quot;') + '"';
                });
                foreach(root.nodes, function (node) {
                    content += node;
                });
                content = content || root.text().replace(/</gm, '&lt;').replace(/>/gm, '&gt;');
                return !name ? content :
                    !content ? '<' + name + attrs + '/>' :
                        '<' + name + attrs + '>' + content + '</' + name + '>';
            };
            XmlNode.prototype.attr = function (name) {
                assert(name in this.attrs, 'Attribute does not exist: ' + this.name() + '.' + name);
                return this.attrs[name];
            };
            XmlNode.prototype.selectOne = function (name, attrs) {
                var nodes = filter(this.nodes, isFunction(name) ? name : function (node) {
                    var attr, lca;
                    // attribute names are lower cased by the parser
                    if (attrs) {
                        for (attr in attrs) {
                            lca = attr.toLowerCase();
                            if (attrs[lca] != node.attrs[lca])
                                return false;
                        }
                    }
                    // node names are lower cased by the parser
                    return node.name() == name.toLowerCase();
                });
                assert(nodes.length == 1, 'Single node expected: ' + name);
                return nodes[0];
            };
            /**
             * Parsing rules (ABNF) for the XML subset supported by this implementation:
             *
             *      xml-node    := open-tag *(xml-node / text) close-tag / empty-tag
             *      open-tag    := "<" name *attr ">"
             *      close-tag   := "</" name ">"
             *      empty-tag   := "<" name *attr "/>"
             *      attr        := name ["=" quoted-string]
             *      text        := <an xml-escaped text>
             *      name        := <a case insensitive name>
             */
            var XmlNode;
            (function (XmlNode) {
                var wsp = rgx(/[\x00-\x20]*/);
                var qstr = rgx(/\x22[^\x22]*\x22/).then(function (s) { return s.slice(+1, -1); });
                var rawval = rgx(/[^\s<>\x22]+/);
                var value = any(qstr, rawval).then(unescapeXml);
                var text = rgx(/[^<]+/m).then(unescapeXml);
                var name = rgx(/[\w\d:-]+/).then(function (s) { return s.toLowerCase(); });
                var attr = seq(name, opt(seq(wsp, txt('='), wsp, value).select(3)));
                var attrs = sep(attr, wsp).join(0, 1);
                var opentag = seq(txt('<'), wsp);
                var closetag = seq(wsp, txt('>'));
                var open = seq(opentag, name, wsp, attrs, closetag).then(function (r) { return ({ name: r[1], attrs: r[3] }); });
                var empty = seq(opentag, name, wsp, attrs, seq(wsp, txt('/>'))).then(function (r) { return ({ name: r[1], attrs: r[3] }); });
                var close = seq(txt('</'), wsp, name, closetag).select(2);
                var node = new Pattern(function (str, pos) { return XmlNode.pattern.exec(str, pos); });
                var full = seq(open, rep(any(node, text)), close).then(function (_a) {
                    var open = _a[0], nodes = _a[1], close = _a[2];
                    if (open.name != close)
                        throw new SyntaxError('</' + close + '> does not match <' + open.name + '>');
                    return { name: close, nodes: nodes, attrs: open.attrs };
                });
                XmlNode.pattern = any(full, empty);
            })(XmlNode = Utils.XmlNode || (Utils.XmlNode = {}));
            //#endregion
            //#region XmlDoc
            /**
             * @param {String} src - XML representation of the document.
             *
             * @member {XmlNode} root
             */
            function XmlDoc(src) {
                return {
                    // <?xml version="1.0" encoding="utf-8"?>
                    // needs to be removed before parsing XML
                    root: XmlNode(trim(src.replace(/^<\?.+?\?>/, '')))
                };
            }
            Utils.XmlDoc = XmlDoc;
            //#endregion
            //#region WWWAuthenticateHeader
            /**
             * Represents the "WWW-Authenticate" HTTP header
             * that contains information about how to get the auth token.
             * Here is an example of how it may look:
             *
             *      Basic realm="johndoe@contoso.com",Digest realm="testrealm@host.com", qop="auth,auth-int"
             *
             * @param {string} text - The value of the "WWW-Authenticate" header.
             *
             * @example
             *
             *      var auth = WWWAuthenticateHeader(
             *          'Bearer client_id="0", uri="qq://login" + '\n' +
             *          'MsRtcOAuth href="qq://login/token",grant_type="urn:microsoft.rtc:passive,urn:microsoft.rtc:anonmeeting"');
             *
             *      auth.Bearer.client_id === "0";
             *      auth.Bearer.uri === "qq://login";
             *      auth.MsRtcOAuth.href === "qq://login/token";
             *      auth.MsRtcOAuth.grant_type === "urn:microsoft.rtc:passive,urn:microsoft.rtc:anonmeeting";
             *
             */
            function WWWAuthenticateHeader(text) {
                var parts = WWWAuthenticateHeader.pattern.exec(text || '');
                if (parts)
                    return parts;
                throw new SyntaxError('Invalid WWW-Authenticate header:\n' + text);
            }
            Utils.WWWAuthenticateHeader = WWWAuthenticateHeader;
            /**
             *  ABNF rules for the WWW-Authenticate header:
             *
             *  www-auth        := *( challenge )
             *  challenge       := scheme *( param )
             *  param           := param-name "=" param-value
             *  scheme          := token
             *  param-name      := token
             *  param-value     := quoted-string
             */
            var WWWAuthenticateHeader;
            (function (WWWAuthenticateHeader) {
                var comma = rgx(/[\s,]*/);
                var name = rgx(/[^\s,=]+/);
                var value = quoted(txt('"'), txt('"'));
                var attr = seq(name, rgx(/\s*=\s*/), value);
                var attrs = sep(attr, comma).join(0, 2);
                var challenge = seq(name, comma, attrs);
                WWWAuthenticateHeader.pattern = sep(challenge, comma).join(0, 2);
            })(WWWAuthenticateHeader = Utils.WWWAuthenticateHeader || (Utils.WWWAuthenticateHeader = {}));
            //#endregion
            //#region Command
            /**
             * It's a function that can be enabled or disabled.
             *
             * The point of commands is to bind them to certain UI elements and disable/enable
             * these elements according to state of their commands. For instance, UI may implement
             * the drag-and-drop way of adding contacts to a group: if the group model's command
             * that adds contacts is enabled, UI allows to drop a contact UI element to the group element.
             *
             * In the most general case, however, a command is callable object that contains all
             * the information needed to invoke a certain function with certain arguments. In addition
             * to that a command can be observed and it can tell whether it can be invoked with certain
             * arguments. To address that we may later extend the command class with the `bind` method:
             *
             *      var cmdSendMessage = messaging.send; // generic command
             *      var cmdSendGreeting = cmdSendMessage.bind(null, "Hello"); // specific command
             *
             *      cmdSendMessage.enabled(); // tells whether a message can be sent in general
             *      cmdSendGreeting.enabled(); // tells whether that particular message can be sent
             *
             * Thus to check whether it's ok to invoke a command with certain arguments a caller
             * may use the `bind` method and the `enabled` property:
             *
             *      if (messaging.send.bind(null, "Hello").enabled())
             *          console.log("This message can be sent.");
             *
             * The first `null` argument is needed to make `bind` be a superset of the existing Function::bind.
             * This `bind` method can be used to create UI elements that do very specific actions. For instance
             * here is how the `mute` and `unmute` buttons can be creates:
             *
             *      var btnMute = Button(audio.muted.set.bind(null, true));
             *      var btnUnmute = Button(audio.muted.set.bind(null, false));
             *
             * The first button executes audio.muted.set(true) and the second executes audio.muted.set(false).
             * Note, that the two buttons subscribe to the `enabled` property and make themselves grayed out
             * when the command cannot be executed. It's also noteworthy that one button can be enabled and
             * the other can be disabled at the same time: the two commands don't have to have the same state
             * as the underlying audio.muted.set command.
             *
             * @property {Boolean} enabled - Tells whether the command can be invoked.
             *
             */
            function Command(invoke, enabled) {
                var execute = function exec() {
                    var err, enabled = execute.enabled;
                    if (!enabled()) {
                        err = Exception('CommandDisabled', { reason: enabled.reason });
                        if (isAsyncFunction(invoke))
                            return Task().reject(err).promise;
                        else
                            throw err;
                    }
                    return invoke.apply(this, arguments);
                };
                function stringify() {
                    // make it easier to inspect commands in the dev console
                    return '[Command: enabled = ' + execute.enabled() + ']';
                }
                function bindContext(that) {
                    return Command(function () {
                        return execute.apply(that, arguments);
                    }, execute.enabled);
                }
                if (isAsyncFunction(invoke))
                    setHiddenProperty(execute, sIsAsync, true);
                return extend(execute, {
                    constructor: Command,
                    // it's absent when the first const true and false properties are constructed
                    enabled: enabled && enabled.asReadOnly(),
                    bind: bindContext,
                    toString: stringify
                });
            }
            Utils.Command = Command;
            /**
             * A command that is always enabled.
             *
             * Instead of creating a full blown command with the Command
             * constructor, it creates a function that looks like a command.
             * This considerably improves performance because Property creates
             * always enabled commands.
             */
            function EnabledCommand(fn) {
                return extend(fn, {
                    constructor: Command,
                    toString: function () { return '[Command: enabled = true]'; },
                    enabled: ConstProperty(true)
                });
            }
            Utils.EnabledCommand = EnabledCommand;
            /**
             * A permanently disabled command.
             *
             * Multiple calls to DisabledCommand without arguments return the very
             * same instance of a command. This considerably improves performance
             * because every property object has a disabled .set command.
             */
            function DisabledCommand(reason) {
                if (reason !== void 0)
                    return Command(function () { }, ConstProperty(false, reason));
                if (!DisabledCommand.instance)
                    DisabledCommand.instance = Command(function () { }, ConstProperty(false));
                return DisabledCommand.instance;
            }
            Utils.DisabledCommand = DisabledCommand;
            var DisabledCommand;
            (function (DisabledCommand) {
                DisabledCommand.instance;
            })(DisabledCommand = Utils.DisabledCommand || (Utils.DisabledCommand = {}));
            /**
             * A permanently disabled async command.
             *
             * Multiple calls to DisabledAsyncCommand without arguments return the very
             * same instance of a command. This considerably improves performance
             * because every property object has a disabled .set command.
             */
            function DisabledAsyncCommand(reason) {
                if (reason !== void 0)
                    return Command(async(function () { }), ConstProperty(false, reason));
                if (!DisabledAsyncCommand.instance)
                    DisabledAsyncCommand.instance = Command(async(function () { }), ConstProperty(false));
                return DisabledAsyncCommand.instance;
            }
            Utils.DisabledAsyncCommand = DisabledAsyncCommand;
            var DisabledAsyncCommand;
            (function (DisabledAsyncCommand) {
                DisabledAsyncCommand.instance;
            })(DisabledAsyncCommand = Utils.DisabledAsyncCommand || (Utils.DisabledAsyncCommand = {}));
            //#endregion
            //#region Subscription
            /**
             * A simple subscription object.
             *
             * It's shared by Property::subscribe and Collection::subscribe.
             * It makes sure that the given `dispose` function is invoked only once.
             */
            function RefCountedSubscription(fnSubscribed, fnUnsubscribed) {
                var nSubscriptions = 0;
                return function () {
                    var isDisposed = false;
                    nSubscriptions++;
                    if (nSubscriptions == 1 && fnSubscribed)
                        fnSubscribed();
                    return {
                        dispose: function () {
                            if (isDisposed)
                                throw Exception('AlreadyDisposed');
                            isDisposed = true;
                            nSubscriptions--;
                            if (nSubscriptions == 0 && fnUnsubscribed)
                                fnUnsubscribed();
                        }
                    };
                };
            }
            //#endregion
            //#region Property
            /**
             * An observable property.
             *
             * An owner of this property can change its value, while others get
             * a read-only version of it and can subscribe to changes of its value.
             *
             * In this example a constructor of class Person creates an observable
             * property "name" and exposes its read-only version in its interface:
             *
             *      var name = Property();
             *      name.set('John Doe');
             *
             *      return {
             *          name: name.asReadOnly()
             *      };
             *
             * The users of the Person subscribe to the property and get notified
             * when the person property is changed:
             *
             *      var person = Person(...);
             *      person.name.changed(function (name) {
             *          console.log('New name is', name);
             *      });
             *
             * So whenever the Person invokes name.set('NewName'), the new value
             * gets printed to the console log.
             *
             * This example demonstrates how the view layer binds to the model layer.
             * The model layer in turn subscribes to the stack layer via event mechanism
             * and update the model properties when it get events from the stack.
             *
             * @param [value] - The initial value of the property.
             * @param [reason] - The initial reason value of the property.
             * @param [readOnly=false] - If the created property needs to be read only.
             *
             * @param {Function} [subscribed]
             *
             *      This callback is invoked after the first subscription to the property is created:
             *
             *          var p = Property({
             *              subscribed: fnSubscribed
             *          });
             *
             *          p.subscribe(); // this triggers fnSubscribed
             *          p.subscribe(); // this doesn't trigger fnSubscribed
             *
             * @param {Function} [unsubscribed]
             *
             *      This callback is invoked after the last subscription to the property is disposed:
             *
             *          var p = Property({
             *              unsubscribed: fnUnsubscribed
             *          });
             *
             *          var s1 = p.subscribe();
             *          var s2 = p.subscribe();
             *
             *          s1.dispose(); // this doesn't trigger fnUnsubscribed
             *          s2.dispose(); // this triggers fnUnsubscribed
             *
             * @param {Function} [get] - Overridden asynchronous getter.
             *
             *      Overrides the default `.get` method that simply reads the cached value
             *      and wraps it into a resolved promise. The overridden getter is a function
             *      returning a promise or a value. When it's invoked, `this` points to the
             *      property object. The value eventually returned by the overridden getter
             *      becomes the new cached value.
             *
             *          var availability = Property({
             *              get: function (value) { // this === availability, value === this()
             *                  return ucwa.send("GET", "presence").then(function (r) {
             *                      return r.get("availability");
             *                  });
             *              }
             *          });
             *
             *          availability.get().then(function (value) {
             *              if (value == "Online")
             *                  alert("You are online.");
             *          });
             *
             *      Calls to .get() are debounced, which means that multiple calls
             *      are almost equivalent to one and do not invoke the custom getter
             *      miltple times if such a getter was set.
             *
             * @param {Function} [set] - Overridden asynchronous setter.
             *
             *      Overrides the default `.set` method that simply changes the cached value,
             *      fires the `changed` event if necessary and returns a resolved promise.
             *      The overridden setter is a function returning a promise or a value. When
             *      it's invoked, `this` points to the property object. The value eventually
             *      returned by the overridden setter becomes the new cached value.
             *
             *          me.availability = Property({
             *              set: function (value) { // this === me.availability, value === this()
             *                  var presence = clone(me.presence());
             *                  presence.availability = value;
             *                  return ucwa.send("POST", "presence", { data: presence }).then(function () {
             *                      return value; // change the cached value (this may fire the `changed` event)
             *                  });
             *              }
             *          });
             *
             *          me.availability.set("Online").then(function () {
             *              alert("The server has accepted the request to change the availability.");
             *          });
             *
             * @param {Function} [check] - Validate the property value.
             *
             *      A function to validate the property value at each time when it is set.
             *      It can not be implemented inside an overridden setter since the setter is
             *      an asynchronous call, and it may only be called in the next cycle. However
             *      the check should be call immediately when the value is set.
             *
             *      The check function should throw an exception when validation condition is not satisfied.
             *
             *          var limit = Property({
             *              value: 1,
             *              check: function (value) {
             *              if (!(value > 0 && (value | 0) == value))
             *                  throw EInvalidArgument('limit', '`limit` must be a positive integer');
             *              }
             *          });
             *
             * @member reason - Explains why the property has the current value.
             *
             * @command {Promise} get() - Fetches the actual value.
             *
             *      The property may contain a cached value that can be retrieved
             *      via the `.call` method:
             *
             *          var myNote = me.note();
             *
             *      Fetching the actual value may require interactions with the server
             *      or with the media plugin and thus it may be asynchronous. A call to
             *      `.get` tells the property to do whatever is necessary to obtain
             *      the actual value of the property:
             *
             *          // may send a GET request to UCWA
             *          my.note.get().then(function (note) {
             *              alert("My note: " + note);
             *          });
             *
             *      If the actual value equals to the cached value, `.get` returns
             *      a promise resolved to that value.
             *
             *      Calls to .get() are debounced, which means that multiple calls
             *      are almost equivalent to one and do not invoke the custom getter
             *      miltple times if such a getter was set.
             *
             * @method {Subscription} subscribe - Tells the property to keep its value always up to date.
             *
             *      This method should be invoked if the up to date property value is needed at all times.
             *      The difference between .subscribe and .get is that .get fetches the value once, while
             *      .subscribe keeps the value always up to date. A call to .subscribe is generally heavier
             *      than a call to .get. Typically it's used to create a presence subscription:
             *
             *          var sub = person.status.subscribe();
             *          person.status.changed(value => console.log(value));
             *          setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
             *
             *      If the property value is needed only once, it's better to use .get.
             *
             *      The first call to this method notifies the property's owner via the `subscribed` hook.
             *      After the last subscription is disposed, the property's owner is notified via the `unsubscribed` hook.
             *
             * @command {Promise} set(value, reason) - Requests to change the value.
             *
             *      There is a shortcut to this method. If p is a property, its
             *      value can be changed via p.set(newValue) or via p(newValue).
             *      The latter looks more concise when a property belongs to another object:
             *
             *          me.note(newNote).location(newLocation);
             *
             *      Note, that p() returns `this` that points to the owner of the property,
             *      so in the example above me.note(newNote) returns `me` (this is why `note`
             *      and `location` changes can be chained). While p() internally invokes p.set(),
             *      it returns `this`, so the progress of the operation can't be monitored.
             *      `.set` returns a promise that completes after the property gets actually changed:
             *
             *          me.note.set(newNote).then(
             *              function (res) {
             *                  // the property has been changed
             *              },
             *              function (err) {
             *                  // something went wrong; see the given error
             *              });
             *
             * @event changed(newValue, reason, oldValue) - Occurs after the value of the property changes.
             *
             *      The attached handler will be called immediately if the property had a value before the
             *      handler is attached. This is correct, because the handler does not know when the value
             *      for the property was set - before or after it was attached.
             *
             *      A subscription to the event doesn't make any side effects such as populating the
             *      property with a meaningful value. To get such a value the caller needs to fetch the value
             *      once via .get or create a persistent subscription via .subscribe.
             *
             * @method when - Adds a listener to the given value.
             *
             *      Specifies a callback to be invoked when the property obtains the given value:
             *
             *          state.when("Disconnected", function (reason, oldState) {
             *              // handling of the Disconnected state
             *          });
             *
             *      If the callback needs to handle multiple values, it's possible to write a
             *      predicate function that would recognize these values:
             *
             *          anyOf = vs => v => vs.indexOf(v) >= 0;
             *          state.when(anyOf("Connected", "Disconnected"), function (reason) {
             *              // the state is either Connected or Disconnected
             *          });
             *
             *      To remove the event listener invoke the dispose method:
             *
             *          sub = state.when("Connected", fn);
             *          sub.dispose();
             *
             *      Note, that the callback is invoked synchronously immediately after it's added
             *      if the property already had a value and thus an attempt to dispose the listener
             *      inside the callback won't work:
             *
             *          p = Property();
             *          p(123);
             *          s = p.when(123, function () {
             *              s.dipose(); // => s is undefined at the moment
             *          });
             *
             *      A workaround is to dispose the listener at the next event cycle:
             *
             *          s = p.when(123, function () {
             *              setTimeout(s.dipose, 0);
             *          });
             *
             *      Or invoke this.dispose() inside the callback, as this refers to the created
             *      subscription object:
             *
             *          p.when(123, function () {
             *              // do something
             *              this.dispose();
             *          });
             *
             *      Notice, that if the callback was created via .bind in order to overwrite `this`,
             *      it won't be possible to invoke the .dispose method.
             *
             * @method once - Adds a one-time listener.
             *
             *      Specifies a callback to be invoked once the property obtains the given value:
             *
             *          state.once("Disconnected", function (reason, oldState) {
             *              // handling of the Disconnected state
             *          });
             *
             *      After the callback is invoked, it's removed from the event listeners.
             *      If the callback needs to handle multiple values, it's possible to write a
             *      predicate function that would recognize these values:
             *
             *          anyOf = vs => v => vs.indexOf(v) >= 0;
             *          state.once(anyOf("Connected", "Disconnected"), function (reason) {
             *              // the state is either Connected or Disconnected
             *          });
             *
             *      To remove the event listener before it's invoked, use the dispose method:
             *
             *          sub = state.once("Connected", fn);
             *          sub.dispose();
             *
             * @method asReadOnly() - Returns a read-only property.
             *
             *      The value of the read-only property can be modified only by its
             *      creator (this Property object).
             *
             *      The read-only property allows the short-hand syntax to get a value
             *      and to convert it to a string:
             *
             *          var p = Property({ value: 123 }).asReadOnly();
             *
             *          assert(p() == 123);
             *          assert(p == '123'); // instead of p().toString()
             *
             *      The read-only property has the same interface as the regular property,
             *      but its .set command is disabled.
             *
             * @method {Property} map(forwardTransform, inverseTransform?)
             *
             *      Creates a new property by applying the given function to the value of this property.
             *      The created property can be observed and fetched and the requests will be properly
             *      redirected to the original property.
             *
             *          var p1 = Property();
             *          var p2 = p1.map(x => Math.pow(2, x));
             *
             *          p1(3);
             *          p2() == 8;
             *
             *      The created property is read-only because it's usually not possible to "unmap"
             *      values from the created property to the original one. However if the inverse mapping
             *      function is provided, the created property becomes writable:
             *
             *          var p1 = Property();
             *          var p2 = p1.map(x => Math.pow(2, x), y => Math.log(y, 2));
             *
             *          p2(8);
             *          p1() == 3;
             *
             * @method {Property} equals(value)
             *
             *      Returns a boolean property, which indicates whether the value of self property equals to the given value.
             *      The boolean property always gets updated when the self property changes.
             *
             * @method {Property} fork(fnSet)
             *
             *      Returns a forked property, which will always have its value synced with its source.
             *      A 'set' function or command must be provided for the forked property.
             *
             * @method {Property} or(property) - Simulates the overloaded || operator.
             *
             */
            function Property(opts) {
                var self = rw;
                var fnGet = opts && opts.get;
                var fnSet = opts && opts.set;
                var isReadOnly = opts && opts.readOnly;
                if (opts && opts.value !== void 0)
                    self._value = opts.value; // undefined means no value
                if (opts && opts.reason !== void 0)
                    self.reason = opts.reason;
                if (opts && opts.check)
                    self._check = opts.check;
                if (fnGet)
                    self._getter = async(fnGet);
                if (isReadOnly)
                    self._ro = self;
                if (fnSet)
                    self._setter = async(fnSet, 'sync');
                if (opts && opts.subscribed)
                    self._subscribed = opts.subscribed;
                if (opts && opts.unsubscribed)
                    self._unsubscribed = opts.unsubscribed;
                // This trick is deeper than it might look.
                // Read the comment for Property.prototype.
                setPrototypeOrExtend(self, Property.prototype);
                extend(self, {
                    get: isCommand(fnGet) ?
                        Command(self._getAsync, fnGet.enabled) :
                        EnabledCommand(self._getAsync),
                    set: isReadOnly ? DisabledAsyncCommand() :
                        isCommand(fnSet) ? Command(self._setAsync, fnSet.enabled) :
                            EnabledCommand(self._setAsync)
                });
                Object.defineProperty(self, 'changed', {
                    get: self._getChanged
                });
                // this function represents the read-write instance of the property
                // and at the same time acts as its getter and setter
                function rw(value, reason) {
                    if (arguments.length == 0) {
                        return self._value;
                    }
                    else {
                        self._write(value, reason);
                        return this;
                    }
                }
                return self;
            }
            Utils.Property = Property;
            var Property;
            (function (Property) {
                // TODO: This thing is deprecated and shouldn't be used in new code.
                //
                // If a property was created with an overridden .set, i.e. p = Property({ set: fn }),
                // then in order to change the property value without triggering the custom setter
                // the owner of the property needs to use some kind of backdoor and this sUpdated
                // is this backdoor, as p.set(val, sUpdated) changes the value without invoking fn.
                //
                // A cleaner solution is to fork a property and give a custom setter to that property:
                //
                //  var pInternal = Property();
                //  var pExternal = pInternal.fork(fnSet);
                //
                // This way the owner of the property can change the value of the internal property
                // which doesn't have custom .set, while a consumer gets an external version of the property
                // with overridedn .set and .get.
                Property.sUpdated = {};
            })(Property = Utils.Property || (Utils.Property = {}));
            // The created property object must be a function with a few extra methods.
            // It also must have at least .call, .apply and .bind methods that all functions have,
            // as the created property object can be used as a function. At the same time some
            // browsers do not support replacing prototype of a function and in such browsers
            // changing the prototype is replacing with copying all the methods from the desired
            // property's prototype object. This works because if replacing the prototype is not
            // supported, then the created property object remains a regular function with its
            // original prototype with .call, .bind and .apply methods, and is extended with custom
            // methods. This is why property objects behave the same way in old and new browsers,
            // though employ quite different techniques to achieve that.
            Property.prototype = function () { };
            // since every property is a function, Property.prototype
            // is not a real prototype of every property instance and thus
            // an attempt to edit the prototype won't change anything in
            // already created properties; however Property.prototype is a
            // convenient and expected place to add methods that will be
            // shared between all properties
            extend(Property.prototype, {
                constructor: Property,
                toString: function () {
                    return '[Property: value = ' + this() + ']';
                },
                or: function (p) {
                    return ComputedProperty(this, p, function (a, b) {
                        return a || b;
                    });
                },
                map: function (fn, ifn) {
                    var self = this, s, p = Property({
                        get: Command(function () {
                            return self.get().then(fn);
                        }, self.get.enabled),
                        subscribed: function () {
                            s = self.subscribe();
                        },
                        unsubscribed: function () {
                            s.dispose();
                        }
                    });
                    self.changed(function (value, reason) {
                        p(fn(value), reason);
                    });
                    return p.fork(Command(function (value) {
                        return self.set(ifn(value)).then(fn);
                    }, ifn ? self.set.enabled : ConstProperty(false)));
                },
                when: function (value, handler) {
                    var changed = this.changed;
                    var sub = {
                        dispose: function () {
                            changed.off(fn);
                        }
                    };
                    var matches = isFunction(value) ?
                        value :
                        function (v) { return v === value; };
                    function fn(newValue, reason, oldValue) {
                        if (matches(newValue))
                            handler.call(sub, reason, oldValue);
                    }
                    changed(fn);
                    return sub;
                },
                once: function (value, callback) {
                    return this.when(value, function () {
                        this.dispose();
                        callback.apply(null, arguments);
                    });
                },
                equals: function (value) {
                    return this.map(function (v) {
                        return v == value;
                    });
                },
                equalsAny: function () {
                    var array = [].slice.call(arguments);
                    return this.map(function (v) {
                        return contains(array, function (item) {
                            return item == v;
                        });
                    });
                },
                fork: function (fnSet) {
                    var self = this, sub;
                    var enabled = fnSet.enabled || ConstProperty(true);
                    var isReadOnly = enabled === ConstProperty(false);
                    var p = Property({
                        value: self(),
                        reason: self.reason,
                        readOnly: isReadOnly,
                        set: !isReadOnly && Command(function (value, reason) {
                            return async(fnSet)(value, reason).then(function (val) {
                                return self.set(val, reason);
                            });
                        }, enabled),
                        get: self.get.bind(self),
                        subscribed: function () {
                            sub = self.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    (self._forks = self._forks || []).push(p);
                    return p;
                },
                asReadOnly: function () {
                    var self = this;
                    if (!self._ro)
                        self._ro = self.fork(DisabledAsyncCommand());
                    return self._ro;
                },
                observed: function () {
                    var self = this, changed = self._changed;
                    return changed && changed.observed();
                },
                subscribe: function () {
                    var self = this;
                    self.subscribe = RefCountedSubscription(self._subscribed, self._unsubscribed);
                    return self.subscribe();
                }
            });
            // These methods are for internal use only. They were relocated from the ctor
            // to reduce memory consumption of the property object.
            extend(Property.prototype, {
                _set: function (value, reason) {
                    var self = this, oldValue = self._value, i, forks = self._forks, changed = self._changed;
                    if (!self._same(value, reason)) {
                        self._value = value;
                        self.reason = reason;
                        if (changed)
                            changed.fire(value, reason, oldValue);
                        if (forks) {
                            for (i = 0; i < forks.length; i++)
                                forks[i]._set(value, reason);
                        }
                    }
                    return value;
                },
                _same: function (value, reason) {
                    var self = this;
                    return deepEqual(value, self._value) && deepEqual(reason, self.reason);
                },
                _getChanged: function () {
                    var self = this;
                    if (!self._changed) {
                        self._changed = Event({
                            context: self,
                            added: self._listenerAdded
                        });
                    }
                    // it might be tempting to replace the property getter
                    // with the actual value which is known now by using 
                    // Object.defineProperty and thus avoid calling this getter
                    // later, but the surprising fact is that such an
                    // "optimization" makes the property with a listener about
                    // 1.5x heavier and about 1.5x slower
                    return self._changed.observer;
                },
                _listenerAdded: function (listener) {
                    var self = this, changed = self._changed, value = self._value, reason = self.reason;
                    if (value !== void 0)
                        // Event::_invoke knows better how to invoke a listener properly
                        changed._invoke(listener, [value, reason]);
                },
                _getAsync: async(function () {
                    var self = this, getter = self._getter, value = self._value;
                    if (!getter)
                        return value;
                    if (!self._dfdget)
                        self._dfdget = getter.call(self, value, self.reason);
                    return self._dfdget.then(function (value) {
                        self._dfdget = null;
                        self._set(value, self.reason);
                        return self._value;
                    }, function (error) {
                        // it can be nulled in a nicer way by .finally(...)
                        // at the expense of creating an extra promise which
                        // is not acceptable in Property::get calls as they
                        // are made frequently
                        self._dfdget = null;
                        throw error;
                    });
                }),
                _setAsync: async(function (value, reason) {
                    var self = this, check = self._check, setter = self._setter;
                    assert(arguments.length > 0);
                    if (self._same(value, reason))
                        return value;
                    if (check)
                        check(value);
                    // _set could be invoked once at the price of always creating
                    // an extra task which would make the whole property model a bit slower
                    return !setter ? self._set(value, reason) : setter.call(self, value, reason).then(function (value) {
                        return self._set(value, reason);
                    });
                }, 'sync'),
                _write: function (value, reason) {
                    var self = this, check = self._check, setter = self._setter;
                    if (self._same(value, reason))
                        return;
                    if (check)
                        check(value);
                    if (!self.set.enabled())
                        throw Error('This is a read-only property.');
                    // obj.prop(123) is a shortcut to obj.prop.set(123)
                    // except that it returns the owner object `obj`
                    // note, that f.set returns a promise; also
                    // `update` could be invoked once at the price of always creating
                    // an extra task which would make the whole property model a bit slower
                    if (setter && reason !== Property.sUpdated) {
                        setter.call(self, value, reason).then(function (value) {
                            self._set(value, reason);
                        });
                    }
                    else {
                        self._set(value, reason);
                    }
                }
            });
            //#endregion Property
            //#region ConstProperty
            /**
             * A read only property with the given value.
             */
            function ConstProperty(value, reason) {
                if (reason === void 0) {
                    if (value === null)
                        return Property.$null;
                    if (value === true)
                        return Property.$true;
                    if (value === false)
                        return Property.$false;
                }
                return Property({
                    value: value,
                    reason: reason,
                    readOnly: true
                });
            }
            Utils.ConstProperty = ConstProperty;
            var Property;
            (function (Property) {
                // The const true and false properties are also regular properties
                // with .get and .set commands. These commands, in turn, are regular
                // commands that have the .enabled property which is either the const true
                // or the const false property. To break this recursion, the const true
                // and false properties are created once with .get and .set commands
                // without the .enabled property and after they are created, their .get and
                // .set commands are given the .enabled properties. Thus the structure
                // of the created two properties look like this:
                //
                //      <t> = {
                //          get: { enabled: <t> },
                //          set: { enabled: <f> }
                //      };
                //
                //      <f> = {
                //          get: { enabled: <t> },
                //          set: { enabled: <f> }
                //      };
                //
                // This makes an impression that there is an infinitely long chain of
                // someProperty.get.enabled.set.enabled.set.enabled.get.enabled... while in
                // fact this chain is a loop between the two const properties.
                Property.$true = Property({ value: true, readOnly: true });
                Property.$false = Property({ value: false, readOnly: true });
                Property['true'] = Property.$true;
                Property['false'] = Property.$false;
                Property.$true.get.enabled = Property.$true;
                Property.$true.set.enabled = Property.$false;
                Property.$false.get.enabled = Property.$true;
                Property.$false.set.enabled = Property.$false;
                DisabledAsyncCommand.instance.enabled = Property.$false;
                Property.$null = Property({ value: null, readOnly: true });
                Property['null'] = Property.$null;
            })(Property = Utils.Property || (Utils.Property = {}));
            //#endregion
            //#region NumProperty
            /**
             * A property that contains an numeric value.
             * Usually it contains an integer value:
             *
             *      p = NumProperty(0);
             *      p.inc(); // p() == 1
             *      p.dec(); // p() == 2
             *
             * @method inc
             * @method dec
             *
             */
            function NumProperty(value, reason) {
                var p = Property();
                p(value, reason);
                // note, that p.asReadOnly() drops these
                // two methods which is fine because a read
                // only property cannot be incremented or
                // decremented
                p.inc = function () { return p(p() + 1); };
                p.dec = function () { return p(p() - 1); };
                return p;
            }
            Utils.NumProperty = NumProperty;
            //#endregion
            //#region BoolProperty
            /**
             * A property that contains a boolean value.
             */
            function BoolProperty(value, reason) {
                var p = Property();
                p(value, reason);
                // TODO: custom methods to be added here
                return p;
            }
            Utils.BoolProperty = BoolProperty;
            //#endregion
            //#region ComputedProperty
            /**
             * Constructs a property which values depends on a few other properties.
             *
             * Note, that a computed property that depends on only one property
             * can be constructed with a call to Property::map; a computed property
             * that depends on two properties corresponds to an overloaded operator
             * of the Property class (which isn't possible in JS as of today).
             *
             *      var a = Property({ value: 1 });
             *      var b = Property({ value: 2 });
             *      var c = ComputedProperty(a, b, (x, y) => x + y);
             *
             * In the knockout library there is something similar. Perhaps, the only
             * major difference between this thing and ko.observable is that ko can
             * figure out the list of dependencies on its own, which is very convenient:
             *
             *      var a = ko.observable(1);
             *      var b = ko.observable(2);
             *      var c = ko.computed((x, y) => x + y);
             *
             * This can be implemented here, but as of today computed properties aren't
             * used in many places and hence I didn't see the need to make the change
             * too complicated.
             *
             */
            function ComputedProperty() {
                var _args = []; /*...properties: Property[], fn: (...values: any[]) => any*/
                for (var _i = 0; _i < arguments.length; _i++) {
                    _args[_i - 0] = arguments[_i];
                }
                var properties = [].slice.call(arguments, 0, -1);
                var fn = arguments[arguments.length - 1];
                var psubs;
                var computed = Property({
                    get: function () {
                        var pgets = map(properties, function (p) { return p.get(); });
                        return Task.waitAll(pgets).then(function (values) {
                            return fn.apply(null, values);
                        });
                    },
                    subscribed: function () {
                        psubs = map(properties, function (p) { return p.subscribe(); });
                    },
                    unsubscribed: function () {
                        foreach(psubs, function (s) { return s.dispose(); });
                    }
                });
                foreach(properties, function (p) {
                    p.changed(function () {
                        var values = map(properties, function (p) { return p(); });
                        computed(fn.apply(null, values));
                    });
                });
                // if we later decide to somehow make the returned property writable,
                // this will be the right place for the change: asReadOnly will need
                // to be replaced with fork(...)
                return computed.asReadOnly();
            }
            Utils.ComputedProperty = ComputedProperty;
            //#endregion
            //#region Collection
            /**
             * An observable ordered collection of items.
             *
             * A creator of this collection can add items to it, while others get a read-only
             * version of the collection and can subscribe to changes in it.
             *
             * In this example a constructor of class Conversation creates an observable
             * collection "messages" and exposes its read-only version in its interface:
             *
             *      var messages = Collection();
             *      messages.add('First Message');
             *
             *      return {
             *          messages: messages.asReadOnly()
             *      };
             *
             * The users of the Conversation subscribe to the collection and get notified
             * when the Conversation adds items to it:
             *
             *      var conversation = Conversation(...);
             *      conversation.chatService.messages.added(function (message) {
             *          console.log('New message:', message);
             *      });
             *
             * So whenever the Conversation invokes messages.add('Another Message'), the new message
             * gets printed to the console log.
             *
             * This example demonstrates how the view layer binds to the model layer.
             * The model layer in turn subscribes to the stack layer via event mechanism
             * and update the model properties when it get events from the stack.
             *
             * @param {Function} [subscribed]
             *
             *      This callback is invoked after the first subscription to the collection is created:
             *
             *          var c = Collection({
             *              subscribed: fnSubscribed
             *          });
             *
             *          c.subscribe(); // this triggers fnSubscribed
             *          c.subscribe(); // this doesn't trigger fnSubscribed
             *
             * @param {Function} [unsubscribed]
             *
             *      This callback is invoked after the last subscription to the collection is disposed:
             *
             *          var c = Property({
             *              unsubscribed: fnUnsubscribed
             *          });
             *
             *          var s1 = c.subscribe();
             *          var s2 = c.subscribe();
             *
             *          s1.dispose(); // this doesn't trigger fnUnsubscribed
             *          s2.dispose(); // this triggers fnUnsubscribed
             *
             * @param {Function} [get] - Overridden asynchronous getter.
             *
             *      Overrides the default `.get` method that returns all cached items from the collection
             *      as an array. The overridden `.get` is given a snapshot of the collection as a dictionary
             *      and should either return the snapshot as-is, or return another dictionary that
             *      would become the new snapshot of the collection. This overridden method may return a promise
             *      resolving to such a dictionary.
             *
             *      The snapshot parameter represents the internal state of the collection and
             *      cannot be obtained via any methods. If this snapshot gets modified, the state of the collection
             *      may become corrupted. To avoid this, the collection allows to get a snapshot as an array
             *      detached from the internal state of the collection.
             *
             *          var contacts = Collection({
             *              get: function () {
             *                  return contacts.size() > 0 ?
             *                      null : // contacts already loaded - no need to bother the server again
             *                      ucwa.send("GET", "contacts").then(function (rContacts) {
             *                          var newItems = {};
             *                          rContacts.links('contact').forEach(function (link) {
             *                              newItems[link.href] = items[link.href] || createContact(link);
             *                          });
             *                          return newItems;
             *                      });
             *              }
             *          });
             *
             *          contacts.get().then(function (array) {
             *              array.forEach(...);
             *          });
             *
             *      Calls to the custom getter are debounced: if someone invokes .get(...) multiple times
             *      while the promise returned from the getter is still pending, the same promise will be
             *      reused. This is useful if the getter is a heavy async operation which isn't supposed
             *      to be invoked multiple times.
             *
             * @event changed - Occurs after the list of items changes.
             *
             *      Right after the handler is attached, it's invoked once.
             *
             *      Adding a handler to this event doesn't make any side effects such
             *      as populating the collection with items. To get the items
             *      they need to be fetched once via .get or the caller needs to create
             *      a persistent subscription via .subscribe.
             *
             * @event added(item, key, index) - Occurs after an item was added to the collection.
             *
             *      If the handler is attached after the collection already had some items,
             *      the handler will be invoked for each of these items.
             *
             *      Adding a handler to this event doesn't make any side effects such
             *      as populating the collection with items. To get the items
             *      they need to be fetched once via .get or the caller needs to create
             *      a persistent subscription via .subscribe.
             *
             * @event removed(item, key, index) - Occurs after an item was removed from the collection.
             *
             *      Adding a handler to this event doesn't make any side effects such
             *      as populating the collection with items. To get the items
             *      they need to be fetched once via .get or the caller needs to create
             *      a persistent subscription via .subscribe.
             *
             * @method {Subscription} subscribe - Tells the collection to keep its list of items always up to date.
             *
             *      This method should be invoked if the up to date list of items is needed at all times.
             *      The difference between .subscribe and .get is that .get fetches the list once, while
             *      .subscribe keeps the list always up to date. A call to .subscribe is generally heavier
             *      than a call to .get.
             *
             *          var sub = client.devices.subscribe();
             *          client.devices.changed(items => console.log(items));
             *          setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
             *
             *      If the list of items is needed only once, it's better to use .get.
             *
             *      The first call to this method notifies the collection's owner via the `subscribed` hook.
             *      After the last subscription is disposed, the collection's owner is notified via the `unsubscribed` hook.
             *
             * @method add(item, key, index) - Adds an item to the collection.
             *
             *      If key is omitted, a random key is generated.
             *      If index is omitted, the item is appended to the end of the collection.
             *
             * @method {Promise} get - Returns an item associated with the specified key or index.
             *
             *      .get() fetches all the items and returns them as an array.
             *      .get(key) fetches an item with the given key, which is a string.
             *      .get(index) fetches an item with the given index.
             *
             *      Multiple calls to .get(...) invoke the custom getter, if it's set, only once.
             *
             * @method remove - Removes an item by key or index.
             *
             *      .remove(key) removes an item by its key, which is a string.
             *      .remove(idx) removes an item from the given index.
             *
             * @method asReadOnly - Returns a read-only version of the collection.
             * @method fork - Creates a fork of the collection with customized .add and .remove commands.
             *
             *      All the forks share the same state and have the same set of items.
             *      In fact they are the same instance of the collection.
             *      Different forks have different customized .add and .remove commands
             *      that can have custom logic and can be async.
             *
             * @method {Boolean} contains(predicate)
             * @method empty
             *
             * @method {Collection} map - Creates a collection with mapped items.
             *
             *      source.map(fn) creates a collection in which all items satisfy the following
             *      condition: source.map(fn)(i) == fn(source(i)). The created collection is
             *      observable and correctly handles calls to .get and .subscribe by routing
             *      them to the source collection:
             *
             *          var phones = teluris.map(formatTelUriNicely);
             *
             *      This example maps every tel uri, which looks like "tel:+1234...", to nicely
             *      looking phone numbers like "+1 (234) 456-7890", and the created collection
             *      remains observable and thus can be attached to UI.
             *
             * @method {Collection} filter - Creates a collection that doesn't have certain items.
             *
             *      source.filter(fn) creates a collection which contains all the items from
             *      the source collection except certain items that are filtered out by the
             *      given predicate:
             *
             *          var activityItems = conversation.historyService.activityItems;
             *          var messages = activityItems.filter(i => i.type() == "TextMessage");
             *
             *      The order of items in the filtered collection is preserved. The created collection
             *      handles correctly calls to .get and .subscribe and remains observable and thus can
             *      be attached to UI.
             *
             * @method {Collection} sort - Creates a sorted collection.
             *
             *      It seems obvious that one collection exposed by the model layer can be displayed
             *      in different parts of UI in different ways: one UI element may need to sort items
             *      by one criteria, while another may need to use another criteria. To meet this
             *      requirement every collection exposed by the model need to have a method that
             *      creates another collection which is sorted:
             *
             *          var byName = persons.sort((p1, p2) => p1.displayName() < p2.displayName());
             *          var byDept = persons.sort((p1, p2) => p1.department() < p2.department());
             *
             *      The created sorted collections are observable and are updated whenever the source
             *      collection is updated, but in addition to that they are sorted.
             *
             * @method observe - Collects batches of changes and sends them to the callback every event cycle.
             *
             *      Whenever an item is added to the collection or removed from it, the collection
             *      fires an appropriate event. However if the UI starts updating the DOM tree
             *      after every change, it may become pretty slow. It might be better to collect
             *      all changes made within a short period of time and then update the DOM tree once.
             *      This method starts listening to the changes in the collection, summarizes these
             *      changes and at the next event cycle it invokes the specified callback:
             *
             *          var sub = conversations.observe(function (added, removed) {
             *              foreach(added, function (conversation, key) {
             *                  console.log("conversation has been added");
             *              });
             *
             *              foreach(removed, function (conversation, key) {
             *                  console.log("conversation has been removed");
             *              });
             *          });
             *
             *          // some time later...
             *          sub.dispose();
             *
             *      This theoretically allows to handle the list of changes and efficiently redraw the UI.
             *
             * @property {Number} size - The number of items in the collection.
             *
             */
            function Collection(options) {
                var self = rw, _ = self._ = extend({}, options);
                if (options && options.get)
                    _.get = async(options.get);
                _.vals = []; // Map<Index, Value>
                _.keys = []; // Map<Index, Key>
                _.idxs = {}; // Map<Key, Index>
                // this function represents the read-write instance of the property
                // and at the same time acts as its getter and setter, which takes
                // ar array of items and replaces contents of the collection with them
                function rw(key) {
                    if (arguments.length == 0) {
                        return self._asArray();
                    }
                    else if (isArray(key)) {
                        self.empty();
                        self._addArray(key);
                        return this;
                    }
                    else {
                        return self._getFromCache(key);
                    }
                }
                setPrototypeOrExtend(self, Collection.prototype);
                self._init();
                return self;
            }
            Utils.Collection = Collection;
            // Collections are functions and in order to behave like proper functions,
            // they need to have all the function's methods like .apply and .call.
            Collection.prototype = function () { };
            // These methods are for internal use only.
            // They were relocated from the ctor to reduce memory consumption.
            extend(Collection.prototype, {
                _init: function () {
                    var self = this;
                    Object.defineProperties(self, {
                        added: {
                            enumerable: true,
                            get: self._initAddedEvent
                        },
                        removed: {
                            enumerable: true,
                            get: self._initRemovedEvent
                        },
                        changed: {
                            enumerable: true,
                            get: self._initChangedEvent
                        },
                        size: {
                            enumerable: true,
                            get: self._initSizeProperty
                        }
                    });
                },
                _initAddedEvent: function () {
                    var self = this, _ = self._, name = 'added', val;
                    _[name] = _[name] || Event({
                        context: self,
                        adding: self._addedListenerAdding
                    });
                    val = _[name].observer;
                    return val;
                },
                _addedListenerAdding: function (listener) {
                    var self = this, _ = self._, event = _.added;
                    foreach(_.vals, function (v, i) {
                        event._invoke(listener, [v, _.keys[i], i]);
                    });
                },
                _initRemovedEvent: function () {
                    var self = this, _ = self._, name = 'removed', val;
                    _[name] = _[name] || Event();
                    val = _[name].observer;
                    return val;
                },
                _initChangedEvent: function () {
                    var self = this, _ = self._, name = 'changed', val;
                    _[name] = _[name] || Event({
                        context: self,
                        added: self._changedListenerAdded
                    });
                    val = _[name].observer;
                    return val;
                },
                _changedListenerAdded: function (listener) {
                    var self = this, _ = self._, event = _.changed;
                    event._invoke(listener, []);
                },
                _initSizeProperty: function () {
                    var self = this, _ = self._, name = 'size', val;
                    _[name] = _[name] || NumProperty(_.vals.length);
                    val = _[name].asReadOnly();
                    return val;
                },
                subscribe: function () {
                    var self = this, _ = self._;
                    self.subscribe = RefCountedSubscription(_.subscribed, _.unsubscribed);
                    return self.subscribe();
                },
                observed: function () {
                    var _ = this._, added = _.added, removed = _.removed, changed = _.changed;
                    return added && added.observed() ||
                        removed && removed.observed() ||
                        changed && changed.observed();
                },
                _insert: function (val, key, idx) {
                    var i, _ = this._, n = _.vals.length;
                    for (i = idx; i < n; i++)
                        _.idxs[_.keys[i]]++;
                    insertAt(_.vals, idx, val);
                    insertAt(_.keys, idx, key);
                    _.idxs[key] = idx;
                },
                add: function (val, key, idx) {
                    var _ = this._, n = _.vals.length;
                    key = key || (_.key || random)(val);
                    if (key in _.idxs)
                        throw EAlreadyExists(key);
                    idx = isInteger(idx) ? idx : n;
                    if (idx < 0)
                        idx = 0; // .add(..., -123) works as .add(..., 0)
                    if (idx > n)
                        idx = n; // .add(..., +Infinity) works as .add(..., .size())
                    this._insert(val, key, idx);
                    if (_.size)
                        _.size.inc();
                    if (_.added)
                        _.added.fire(val, key, idx);
                    if (_.changed)
                        _.changed.fire();
                    return key;
                },
                remove: function (key) {
                    var _ = this._, idx, val, i;
                    if (isInteger(key)) {
                        idx = key;
                        key = _.keys[idx];
                    }
                    else {
                        idx = _.idxs[key];
                    }
                    val = _.vals[idx];
                    if (idx >= 0 && idx < _.vals.length) {
                        for (i = idx + 1; i < _.keys.length; i++)
                            _.idxs[_.keys[i]]--;
                        removeAt(_.vals, idx);
                        removeAt(_.keys, idx);
                        delete _.idxs[key];
                        if (_.size)
                            _.size.dec();
                        if (_.removed)
                            _.removed.fire(val, key, idx);
                        if (_.changed)
                            _.changed.fire();
                    }
                },
                _getFromCache: function (key) {
                    var _ = this._;
                    return isString(key) ?
                        _.vals[_.idxs[key]] :
                        _.vals[key]; // get by index
                },
                get: function (key) {
                    // `get` is wrapped by `async` so it may return values and promises
                    // if `key` is a string - return an item associated with this key
                    // if `key` is a number - return an item associated with this zero-based index
                    // if `key` is undefined - return all items as an array
                    var self = this, _ = self._, get = _.get, promise;
                    if (get && !_.dfdget)
                        _.dfdget = get();
                    if (_.dfdget) {
                        promise = _.dfdget.then(function (items) {
                            _.dfdget = null;
                            return self._setNewItems(items);
                        }, function (error) {
                            _.dfdget = null;
                            throw error;
                        });
                    }
                    return Task.wait(promise).then(function () {
                        return isVoid(key) ? self._asArray() : self._getFromCache(key);
                    });
                },
                // index by key
                index: function (key) {
                    return this._.idxs[key];
                },
                // key by index
                key: function (idx) {
                    return this._.keys[idx];
                },
                _setNewItems: function (newItems) {
                    var self = this, _ = self._, key;
                    if (!isDictionary(newItems))
                        return;
                    for (key in _.idxs)
                        if (!(key in newItems) || _.vals[_.idxs[key]] !== newItems[key])
                            self.remove(key);
                    for (key in newItems)
                        if (!(key in _.idxs))
                            self.add(newItems[key], key);
                },
                empty: function () {
                    var _ = this._, i;
                    if (_.removed) {
                        for (i = 0; i < _.vals.length; i++)
                            _.removed.fire(_.vals[i], _.keys[i]);
                    }
                    _.vals = [];
                    _.keys = [];
                    _.idxs = {};
                    if (_.size)
                        _.size(0);
                    if (_.changed)
                        _.changed.fire();
                },
                _addArray: function (arr) {
                    for (var i = 0; i < arr.length; i++)
                        this.add(arr[i]);
                },
                _asArray: function () {
                    return this._.vals.slice(0); // clone the array
                },
                asReadOnly: function () {
                    var self = this, readonly = ro;
                    function ro(key) {
                        return arguments.length == 0 ?
                            self._asArray() :
                            self._getFromCache(key);
                    }
                    setPrototypeOrExtend(readonly, self);
                    readonly._init();
                    // the delete operator won't work deletes a member 
                    // from the object, but not from its prototype
                    readonly.add = null;
                    readonly.remove = null;
                    readonly.empty = null;
                    return readonly;
                },
                fork: function (methods) {
                    var self = this, writable = wr;
                    function wrap(fn) {
                        return isCommand(fn) ? Command(async(fn), fn.enabled) :
                            isFunction(fn) ? EnabledCommand(async(fn)) :
                                DisabledAsyncCommand(ENotSupported());
                    }
                    function wr(key) {
                        return arguments.length == 0 ? self() : self(key);
                    }
                    setPrototypeOrExtend(writable, self);
                    extend(writable, {
                        add: wrap(methods.add),
                        remove: wrap(methods.remove)
                    });
                    writable._init();
                    return writable;
                },
                // this method is depercated; use .fork
                asWritable: function (methods) {
                    return this.fork(methods);
                }
            });
            // since every collection is a function, Collection.prototype
            // is not a real prototype of every collection instance and thus
            // an attempt to edit the prototype won't change anything in
            // already created collections; however Collection.prototype is a
            // convenient and expected place to add methods that will be
            // shared between all collections
            extend(Collection.prototype, {
                constructor: Collection,
                toString: function () {
                    return '[Collection: ' + this.size() + ' items]';
                },
                each: function (fn) {
                    this.added(fn);
                    this.added.off(fn);
                    return this;
                },
                contains: function (predicate) {
                    var res = false;
                    // before making this function work with
                    // primitive values, consider collections that
                    // contain functions
                    this.each(function (val) {
                        if (predicate(val))
                            res = true;
                    });
                    return res;
                },
                observe: function (callback) {
                    var hTimer, source = this, added = {}, removed = {};
                    function itemAdded(val, key) {
                        added[key] = val;
                        delete removed[key];
                        startTimer();
                    }
                    function itemRemoved(val, key) {
                        removed[key] = val;
                        delete added[key];
                        startTimer();
                    }
                    function startTimer() {
                        if (!hTimer) {
                            hTimer = setTimeout(function () {
                                var _added = added, _removed = removed;
                                added = {}; // callback may add an item indirectly
                                removed = {}; // callback may remove an item indirectly
                                hTimer = null;
                                callback(_added, _removed);
                            }, 0);
                        }
                    }
                    function stopTimer() {
                        if (hTimer) {
                            clearTimeout(hTimer);
                            hTimer = null;
                        }
                    }
                    source.added(itemAdded);
                    source.removed(itemRemoved);
                    return {
                        dispose: function () {
                            stopTimer();
                            source.added.off(itemAdded);
                            source.removed.off(itemRemoved);
                        }
                    };
                },
                map: function (fn) {
                    var source = this, sub, mapped = Collection({
                        // the call to .get cannot be directly routed to the source
                        // collection because these collections have different items,
                        // despite these items have the same keys and the same order
                        get: function (src) {
                            return source.get().then(function () {
                                return mapped(src);
                            });
                        },
                        subscribed: function () {
                            sub = source.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    source.added(function (val, key, idx) {
                        // it's important to preserve the order of items
                        mapped.add(fn(val), key, idx);
                    });
                    source.removed(function (val, key) {
                        mapped.remove(key);
                    });
                    // theoretically the mapped collection can be left writable
                    // if it was possible to "unmap" every item with the inverse
                    // mapping function; since an arbitrary function cannot be
                    // inversed, the caller would need to pass both mapping and
                    // inverse mapping function
                    return mapped.asReadOnly();
                },
                filter: function (fn) {
                    var source = this, sub, filtered = Collection({
                        get: function (src) {
                            return source.get().then(function () {
                                return filtered(src);
                            });
                        },
                        subscribed: function () {
                            sub = source.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    source.added(function (val, key, idx) {
                        var si, sn, fi;
                        if (!fn(val))
                            return;
                        si = idx + 1;
                        sn = source.size();
                        // To preserve the original order of items find
                        // the closest item in the source collection which
                        // also exists in the filtered collection and insert
                        // the new item before that item.
                        while (si < sn && !fn(source(si)))
                            si++;
                        fi = si < sn ?
                            filtered.index(source.key(si)) :
                            filtered.size();
                        filtered.add(val, key, fi);
                    });
                    source.removed(function (val, key) {
                        filtered.remove(key);
                    });
                    return filtered.asReadOnly();
                },
                sort: function (isOrderCorrect) {
                    var unsorted = this, sub, sorted = Collection({
                        get: function (src) {
                            // the call cannot be directly routed to the unsorted collection
                            // because the order of items in the two collections is different
                            // and thus the same .get with the same index can return different items
                            return unsorted.get().then(function () {
                                return sorted(src);
                            });
                        },
                        subscribed: function () {
                            sub = unsorted.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    function ord(x, y) {
                        // ord(x, y) = x @ y tells whether x can precede y in the ordered collection;
                        // essentially @ is a transitive relation over the set of items;
                        // a well behaved relation must allow either (x, y) or (y, x) for any given x and y;
                        // if, however, it allows neither, it can be assumed that it doesn't care;
                        return isOrderCorrect(x, y) || !isOrderCorrect(y, x);
                    }
                    unsorted.added(function (val, key, idx) {
                        var n = sorted.size(), i = 0;
                        // The @ relation splits the entire collection into several groups:
                        // items witin a group can be placed in any order as @ cannot distinguish them,
                        // but the groups must come in a certain "ascending" order.
                        // Thus the first step before insering a new item into the sorted collection
                        // is to find the appropriate group G for that item. This loop finds the leftmost
                        // boundary of the appropriate group.
                        while (i < n && !ord(val, sorted(i)))
                            i++;
                        // After the appropriate group G is found, the item can be theoretically
                        // inserted at any position within the group, i.e. at the beginning or at the end,
                        // however it's better to consider how items in the group are ordered in
                        // the unsorted collection. The group G can be called "sorted" if for any
                        // pair of items x and y from G, if x appears before y in G, then it also appears
                        // before y in the unsorted collection. To not break this property of G, the new
                        // item must be inserted at the right position and, obviously, there is only
                        // one such position. The loop below finds this only possible position.
                        // Thus this loop makes the sorting algorithm stable.
                        while (i < n && ord(sorted(i), val) && unsorted.index(sorted.key(i)) < idx)
                            i++;
                        sorted.add(val, key, i);
                    });
                    unsorted.removed(function (val, key) {
                        sorted.remove(key);
                    });
                    return sorted.asReadOnly();
                }
            });
            var Collection;
            (function (Collection) {
                // An empty read only collection is useful to create stubs
                // in place of real collections. Since two empty read only
                // collections cannot be distinguished, it's reasonble to
                // have only one instance of such a collection.
                Collection.empty = Collection().asReadOnly();
            })(Collection = Utils.Collection || (Utils.Collection = {}));
            //#endregion
            //#region Model
            /**
             * @method {Object} toJSON - Takes a snapshot of the model.
             *
             */
            function Model(members) {
                return inherit(Model.prototype, members);
            }
            Utils.Model = Model;
            // .toJSON shouldn't be enumarable as .toJSON().toJSON should be absent
            setHiddenProperty(Model.prototype, 'toJSON', function () {
                return map(this, function fn(member) {
                    return isModel(member) ? member.toJSON() :
                        isCollection(member) ? map(member(), fn) :
                            isProperty(member) ? fn(member()) :
                                isCommand(member) ? { enabled: !!member.enabled() } :
                                    isFunction(member) ? { enabled: true } :
                                        member;
                });
            });
            //#endregion
            //#region SourcedProperty
            /**
             * A property that takes its value from another (source) property.
             *
             * @method setSource(source) - Sets source property
             *
             */
            function SourcedProperty() {
                var src, s, cs, p, enabled = Property({ value: false });
                p = Property({
                    get: function () {
                        return src && src.get();
                    },
                    set: Command(function (value, reason) {
                        return src && src.set(value, reason).then(function () {
                            return p();
                        });
                    }, enabled),
                    subscribed: function () {
                        s = src && src.subscribe();
                    },
                    unsubscribed: function () {
                        if (s) {
                            s.dispose();
                            s = null;
                        }
                    }
                });
                p.setSource = function (source) {
                    assert(isProperty(source) || !source);
                    if (src === source)
                        return;
                    src = source;
                    enabled(!!src);
                    if (cs) {
                        cs.dispose();
                        cs = null;
                    }
                    if (src) {
                        cs = src.changed(function (value, reason) {
                            p._set(value, reason);
                        });
                        if (src() === void 0)
                            p._set(src());
                    }
                    if (s) {
                        s.dispose();
                        s = src && src.subscribe();
                    }
                    if (!src)
                        p._set(void 0);
                };
                return p;
            }
            Utils.SourcedProperty = SourcedProperty;
            //#endregion
            //#region SourcedCommand
            /**
             * A command that delegates its execution to another (source) command.
             *
             * @method setSource(source) - Sets source cmd
             *
             * NB: it is assumed that source command is not using "this" in its implementation -
             * its context is coming from the closures.
             *
             */
            function SourcedCommand() {
                var cmd, src, enabled = SourcedProperty();
                // cmd with undefined source is disabled
                enabled.setSource(ConstProperty(false));
                cmd = Command(function () {
                    return src.apply(null, arguments);
                }, enabled);
                cmd.setSource = function (source) {
                    assert(isCommand(source) || !source);
                    src = source;
                    enabled.setSource(src ? src.enabled :
                        ConstProperty(false));
                };
                return cmd;
            }
            Utils.SourcedCommand = SourcedCommand;
            //#endregion
            //#region SourcedModel
            /**
             * A model composed of properties sourced by properties of another (source) model.
             *
             * @param {Model} model - A model used as a blueprint for sourced model construction.
             *
             * @method setSource(source) - Sets source model
             *
             */
            function SourcedModel(model) {
                var m = Model(map(model, function (member) {
                    return isProperty(member) ? SourcedProperty() :
                        isModel(member) ? SourcedModel(member) :
                            isCommand(member) ? SourcedCommand() :
                                // TODO: add collections
                                assert(false);
                }));
                setHiddenProperty(m, 'setSource', function (source) {
                    for (var i in m)
                        m[i].setSource(source && source[i]);
                });
                return m;
            }
            Utils.SourcedModel = SourcedModel;
            //#endregion
            //#region SequentialStateMachine
            /**
             * Implements a sequential state machine, i.e. the unidirectional state machine that advances
             * through an ordered set of states until it reaches the target state
             *
             * @param {Number} uninitState - Uninitialized state.
             *
             * @method defineState(state, handler)
             *
             *      Defines a state and an action needed to reach
             *      this state from the previous state.
             *
             * @method advanceTo(state) - Advances the state machine to the given state.
             * @method reset() - Reset the state machine to the uninitialized state.
             * @property {Number} state - The current state of the state machine.
             * @property {Number} target - The target state of the state machine.
             *
             * @example
             *
             *    var State = Enum('Zero', 'One', 'Two');
             *    var sm = SequentialStateMachine(State.Zero);
             *    sm.defineState(State.One, function () {
             *              // actions to get to One
             *              return 'Ok';
             *          });
             *    sm.defineState(State.Two, function () {
             *              // actions to get to Two
             *              return send('GET', '/me/name');
             *          });
             *
             *    sm.advanceTo(State.Two).then(function () {
             *          assert(sm.state() == State.Two);
             *    });
             *
             */
            function SequentialStateMachine(uninitState) {
                var current = Property({ value: uninitState }), target = Property({ value: uninitState }), handlers = {}, task, promise; // the current pending operation returned by handler[i]
                /**
                 * Defines machine actions for the state
                 *
                 * @param {Number} state
                 * @param {Function} handler
                 *
                 *      Action to be executed to reach this state from the previous one.
                 *      This function may return a value, a promise or throw an exception.
                 */
                function defineState(state, handler) {
                    assert(!handlers[state]);
                    assert(state > uninitState);
                    assert(isFunction(handler));
                    handlers[state] = async(handler);
                }
                /**
                 * Reset the state machine to the uninitialized state
                 *
                 *      The function will set the state machine to the uninitialized state,
                 *      keep all defined hanlders, and cancel the pending promise if there is one.
                 */
                function reset() {
                    current(uninitState);
                    target(uninitState);
                    // promise already set as null if it is cancelled or resolved
                    if (promise)
                        cancel(Exception('Reset'));
                    task = null;
                    promise = null;
                }
                /**
                 * Advances the state machine to the given state
                 *
                 * @param {Number} state - The desired state.
                 */
                function advanceTo(state) {
                    check(state >= target(), 'InvalidTargetState', {
                        currentTarget: target(),
                        requestedTarget: state
                    });
                    if (state == current())
                        return;
                    if (state > target()) {
                        task = Task('advancing to target state ' + state, {
                            cancel: cancel
                        });
                        target.set(state);
                        next(task);
                    }
                    return task.promise;
                }
                function cancel(reason) {
                    // this will invoke task.reject
                    promise.cancel(reason);
                    promise = null;
                }
                function next(task) {
                    // an existing promise signals that state transition is in progress
                    if (promise)
                        return;
                    var nextState = current() + 1;
                    task.status('advancing to state ' + nextState);
                    // the returned promise can be already resolved
                    // or rejected: to handle this case its "then"
                    // method is invoked separately
                    promise = handlers[nextState].call(null);
                    promise.then(function (result) {
                        promise = null;
                        current.set(nextState);
                        if (current() < target())
                            next(task);
                        else
                            task.resolve(result);
                    }, function (error) {
                        promise = null;
                        task.reject(error);
                    });
                }
                return {
                    defineState: defineState,
                    reset: reset,
                    advanceTo: async(advanceTo),
                    state: current.asReadOnly(),
                    target: target.asReadOnly()
                };
            }
            Utils.SequentialStateMachine = SequentialStateMachine;
            //#endregion SequentialStateMachine
            //#region throttle
            /**
             * @param ajax - A function that sends a HTTP request.
             *
             *      This function has the same signature as jQuery.ajax:
             *
             *          function ajax(request) {
             *              return Task().promise;
             *          }
             *
             * @param size - The max number of concurrent HTTP requests.
             *
             *      This parameter limits the number of HTTP requests that can
             *      be sent at the same time. If the caller tries to send
             *      more requests, the throttle will queue them and will send them
             *      in due order after the server replies to first requests.
             *
             * @returns A function that has the same signature as jQuery.ajax.
             *
             *      In addition it has a parameter specifying the priority of the request:
             *
             *          {async Response} send(Request request, Number priority)
             *
             *      The higher the priority, the sooner the request will leave
             *      the queue and will be actually sent.
             *
             *      If the function is invoked multiple times, it will send
             *      up to the specified number of requests and will save other
             *      requests into an internal queue. Then, after the server replies
             *      to first requests, the throttle will send requests from
             *      the queue.
             *
             */
            function throttle(ajax, size) {
                assert(isFunction(ajax));
                assert(size > 0);
                ajax = async(ajax);
                var sent = 0; // the number of sent requests to which the server has not replied
                var queue = []; // the ids of requests waiting for being sent
                var results = {}; // results[id] = the deferred for the id-th request
                var requests = {}; // requests[id] = the id-th request
                var priorities = []; // priorities[i] corresponds to queue[i]
                var pending = {}; // pending[id] is a promise that observes the progress of the corresponding request
                function dequeue() {
                    assert(sent <= size);
                    while (sent < size && queue.length > 0)
                        send();
                }
                function send() {
                    var id = queue.splice(0, 1)[0];
                    var request = requests[id];
                    var result = results[id];
                    delete requests[id];
                    delete results[id];
                    priorities.splice(0, 1);
                    sent++;
                    pending[id] = ajax(request);
                    pending[id].then(function (res) { return result.resolve(res); }, function (err) { return result.reject(err); }, result.status).then(function () {
                        sent--;
                        delete pending[id];
                        dequeue();
                    });
                }
                function insert(id, priority) {
                    var i = priorities.length;
                    while (i > 0 && priority > priorities[i - 1])
                        i--;
                    priorities.splice(i, 0, priority);
                    queue.splice(i, 0, id);
                }
                function cancel(id, reason) {
                    var i;
                    if (pending[id]) {
                        // this will invoke result.reject
                        pending[id].cancel(reason);
                    }
                    else {
                        results[id].reject(reason);
                        delete requests[id];
                        delete results[id];
                        for (i = 0; i < queue.length; i++) {
                            if (queue[i] == id) {
                                queue.splice(i, 1);
                                priorities.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                return function (request, priority) {
                    var id = random();
                    var task = Task('Waiting in the throttling queue.', {
                        cancel: bind(cancel, id)
                    });
                    results[id] = task;
                    requests[id] = request;
                    insert(id, priority);
                    dequeue();
                    return task.promise;
                };
            }
            Utils.throttle = throttle;
            //#endregion
            //#region singleton
            /**
             * Returns a single instance of an object constructed by the argument function
             *
             * @example
             *      var s = singleton(function() {
             *                  return { ticks: (new Date).getTime() };
             *              });
             *      var t0 = s().ticks, t1 = s().ticks;
             *      assert(t0 == t1);
             */
            function singleton(ctor) {
                assert(isFunction(ctor));
                var instance = null;
                return function () {
                    return instance || (instance = ctor());
                };
            }
            Utils.singleton = singleton;
            //#endregion
            //#region debounced
            /**
             * Debounces multiple requests to an async function.
             *
             * While the promise returned by the first call is pending,
             * all subsequent calls will return the same promise and won't
             * invoke the function.
             *
             *      fetch = debounced(function () {
             *          return ucwa.send("GET", "/presence").then(r => r.get("availability"));
             *      });
             *
             *      // fetch is invoked only once
             *      status1 = fetch();
             *      status2 = fetch();
             *
             */
            function debounced(fn) {
                var res, dfd, afn = async(fn);
                return function () {
                    if (!dfd) {
                        res = dfd = afn();
                        // if dfd is completed and the underlying task is sync,
                        // this callback will be executed right away, nulling dfd
                        dfd.finally(function () {
                            dfd = null;
                        });
                    }
                    return res;
                };
            }
            Utils.debounced = debounced;
            //#endregion
            //#region batched
            /**
             * JS code lives in a single-threaded event-based environment.
             * When an event occurs, a JS handler for that event may need
             * to send multiple HTTP requests in a loop and these requests
             * may be sent as a single batch request to UCWA. To achieve that
             * the function that sends HTTP requests puts a request into a
             * queue and invokes setTimeout/postMessage in order to empty the
             * queue and send the batch request after the JS code currently
             * being executed completes sending HTTP requests and quits.
             *
             * @param {Function} batch - Sends a batch request.
             *
             *  It has the following signature:
             *
             *      Response[] batch(Request[] requests)
             *
             *  It may return the results asynchronously.
             *
             * @param {Number} maxBatchSize
             *
             *      The max number of requests that the batch can send.
             *
             * @returns A function with the following signature:
             *
             *      {async Response} send(Request request, Number priority)
             *
             *          {Request} request - A request acceptable by the <batch> function.
             *          {Number} priority - Requests with higher priority are sent first.
             *
             *      The <send> function inserts <request> into an internal queue
             *      at a position appropriate to the given <priority> value: the
             *      higher priority the sooner the request will be extracted from
             *      the queue and sent with the <batch> function.
             *
             */
            function batched(batch, maxBatchSize) {
                assert(maxBatchSize > 0);
                // queue[i].request is a request to be sent with <batch>.
                // queue[i].task is a task that adopts a result of <batch>.
                // queue[i].priority is the importance of the request.
                // queue[i].priority <= queue[i + 1].priority
                var queue = [];
                // a handle of the pending timer that when expired
                // reads requests from the queue and sends them in batch
                var hTimer;
                /**
                 * Inserts a pending request into the queue and
                 * associates it with the given priority.
                 *
                 * @param {Number} priority
                 * @param {Object} request
                 * @param {Task} task
                 */
                function insert(priority, request, task) {
                    assert(isNumber(priority));
                    assert(task instanceof Task);
                    var i = 0;
                    while (i < queue.length && priority > queue[i].priority)
                        i++;
                    queue.splice(i, 0, { priority: priority, request: request, task: task });
                }
                /**
                 * Finds up to the given number of most urgent pending requests,
                 * removes them from the queue and returns them as an array.
                 *
                 * @param {Number} count
                 *
                 *      The max number of requests to extract.
                 *
                 * @returns Null or an object with two keys:
                 *
                 *      {Request[]} requests - All requests from the queue that are due to the given time.
                 *      {Task[]} tasks - Corresponding tasks.
                 */
                function extract(count) {
                    assert(count > 0);
                    assert(queue.length > 0);
                    var i, requests = [], tasks = [];
                    for (i = queue.length - 1; i >= 0 && requests.length < count; i--) {
                        requests.push(queue[i].request);
                        tasks.push(queue[i].task);
                    }
                    queue.splice(i + 1, count);
                    return { requests: requests, tasks: tasks };
                }
                /**
                 * Attempts to cancel the given task.
                 */
                function cancel(task, reason) {
                    var i;
                    for (i = 0; i < queue.length; i++)
                        if (queue[i].task === task)
                            break;
                    if (i < queue.length) {
                        // the request is still waiting in the queue,
                        // so it can be just removed from and marked as cancelled
                        queue.splice(i, 1);
                        task.reject(reason);
                    }
                    else {
                        // the request has been sent in a batch of other
                        // requests to the throttling queue; it cannot be
                        // thus cancelled, but the response may be ignored
                        task.cancelled = true;
                        task.reject(reason);
                    }
                }
                /**
                 * Periodically extracts pending requests up to maximum batch size,
                 * sends them in a batch and redirects the batch response to pending tasks.
                 */
                function send() {
                    var pending = extract(maxBatchSize);
                    function forEachPendingTask(fn) {
                        foreach(pending.tasks, function (task, i) {
                            if (!task.cancelled)
                                fn(task, i);
                        });
                    }
                    Task.wait(batch(pending.requests)).then(function (responses) {
                        forEachPendingTask(function (task, i) {
                            var rsp = isArray(responses) ? responses[i] : responses;
                            Task.wait(rsp).then(function (res) { return task.resolve(res); }, function (err) { return task.reject(err); }, task.status);
                        });
                    }, function (error) {
                        forEachPendingTask(function (task) {
                            task.reject(error);
                        });
                    }, function (status) {
                        forEachPendingTask(function (task) {
                            task.status(status);
                        });
                    });
                }
                return function (request, priority) {
                    var task = Task('Waiting in the batching queue.', {
                        cancel: function (reason) {
                            cancel(task, reason);
                        }
                    });
                    if (!hTimer) {
                        hTimer = setTimeout(function () {
                            hTimer = null;
                            while (queue.length > 0)
                                send();
                        }, 0);
                    }
                    insert(priority, request, task);
                    return task.promise;
                };
            }
            Utils.batched = batched;
            //#endregion
            //#region URI (see RFC 3986)
            /**
             * Parses a URI, provides API to edit its parts and to stringify
             * the changed URI parts into a URI string:
             *
             *      uri = URI("http://contoso.com/data?tag=1");
             *      uri.scheme("https").port(443);
             *      uri == "https://contoso.com:443/data?tag=1");
             *
             * @property {String} scheme - e.g. "https"
             * @property {String} user - e.g. "johndoe:123"
             * @property {String} host - e.g. "contoso.com"
             * @property {String} port - e.g. "8081"
             * @property {String} path - e.g. "/ucwa/oauth/v1/me/name"
             * @property {String} query - e.g. "groupId=wnm176snmq=&tag=2"
             * @property {String} hash - e.g. "Introduction"
             *
             */
            function URI(text) {
                var parts;
                if (!(this instanceof URI))
                    return new URI(text);
                parts = URI.pattern.exec((text || '') + '');
                // the regexp is written in such a way, that it matches any string,
                // so this exception is never thrown; this may change once the regexp
                // is written more accurately
                if (!parts)
                    throw new SyntaxError('Invalid URI: ' + text);
                function bind(name) {
                    var prop = function (value) {
                        if (arguments.length == 0)
                            return (parts[name] || '') + '';
                        parts[name] = (value || '') + '';
                        return this;
                    };
                    prop.toString = function () {
                        return prop();
                    };
                    return prop;
                }
                this.scheme = bind('scheme');
                this.user = bind('user');
                this.host = bind('host');
                this.port = bind('port');
                this.path = bind('path');
                this.query = bind('query');
                this.hash = bind('hash');
            }
            Utils.URI = URI;
            URI.prototype.toString = function () {
                var prefixed = function (prefix, value) { return value ? prefix + value : ''; };
                var authority = (!this.user() ? '' : this.user() + '@') + (this.host() || '') + prefixed(':', this.port());
                return (this.scheme() ? this.scheme() + ':' : '') +
                    prefixed('//', authority) + this.path() +
                    prefixed('?', this.query()) +
                    prefixed('#', this.hash());
            };
            var URI;
            (function (URI) {
                URI.pattern = {
                    // RFC 3986 specifies an ABNF of URI, but since we don't have an ABNF parser and since that particular
                    // ABNF can be represented with a regular expression, I chose to write a regexp here. The mentioned ABNF
                    // has the following form: [scheme ":"] ["//" [user "@"] host [":" port]] path ["?" query] ["#" hash]
                    regexp: /^(?:([a-zA-Z][\w+-.]*):)?(?:\/\/(?:([^/@]*)@)?([^:/?#]*)(?:\:(\d*))?)?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/,
                    exec: function (text) {
                        var p = this.regexp.exec(text);
                        return p && { scheme: p[1], user: p[2], host: p[3], port: p[4], path: p[5], query: p[6], hash: p[7] };
                    }
                };
                /**
                 * Parses the query part of the URI
                 * and lets stringify it back:
                 *
                 *      var uri = URI.Query("a=1&b=2&c=3");
                 *
                 *      uri.a = 111;
                 *      delete uri.b;
                 *      uri.d = 444;
                 *
                 *      uri == "a=111&c=3&d=444";
                 *
                 */
                function Query(text) {
                    if (!(this instanceof Query))
                        return new Query(text);
                    var self = this;
                    if (isString(text)) {
                        foreach(text.split('&'), function (pair) {
                            var k, v, i = pair.indexOf('=');
                            if (i < 0) {
                                k = pair;
                                v = '';
                            }
                            else {
                                k = pair.slice(0, i);
                                v = pair.slice(i + 1);
                            }
                            if (k) {
                                self[decodeURIComponent(k)] = decodeURIComponent(v);
                            }
                        });
                    }
                    else if (text) {
                        // note how clone gets rid of the object's prototype
                        foreach(clone(text), function (v, k) {
                            self[k] = v + '';
                        });
                    }
                }
                URI.Query = Query;
                Query.prototype.toString = function () {
                    var pairs = [];
                    // note how clone(this) gets rid of this.toString
                    foreach(clone(this), function (v, k) {
                        pairs.push(v ?
                            encodeURIComponent(k) + '=' + encodeURIComponent(v) :
                            encodeURIComponent(k));
                    });
                    return pairs.join('&');
                };
            })(URI = Utils.URI || (Utils.URI = {}));
            //#endregion
            //#region HttpStatus
            Utils.HttpStatus = {
                isInfo: bind(isInRange, 100, 199),
                isSuccess: bind(isInRange, 200, 299),
                isRedirection: bind(isInRange, 300, 399),
                isClientError: bind(isInRange, 400, 499),
                isServerError: bind(isInRange, 500, 599),
                isError: bind(isInRange, 400, 599),
                Unauthorized: 401,
                ProxyAuthenticationRequired: 407,
                ExpectationFailed: 417,
                TooManyRequests: 429,
                InternalServerError: 500
            };
            //#endregion
            //#region HttpHeaders
            /**
             * This is a collection of HTTP headers.
             * jQuery returns HTTP headers as a string, so it needs
             * to be parsed before use.
             *
             * @param {string} text - A multiline string with all the headers.
             *
             * @method {string} get(name) - Returns the value associated with the header.
             * @method add(name, value) - Adds a new value for a header.
             * @method {string} toString - Returns the textual representation of the headers.
             *
             * @example
             *
             *      var headers = HttpHeaders('Authorization: Bearer cwt=abcdef\nH: Qwerty\n\n');
             *      headers.get('authorization') == 'Bearer cwt=abcdef';
             *      headers.get('h') == 'Qwerty';
             *
             */
            function HttpHeaders(text) {
                /**
                 * Parses the multi-line string containing the headers.
                 */
                function parse(text) {
                    assert(isString(text));
                    var lines = text.split('\r\n');
                    var sep, name, value, line;
                    for (var i = 0; i < lines.length; i++) {
                        if (line = trim(lines[i])) {
                            sep = line.indexOf(':');
                            // silently skip invalid headers
                            if (sep >= 0) {
                                name = trim(line.substr(0, sep));
                                value = trim(line.substr(sep + 1));
                                add(name, value);
                            }
                        }
                    }
                }
                /**
                 * Copies headers from another list of headers.
                 */
                function copy(hdrs) {
                    assert(isDictionary(hdrs));
                    for (var name in hdrs)
                        add(name, hdrs[name] + '');
                }
                /**
                  * Gets the value of the header.
                  *
                  * @param {string} name
                  * @returns {string}
                  */
                function get(name) {
                    assert(isNotEmptyString(name));
                    return headers[name.toLowerCase()];
                }
                /**
                 * Adds a new value to a header.
                 *
                 * @param {string} name - The name of the header.
                 * @param {string} value - The new value for the header.
                 */
                function add(name, value) {
                    assert(isNotEmptyString(name));
                    assert(isNotEmptyString(value));
                    name = name.toLowerCase();
                    if (headers[name])
                        headers[name] += '\n' + value;
                    else
                        headers[name] = value;
                }
                /**
                 * Returns a text representation of the headers.
                 *
                 * @returns {string}
                 */
                function stringify() {
                    var i, name, values, text = '';
                    for (name in headers) {
                        values = headers[name].split('\n');
                        for (i = 0; i < values.length; i++)
                            if (values[i])
                                text += name + ': ' + values[i] + '\r\n';
                    }
                    return text + '\r\n';
                }
                var headers = {};
                if (isNotEmptyString(text))
                    parse(text);
                else if (isDictionary(text))
                    copy(text);
                return {
                    get: get,
                    add: add,
                    toString: stringify
                };
            }
            Utils.HttpHeaders = HttpHeaders;
            //#endregion HttpHeaders    
            //#region ContentTypeHeader
            /**
             * Parses a value of the Content-Type header. An example of such as header:
             *
             *      Content-Type: multipart/related; type="text/plain"; charset=utf-8; boundary=123
             *
             * @param {String} value - The text value of the Content-Type header.
             *
             * @member {String} mimeType - e.g. "multipart/related"
             * @member {Object} attributes - e.g. {charset:"utf-8"}
             */
            function ContentTypeHeader(value) {
                // DataUri already has a parser for mime types
                var dataUri = DataUri('data:' + value.replace(/\s/g, '') + ',');
                return {
                    mimeType: dataUri.mime,
                    attributes: dataUri.attributes
                };
            }
            Utils.ContentTypeHeader = ContentTypeHeader;
            //#endregion
            //#region timeStampToDate
            /**
             * Converts time-stamp (string) into a UTC ISO 8061 date string (new Date().toJSON())
             *
             * @param {Date} date
             *
             * @returns {string} - in the form of 'YYYY-MM-DDThh:mm:ss.sZ'
             */
            function timeStampToDate(ts) {
                if (!ts) {
                    return ts;
                }
                // "/Date(11111111111)/" => new Date(11111111111)
                var p = /\d+/.exec(ts);
                return new Date(p && +p[0]);
            }
            Utils.timeStampToDate = timeStampToDate;
            //#endregion
            //#region dateToTimeStamp
            /**
             * Converts a Date object into a formatted string
             *
             * @param {Date} date
             *
             * @returns {string} - in the form of '/Date(123)/'
             */
            function dateToTimeStamp(date) {
                if (!date) {
                    return date;
                }
                // Date(11111111111) => "/Date(11111111111)/"
                return '\/Date(' + (+date) + ')\/';
            }
            Utils.dateToTimeStamp = dateToTimeStamp;
            //#endregion
            //#region setEqual
            /**
             * Compares two sets and determines if they are equal by checking if each is a subset of the other
             *
             * @param {Array} set1 - First set to compare
             * @param {Array} set2 - Second set to compare
             *
             * @returns {boolean} - indicates where the first and second sets are equal
             */
            function setEqual(set1, set2) {
                function isSubSet(a, b) {
                    for (var i = 0; i < a.length; i++) {
                        if (indexOf(b, a[i]) < 0) {
                            return false;
                        }
                    }
                    return true;
                }
                return isSubSet(set1, set2) && isSubSet(set2, set1);
            }
            Utils.setEqual = setEqual;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=utils.js.map

/// <reference path="./utils.ts" />
/**
 * This file implements authentication flows.
 * It doesn't contain any UCWA-specific stuff:
 * such stuff goes to the ucwa.js file.
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            
            var global = window.ttt ? window.ttt.window : window;
            //#region Imports (from Skype.Web.Utils)
            var Utils = Skype.Web.Utils;
            var debug = Utils.debug;
            var URI = Utils.URI;
            var isObject = Utils.isObject;
            var bind = Utils.bind;
            var random = Utils.random;
            var Task = Utils.Task;
            var async = Utils.async;
            var guid = Utils.guid;
            var check = Utils.check;
            var Exception = Utils.Exception;
            var W3A = Utils.WWWAuthenticateHeader;
            var XmlDoc = Utils.XmlDoc;
            var HttpHeaders = Utils.HttpHeaders;
            var HttpStatus = Utils.HttpStatus;
            Utils = null;
            //#endregion
            //#region Constants
            var sW3A = 'WWW-Authenticate';
            var sMSD = 'X-MS-Diagnostics';
            //#endregion
            //#region Common Exceptions
            function EGrantTypeNotSupported(type, msra) {
                var text = 'grant_type=' + type + ' is not in the list: [' + msra.grant_type + ']';
                return Exception.call(text, 'GrantTypeNotSupported', { grant_type: type, msra: msra });
            }
            //#endregion
            //#region XMsDiagnostics
            /**
             * Parses the X-Ms-Diagnostics header.
             *
             * X-MS-Diagnostics: 28032;source="contoso.com";reason="The web ticket is invalid."
             * X-MS-Diagnostics: 28072;source="contoso.com";reason="The ticket presented could not be verified, a new ticket is required."
             *
             * @member {Number} code
             */
            function XMsDiagnostics(header) {
                var parts = (header || '').split(';');
                return {
                    code: +parts[0]
                };
            }
            //#endregion
            //#region WebTicketService
            /**
             * Encapsulates /WebTicket/WebTicketService.svc and offers
             * API to get web tickets from the server either by exchanging
             * the RPSAuth cookie or by exchanging the OAuth token.
             *
             * @param root - e.g. https://webdir.online.lync.com
             * @param send - The underlying transport layer.
             * @param [context] - It's a GUID set by unit tests.
             *
             * @method getOAuthUrl
             * @method getPassiveAuthUrl
             * @method getWsFedPassivePath
             * @method getOAuthPath
             * @method getWebTicket
             *
             */
            function WebTicketService(root, send, context) {
                var mex, svc, soap = '<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">' +
                    '<s:Body>' +
                    '<RequestSecurityToken xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" Context="{context}" xmlns="http://docs.oasis-open.org/ws-sx/ws-trust/200512">' +
                    '<TokenType>urn:component:Microsoft.Rtc.WebAuthentication.2010:user-cwt-1</TokenType>' +
                    '<RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</RequestType>' +
                    '<AppliesTo xmlns="http://schemas.xmlsoap.org/ws/2004/09/policy">' +
                    '<EndpointReference xmlns="http://www.w3.org/2005/08/addressing">' +
                    '<Address>{scope}</Address>' +
                    '</EndpointReference>' +
                    '</AppliesTo>' +
                    '</RequestSecurityToken>' +
                    '</s:Body>' +
                    '</s:Envelope>';
                // the web ticket service URL can be discovered
                // by looking at (GET /ucwa).X-MS-WebTicketURL
                function getWebTicketServicePath() {
                    var defaultPath = '/WebTicket/WebTicketService.svc';
                    return send({
                        type: 'GET',
                        url: '/ucwa'
                    }).then(function (rsp) {
                        var hdr = HttpHeaders(rsp.headers).get('X-MS-WebTicketURL');
                        svc = URI(hdr).path() || defaultPath;
                    }).catch(function () {
                        svc = defaultPath;
                    });
                }
                // The first step is to discover the URLs of the web ticket service.
                // There are two ways to do this: the old way to inspect the mex XML
                // and the modern way to inspect a 400 response from a POST to
                // the /WebTicket/oauthtoken handler. The second approach is JS-friendly,
                // but not reliable because instead of a 400 with the URL it may
                // return some random error.
                function getConfigXml() {
                    return mex = mex || getWebTicketServicePath().then(function () {
                        return send({
                            type: 'GET',
                            url: svc + '/mex'
                        });
                    }).then(function (rsp) {
                        if (HttpStatus.isSuccess(rsp.status))
                            return rsp.responseText;
                        else
                            throw Exception('MexRequestFailed', { response: rsp });
                    });
                }
                // this must return a full URL because it'll be used
                // as the source of an iframe element
                function getPassiveAuthUrl() {
                    return getConfigXml().then(function (xml) {
                        // <af:WsFederationPassive af:passiveauthpage=".../PassiveAuth/PassiveAuth.aspx" /> 
                        return /\bpassiveauthpage="(.+?)"/i.exec(xml)[1];
                    }).catch(function () {
                        return root + '/PassiveAuth/PassiveAuth.aspx';
                    });
                }
                // this must return a full URL because it'll be used
                // as the source of an iframe element
                function getOAuthUrl() {
                    return getConfigXml().then(function (xml) {
                        // <af:OAuth af:authorizationUri="https://login.windows.net/common/oauth2/authorize"/> 
                        return /\bauthorizationUri="(.+?)"/i.exec(xml)[1];
                    });
                }
                // this must return only a path because it'll be used as
                // the target for an XHR request and XHR requests cannot
                // be sent to other domains because of the same-origin policy
                function getWsFedPassivePath() {
                    return getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'WsFedPassive' })
                            .selectOne('soap:address');
                        return URI(node.attr('location')).path();
                    }).catch(function () {
                        return svc + '/WsFed_passive';
                    });
                }
                // this must return only a path because it'll be used as
                // the target for an XHR request and XHR requests cannot
                // be sent to other domains because of the same-origin policy
                function getOAuthPath() {
                    return getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'OAuth' })
                            .selectOne('soap:address');
                        return URI(node.attr('location')).path();
                    }).catch(function () {
                        return svc + '/OAuth';
                    });
                }
                // The last step is to exchange the RPSAuth/LyncWif cookie for a web ticket.
                // The client doesn't have access to these cookies and thus it cannot know whether
                // they exist or not, so it blindly sends a request in assumption that these cookies
                // exist. If they don't, the server will reply with an error message.
                //
                // There are two ways to get the web ticket: the old way to send an XML request
                // to /WsFed_Passive and the modern way to send a request to /oauthtoken. The second
                // approach is JS-friendly and is easier to use, but it gives web tickets with
                // invalid audience if the sign in user is homed on a pool different from the one
                // to which this request is sent.
                //
                // The same API can be used to exchange an OAuth token for a web ticket. In this case
                // the token is kept inside the iframe and is unavailable to the client, but the client
                // can send a POST to /OAuth to get a web ticket: the iframe will attach the OAuth token,
                // the web ticket service will check the token and return a web ticket. The created
                // web ticket has about the same lifetime as the OAuth token.
                function getWebTicket(path) {
                    return send({
                        type: 'POST',
                        url: path,
                        headers: {
                            'SOAPAction': 'http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue',
                            'Content-Type': 'text/xml; charset=utf-8'
                        },
                        data: soap
                            .replace('{scope}', root)
                            .replace('{context}', context || guid()) // this must be a GUID - random values in other forms are rejected
                    }).then(function (rsp) {
                        // <RequestedSecurityToken>
                        //  <a:UserToken>cwt=...</a:UserToken>
                        // </RequestedSecurityToken>
                        if (HttpStatus.isSuccess(rsp.status))
                            return 'Bearer ' + /<(?:a:)?UserToken.*?>(.+?)<\/(?:a:)?UserToken>/i.exec(rsp.responseText)[1];
                        else
                            throw Exception('WsFedRequestFailed', { response: rsp });
                    });
                }
                return {
                    getOAuthUrl: getOAuthUrl,
                    getPassiveAuthUrl: getPassiveAuthUrl,
                    getWsFedPassivePath: getWsFedPassivePath,
                    getOAuthPath: getOAuthPath,
                    getWebTicket: getWebTicket
                };
            }
            //#endregion
            //#region MsRtcOAuth (MsRtcOAuth grant_type=...)
            /**
             * It basically finds the "WWW-Authenticate" header in the
             * HTTP 401 response, extracts the URL of the auth service and
             * sends user name and password (if given) to that service.
             * The service responds with the token string.
             *
             * @param {Object|Function} params - An async function that gets a web ticket.
             *
             *  `params` can be an async function that is called whenever a new web ticket
             *  is needed. That function takes two parameters (another async function
             *  that sends HTTP requests and a parsed MsRtcOAuth section from the WWW-Authenticate
             *  headers) and returns a promise that resolves to a string with the
             *  compact web ticket. Thus this function can look like this:
             *
             *      function (send, msra) {
             *          msra.href == "https://lyncweb.com/WebTicket/oauthtoken";
             *          msra.grant_type == "password;urn:microsoft.rtc:windows";
             *          return sleep(1000).then(function () {
             *              return "Bearer cwt=ABCDEF";
             *          });
             *      }
             *
             *  This function only needs to get a new web ticket. All the logic of
             *  caching the web ticket, deciding when to renew it, when to give up
             *  renewing and so on is outside this function and is implemented in
             *  the MsRtcOAuth class.
             *
             *  `params` can be an object with a few parameters for the default
             *  procedure to get a web ticket: this procedure basically sends
             *  a POST request to MsRtcOAuth.href URL and parses the JSON response.
             *  This default procedure is implemented in MsRtcOAuth.get.
             *
             * @returns {Function} - An async function that acts as a layer in the HTTP stack.
             *
             *  This function is responsible to seamlessly authenticate all requests
             *  going thru it. It takes two parameters (a request object and another
             *  async function that sends a request and returns a response) and returns
             *  a response. Thus it may look like this:
             *
             *      function (req, send) {
             *          return sleep(1000).then(function () {
             *              req.headers['Authorization'] = "Bearer cwt=ABCDEF";
             *              return send(req);
             *          });
             *      }
             *
             */
            function MsRtcOAuth(params) {
                var token, isNew, dfd, renew = async(isObject(params) ? bind(MsRtcOAuth.get, params) : params);
                //#region processResponse
                /**
                 * Handles all HTTP responses and checks whether they indicate an
                 * authorization failure. If they do, it tries to obtain an auth
                 * token and resend the original request.
                 *
                 * In theory, the server may keep responding with HTTP 401 or with HTTP 500
                 * and the client will thus keep trying to get the auth token. However
                 * this situation doesn't seem likely to happen and if it does happen,
                 * it should be handled by invoking the Task::cancel method.
                 *
                 * @param {Function} send(request) - Sends a request and returns a response.
                 * @param {HttpResponse} response
                 * @param {HttpRequest} request
                 *
                 * @returns {Promise<HttpResponse>}
                 */
                function processResponse(send, response, request) {
                    var headers = HttpHeaders(response.headers);
                    var authHeader = headers.get(sW3A);
                    var diagHeader = headers.get(sMSD);
                    var auth;
                    try {
                        auth = authHeader && W3A(authHeader);
                    }
                    catch (error) {
                        auth = null;
                    }
                    // HTTP 401 Unauthorized
                    // WWW-Authenticate: MsRtcOAuth href="contoso.com/oauthtoken",grant_type="password"
                    if (response.status == HttpStatus.Unauthorized && auth && auth.MsRtcOAuth) {
                        // if the server rejects a new web ticket, no need to get another one -
                        // it will be rejected anyway
                        if (isNew)
                            throw response;
                        // if renewing the token is taking too long, subsequent requests shouldn't
                        // start getting more tokens; otherwise in the passive auth after the rpsauth
                        // cookie expires, every subsequent request will result in a 401 and will
                        // create a new <iframe> to get a new token: in a few hours there will be hundreds
                        // of <iframe> elements that don't do anything
                        dfd = dfd || renew(send, auth.MsRtcOAuth).then(function (cwt) {
                            token = cwt;
                            isNew = true;
                        }).finally(function () {
                            dfd = null;
                        });
                        return dfd.then(function () {
                            return sendRequest(request, send);
                        }).then(function (response) {
                            response.webTicketRenewed = true;
                            return response;
                        });
                    }
                    else if (diagHeader && diagHeader.split(';')[0] in { '28032': 1, '28072': 1 } ||
                        response.status == HttpStatus.Unauthorized) {
                        // if the server rejects a new web ticket, no need to get another one -
                        // it will be rejected anyway
                        if (isNew)
                            throw response;
                        // HTTP 500 Internal Server Error
                        // X-MS-Diagnostics: 28032;source="contoso.com";reason="The web ticket is invalid."
                        //
                        // HTTP 401 Unauthorized
                        // X-MS-Diagnostics: 28072;source="contoso.com";reason="The ticket presented could not be verified, a new ticket is required."
                        return send({
                            type: 'GET',
                            url: '/ucwa/oauth'
                        }).then(function (response) {
                            if (request.headers)
                                delete request.headers['Authorization'];
                            return processResponse(send, response, request);
                        });
                    }
                    else {
                        // HTTP 200
                        isNew = false;
                        return response;
                    }
                }
                //#endregion
                //#region sendRequest
                function sendRequest(request, send) {
                    if (token) {
                        if (!request.headers)
                            request.headers = {};
                        request.headers['Authorization'] = token;
                    }
                    return send(request).then(function (response) {
                        return processResponse(send, response, request);
                    });
                }
                //#endregion
                return sendRequest;
            }
            //#endregion
            var MsRtcOAuth;
            (function (MsRtcOAuth) {
                //#region MsRtcOAuth.get
                /**
                 * Handles a response of the following form:
                 *
                 *      HTTP 401 Unauthorized
                 *      WWW-Authenticate: MsRtcOAuth ...
                 *
                 * @param {Object} msra - MsRtcOAuth from WWW-Authenticate header.
                 * @param {Object} data - Params that need to be sent in a POST in order to get a token.
                 * @param {Function} send - A function that sends a request and eventually returns a response:
                 *
                 *      send("GET", "/some/url").then(function (rsp) {
                 *          console.log(rsp.status);
                 *      });
                 *
                 * @returns {Promise<String>} - A promise object that resolves to the compact web ticket.
                 */
                function get(data, send, msra) {
                    if (msra.grant_type.indexOf(data.grant_type) < 0)
                        throw EGrantTypeNotSupported(data.grant_type, msra);
                    return send({
                        type: 'POST',
                        url: msra.href,
                        data: data
                    }).then(function (response) {
                        if (!HttpStatus.isSuccess(response.status))
                            throw Exception('InvalidCreds', { response: response });
                        var parsed = JSON.parse(response.responseText);
                        check.belongs('token_type', parsed);
                        check.belongs('access_token', parsed);
                        return parsed.token_type + ' ' + parsed.access_token;
                    });
                }
                MsRtcOAuth.get = get;
                ;
            })(MsRtcOAuth || (MsRtcOAuth = {}));
            //#region Basic (MsRtcOAuth grant_type=password)
            /**
             * It sends the credentials in plain text with grant_type=password
             * to get the auth token. Note, that the user name may differ from
             * the sign in address (which is used for auto discovery). For instance
             * auto discovery starts from "user1@contoso.com" but when asked
             * for credentials, the client is supposed to provide "group1\user1"
             * as the user name.
             *
             * @param {String} username
             * @param {String} password
             *
             */
            function Basic(username, password) {
                return MsRtcOAuth({
                    grant_type: 'password',
                    username: username,
                    password: password
                });
            }
            Auth.Basic = Basic;
            //#endregion
            //#region Integrated (MsRtcOAuth grant_type=urn:microsoft.rtc:windows)
            /**
             * It sends grant_type=urn:microsoft.rtc:windows to the auth service, the latter
             * sends a special reply that is handled by the browser (it shows a popup window
             * to prompt for credentials) and then the browser sends a reply with the token
             * as though there was no NTLM negotiation between the first request and the last
             * response.
             *
             * Note, that not all browsers support this authentication.
             *
             */
            function Integrated() {
                return MsRtcOAuth({
                    grant_type: 'urn:microsoft.rtc:windows'
                });
            }
            Auth.Integrated = Integrated;
            //#endregion       
            //#region Passive (MsRtcOAuth grant_type=urn:microsoft.rtc:passive)
            /**
             * The passive auth is about exchanging a cookie set for the Lync server FQDN
             * for an access token for that FQDN. The full authentication flow consists of
             * three steps:
             *
             *  1. Redirect the user to the login page and let him sign in.
             *  2. Discover the Lync's passive auth URL and use it to get the cookie.
             *  3. Exchange the cookie for an access token.
             *
             * The first step requires the full page redirect and involves UI, so it's beyond
             * the scope of this library.
             *
             * The second step is meant to be done via a POST request to /oauthtoken which is
             * designed for JS web apps, but because of several bugs in /oauthtoken that do not
             * have workarounds, this library reads XML from /mex and finds there the passive
             * auth URL that usually ends with /PassiveAuth.aspx This URL is then used as the
             * source of a hidden iframe that loads the page, follows redirects if any and executes
             * JS code downloaded from a trusted site. The JS code sends a request to the Lync
             * server and in a response the server sends the RPSAuth or LyncWif cookie.
             *
             * The third step is meant to be done via the very same POST to /oauthtoken which is
             * designed for JS web apps, but because of another bug on the server, the library has
             * to send a SOAP request to /WsFed_Passive and extract the access token from a SOAP
             * response.
             *
             */
            function Passive(document) {
                // to simplify writing unit tests
                document = document || global.document;
                // The function given to MsRtcOAuth is invoked every time a new web ticket
                // is needed. That function takes two parameters: 
                //
                //  1. A function to send HTTP requests on behalf of the Lync pool for which the web ticket is needed.
                //  2. The parsed MsRtcOAuth section from the WWW-Authenticate header.
                //
                // The function returns a promise that resolves to the web ticket.
                return MsRtcOAuth(function (send, msra) {
                    // The scope of the required web ticket can be extracted from MsRtcOAuth.
                    var aspx, cwts, root = URI(msra.href).path('') + '', wtsvc = WebTicketService(root, send);
                    return Task.wait(0).then(function () {
                        // The Task.waitAll below handles three possible error cases:
                        //
                        //  1. If the GET fails, the two default URLs must be taken.
                        //  2. If the GET succeeds but the regexp fails, only the default aspx URL must be taken.
                        //  3. If the GET succeeds but XmlDoc fails, only the default WsFed URL must be taken.
                        // 
                        return Task.waitAll([
                            wtsvc.getPassiveAuthUrl().then(function (url) {
                                aspx = url;
                            }),
                            wtsvc.getWsFedPassivePath().then(function (url) {
                                cwts = url;
                            }),
                        ]);
                    }).then(function () {
                        // The second step is to use the OrgID service URL to get the RPSAuth or LyncWif
                        // cookie for the Lync server FQDN. This can be done implicitly, without prompting
                        // for user credentials, because the user has already signed in to OrgID and the
                        // client browser has remembered auth cookies for the OrgID FQDNs.
                        //
                        // In order to get the RPSAuth/LyncWif cookie the client needs to download the HTML
                        // page located at the passive auth URL and process it as any other regular HTML page.
                        // This can be done with a hidden iframe.
                        var n = 0, tasks = [], iframe;
                        function awaitLoad(i) {
                            tasks[i] = Task('waiting for the ' + i + '-th onload event from iframe at ' + aspx);
                            return tasks[i].promise;
                        }
                        iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.src = aspx;
                        // The onload event may be fired multiple times:
                        //
                        //  - once if the RPSAuth/LyncWif cookie already exists
                        //  - twice if the OrgID cookies exist, but RPSAuth/LyncWif doesn't
                        //  - three times if the signed in user is federated and doesn't have OrgID cookies
                        //
                        iframe.onload = function () {
                            tasks[++n].resolve();
                        };
                        document.body.appendChild(iframe);
                        // Federated users aren't supported, so this implementation expects
                        // up to two onload events.
                        return Task.waitAny([
                            // one request to be sent immediately in case the RPSAuth cookie already exists
                            Task.wait(0).then(bind(wtsvc.getWebTicket, cwts)),
                            // one request to be sent after the frame loads one time in case Lync server doesn't redirect to OrgID
                            awaitLoad(1).then(bind(wtsvc.getWebTicket, cwts)),
                            // one request to be sent after the frame loads twice in case Lync server redirects to OrgID
                            awaitLoad(2).then(bind(wtsvc.getWebTicket, cwts))
                        ]).finally(function () {
                            // No matter whether the web ticket received,
                            // the iframe needs to be removed. Notice, how
                            // this clean-up code doesn't alter the result
                            // and doesn't modify the exception.
                            document.body.removeChild(iframe);
                        });
                    }).catch(function (err) {
                        // If the web ticket cannot be obtained, provide the URL
                        // that needs to be followed to sign the user in.
                        throw aspx ? Exception('NotSignedIn', { aspx: aspx, reason: err }) : err;
                    });
                });
            }
            Auth.Passive = Passive;
            //#endregion
            //#region Implicit (OAuth2 response_type=token)
            /**
             * The OAuth2 implicit grant flow (RFC 6749, section 4.2).
             *
             * In the implicit auth flow the client creates a new <iframe> to get
             * a new access token. Let's say the client has sent a request to UCWA
             * and got a 401 in response:
             *
             *      GET /contacts
             *      Host: webdir.tip.lync.com
             *
             *      HTTP 401
             *      WWW-Authenticate: Bearer authorization_uri="https://login.windows.net/authorize"
             *
             * The client needs an access token for the webdir.tip.lync.com resource.
             * This can be achieved by sending a GET to the OAuth URI:
             *
             *      GET /authorize?response_type=token
             *          &client_id=...
             *          &state=...
             *          &resource=https://webdir.tip.lync.com
             *          &redirect_uri=https://webdir.tip.lync.com/xframe
             *      Host: login.windows.net
             *
             *      HTTP 302
             *      Location: https://webdir.tip.lync.com/xframe#access_token=...
             *          &token_type=Bearer
             *          &state=...
             *          &expires_in=3599
             *
             * Since 302 responses cannot be inspected with XHR, the client has to implement
             * an HTML page and specify the URL of this page in the redirect_uri parameter.
             * Then this page will be loaded with the access token in its URL.
             *
             * To prevent malicious scripts from stealing the token, it's kept securely
             * inside that page. At the same time this token must be sent to UCWA in every
             * request in the Authorization header. To meet the two requirements the xframe
             * also serves as the landing page for the access token.
             *
             * Thus when the client sees a 401 response, it redirects the xframe to the OAuth URI
             * and the xframe object takes into account that there could be pending requests
             * with the old access token sent to UCWA before the 401 response. To handle this case
             * the xframe object creates a new iframe for new requests and keeps the old iframe
             * until all pending requests complete.
             *
             * @param {XFrame} xframe
             * @param {String} client_id - The OAuth2 client id given to the web app.
             * @param {String} [oauth_uri] - Overrides URL of the OAuth2 token service.
             *
             *      This is useful when the server doesn't return the OAuth URL correctly.
             *      Typical OAuth URLs are:
             *
             *          https://login.microsoftonline.com/common/oauth2/authorize
             *          https://login.windows.net/common/oauth2/authorize
             *
             *      Note, that this URL overrides any OAuth URI given in the WWW-Authenticate header.
             *
             * @param {String} [state] - The state parameter. Used by unit tests.
             * @param {String} [context] - It's a GUID set by unit tests. Used in a POST to /WebTicketService.svc/...
             *
             */
            function Implicit(xframe, client_id, oauth_uri, state, context) {
                // targets["login.windows.net/.../?...&redirect_uri=lync.com/xframe"] = "lync.com/xframe"
                var ready, targets = {}, ticket, nonce, attempt = 1;
                // the nonce value which is known to the xframe and to the client:
                // the client attaches it to every request and the xframe verifies it;
                // the point was to add extra protection against malicious scripts
                // that managed to get into the page, however this measure is questionable
                // since such a malicious script can create its own iframe with its own nonce
                state = state || random();
                function isAuthRequired(rsp) {
                    // sometimes the server doesn't send a 401 with the WWW-Authenticate header,
                    // but sends some random errors with the X-MS-Diagnostics header with a certain code:
                    // if this happens, the client can send a GET to /ucwa/oauth to get a proper 401 response
                    var headers, xmsdiag, code;
                    // the impicit auth implementation needs to handle web ticket related error codes
                    // because it always exchanges the OAuth token for a web ticket to reduce load on the server
                    if (rsp.status == 401)
                        return true;
                    if (rsp.status == 500) {
                        headers = HttpHeaders(rsp.headers);
                        xmsdiag = XMsDiagnostics(headers.get(sMSD));
                        code = xmsdiag.code;
                        // X-MS-Diagnostics: 28032;source="contoso.com";reason="The web ticket is invalid."
                        // X-MS-diagnostics: 28033;source="contoso.com";reason="The web ticket has expired."
                        // X-MS-Diagnostics: 28072;source="contoso.com";reason="The ticket presented could not be verified, a new ticket is required."
                        return code == 28032 || code == 28033 || code == 28072;
                    }
                    return false;
                }
                function getOAuthURI(rsp) {
                    // Currently the OAuth URI is given by the server in a WWW-Authenticate header.
                    // There is, however, a more general way of discovering this URI, known as OAuth URI discovery.
                    // At the moment this mechanism isn't implemented on the server.
                    var headers = HttpHeaders(rsp.headers);
                    var bearer = W3A(headers.get(sW3A))['Bearer'];
                    return bearer && bearer.authorization_uri;
                }
                return function (req, send) {
                    function setAuthAndSend(req) {
                        // nonce is needed to use the token in the iframe
                        if (nonce)
                            req.nonce = nonce;
                        // if web ticket is available, it can be used directly
                        if (ticket) {
                            req.headers = req.headers || {};
                            req.headers['Authorization'] = ticket;
                        }
                        return send(req);
                    }
                    // if the iframe is getting a new access token, wait for it
                    return Task.wait(ready).then(function () {
                        return setAuthAndSend(req);
                    }).then(function (rsp) {
                        var wtsvc, src;
                        if (!isAuthRequired(rsp))
                            return rsp;
                        ticket = null;
                        src = xframe.src();
                        // xframe.src serves as a URL of the resource which the client needs to get an access token for.
                        // However after receiving the first access token from AAD, xframe.src points to a URL on AAD and
                        // thus the next time the client might mistakenly assume that it needs an access token for AAD itself.
                        // The client needs to know that the URL on AAD indirectly refers to UCWA and to solve this problem
                        // the client has a mapping from xframe.src values to actual URLs of UCWA.                    
                        if (targets[src])
                            src = targets[src];
                        // to get the access token, the client needs to discover first the OAuth URI
                        // and the primary source of this URI is the web ticket service's mex config
                        wtsvc = WebTicketService(URI(src).path('').query('').hash(''), setAuthAndSend, context);
                        // 1. The URI given by UI takes precedence over any URI found elsewhere.
                        // 2. If authorization_uri can be found in the 401 response, get it from there.
                        // 3. Otherwise get the OAuth URI from the mex config.
                        ready = Task.wait(oauth_uri || getOAuthURI(rsp) || wtsvc.getOAuthUrl()).catch(function () {
                            // if the URI couldn't be found in mex, use an
                            // alternate route: the WWW-Authenticate header
                            return setAuthAndSend({
                                type: 'GET',
                                url: '/ucwa/oauth'
                            }).then(function (rsp) {
                                return getOAuthURI(rsp);
                            });
                        }).then(function (url) {
                            var uri, query;
                            if (!url)
                                throw Exception('OAuthUriMissing', { response: rsp });
                            uri = URI(url);
                            query = URI.Query(uri.query());
                            // to get a new token, the iframe needs to be redirected to a special URL;
                            // this URL is better to be unique every time, as otherwise the xframe may do nothing
                            nonce = state + '.' + attempt++;
                            query.response_type = 'token';
                            query.client_id = client_id;
                            query.redirect_uri = src;
                            query.resource = URI(src).path('').query('').hash('') + '';
                            query.state = nonce;
                            // TODO: The prompt=none parameter is supposed to replace the "X-Frame-Options: Deny" header with
                            // a meaningful error message. However due to a bug in the common AAD endpoint this parameter breaks
                            // the auth flow. The workaround is to use the tenant-specific endpoint, i.e. to replace /common/ with,
                            // let's say, /microsoft.com/ in the AAD URL. This workaround isn't used in the current implementation.                    
                            uri.query(query + '');
                            targets[uri] = src;
                            // after xframe.src.set is done, an OAuth token will be in the iframe
                            return xframe.src.set(uri + '').then(function () {
                                // to reduce load on the server, the token can be exchanged for a web ticket;
                                // if something goes wrong during the exchange, the client should use the token
                                return wtsvc.getOAuthPath().then(function (path) {
                                    // the iframe checks the nonce of every request
                                    return wtsvc.getWebTicket(path);
                                }).then(function (cwt) {
                                    ticket = cwt;
                                }, function (err) {
                                    // since the error is discarded, this is the only way to tell that the cwt request failed
                                    debug.log(err);
                                    ticket = null;
                                });
                            });
                        });
                        // wait for an access token from AAD and resend the request:
                        // if it fails again, let the caller get the error response,
                        // as getting a yet another access token won't help
                        return Task.wait(ready).then(function () {
                            return setAuthAndSend(req);
                        });
                    });
                };
            }
            Auth.Implicit = Implicit;
            //#endregion
            //#region Anonymous (MsRtcOAuth grant_type=urn:microsoft.rtc:anonmeeting)
            /**
             * This kind of authentication is used to join an online meeting anonymously.
             * The client must know the URI of the meeting to sign in.
             *
             * @param {String} uri - The online meeting URI.
             * @param {String} [key] - The online meeting key.
             *
             */
            function Anonymous(uri, key) {
                // this is how an online meeting uri looks like:
                // sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:QHJ72TKK
                return MsRtcOAuth({
                    grant_type: 'urn:microsoft.rtc:anonmeeting',
                    ms_rtc_conferenceuri: uri,
                    password: key || uri.match(/:(\w+)$/)[1]
                });
            }
            Auth.Anonymous = Anonymous;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=auth.js.map

/// <reference path="./auth.ts" />
/**
 * The UCWA stack layer of SkypeWeb.
 *
 * This is the transport layer or the stack that lays between the UCWA server
 * and the model layer. The stack sends HTTP requests with
 * JSON payload to the UCWA server, processes responses with JSON
 * payload and provides the responses in a object-oriented way.
 *
 * The stack consists of four levels:
 *
 *      XFrame - the lowest level
 *
 *          Abstracts the functionality of the <iframe> HTML element.
 *          XFrame can send an HTTP request to the underlying <iframe>
 *          and receive a response from it. If this XFrame is replaced
 *          with a different XFrame that has the same interface but a different
 *          implementation (e.g. based on the Node's "http" or "https" module)
 *          then the whole stack will be able to run outside the browser.
 *
 *      Transport - built on top of XFrame
 *
 *          Adds resiliency on top of XFrame. Because the <iframe> given
 *          by the server cannot be considered as a reliable way to deliver
 *          messages, Transport takes care of of misbehaving iframes. It also
 *          contains the logic of matching responses with requests.
 *
 *          Transport maintains an xframe queue that queues requests until
 *          the underlying xframe becomes ready to redirect requests to the server.
 *          Almost at all times this queue is empty, because the xframe is ready.
 *
 *          Transport maintains a throttling queue to make sure that at all times
 *          no more than a given number of requests (usually it's 5 or 6) are
 *          pending. This queue is necessary because browsers do not allow
 *          web apps to send have too many pending requests. This queue is normally
 *          empty because the client sends almost all requests in batches. This
 *          queue is aware of that every request may have a priority and
 *          enqueues requests according to their priority.
 *
 *      Endpoint - built on top of Transport
 *
 *          Adds on top of Transport the ability to seamlessly bypass
 *          authentication. If the server responds with an "HTTP 401 Unauthorized"
 *          response, Endpoint obtains the auth token and sends the same
 *          request again with the token. Thus layers above the endpoint
 *          do not need to care about authentication.
 *
 *      Application - built on top of Endpoint
 *
 *          While lower layers of the stack send requests to raw URLs, Application
 *          sends requests to UCWA resources and saves responses to the resource
 *          repository (the cache).
 *
 *          Application has a persistent connection with the server over which it
 *          receives events from it. For example an IM invitation arrives from this
 *          channel.
 *
 *          Application maintains a batching queue that is used to merge requests
 *          of similar priority in chunks and send them as batch requests. The batching
 *          queue is aware of that every request may have a priority and can be
 *          non batchable. For example a request to send an IM has a very high
 *          priority; a request to download a photo is non batchable.
 *
 * In addition to the stack itself, there are a few supplementary  objects:
 *
 *      Repository
 *
 *          Contains all UCWA resources known to the stack. Repository enables
 *          resource lookup by its type (rel), URL (href) or by some other properties.
 *
 *      Connection
 *
 *          Is the persistent event channel connecting the client with the UCWA server
 *          during the lifetime of the JS application. Under the hood it sends
 *          HTTP GET requests to the event channel URL provided by the server,
 *          parses responses and returns responses as events. The caller of Connection
 *          attaches a handler to Connection to receive events. The pending GET requests
 *          to get events are sent with the highest priority, which is +Infinity.
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            
            var global = window.ttt ? window.ttt.window : window;
            var Date = global.Date;
            var Settings = Skype.Web.Settings;
            var ver = Skype.Web.version;
            //#region Imports (from Skype.Web.Utils)
            var Utils = Skype.Web.Utils;
            var URI = Utils.URI;
            var isObject = Utils.isObject;
            var isArray = Utils.isArray;
            var isString = Utils.isString;
            var isNotEmptyString = Utils.isNotEmptyString;
            var isVoid = Utils.isVoid;
            var isFunction = Utils.isFunction;
            var isArrayOf = Utils.isArrayOf;
            var isAjaxRequest = Utils.isAjaxRequest;
            var isAjaxResponse = Utils.isAjaxResponse;
            var isDictionary = Utils.isDictionary;
            var extend = Utils.extend;
            var map = Utils.map;
            var indexOf = Utils.indexOf;
            var bind = Utils.bind;
            var Task = Utils.Task;
            var debug = Utils.debug;
            var async = Utils.async;
            var inherit = Utils.inherit;
            var all = Utils.all;
            var Event = Utils.Event;
            var guid = Utils.guid;
            var assert = Utils.assert;
            var foreach = Utils.foreach;
            var filter = Utils.filter;
            var values = Utils.values;
            var keys = Utils.keys;
            var throttle = Utils.throttle;
            var debounced = Utils.debounced;
            var batched = Utils.batched;
            var clone = Utils.clone;
            var sleep = Utils.sleep;
            var repeat = Utils.repeat;
            var check = Utils.check;
            var Exception = Utils.Exception;
            var Property = Utils.Property;
            var ConstProperty = Utils.ConstProperty;
            var BoolProperty = Utils.BoolProperty;
            var Collection = Utils.Collection;
            var isEmptyObject = Utils.isEmptyObject;
            var HttpHeaders = Utils.HttpHeaders;
            var HttpStatus = Utils.HttpStatus;
            var ContentTypeHeader = Utils.ContentTypeHeader;
            var getOption = Utils.getOption;
            var random = Utils.random;
            var repeatAndExit = Utils.repeatAndExit;
            Utils = null;
            //#endregion
            //#region Imports (from Skype.Web.Auth)
            var Auth = Skype.Web.Auth;
            var BasicAuth = Auth.Basic;
            var AnonMeetingAuth = Auth.Anonymous;
            var IntegratedAuth = Auth.Integrated;
            var ImplicitAuth = Auth.Implicit;
            var PassiveAuth = Auth.Passive;
            Auth = null;
            //#endregion
            //#region Common Exceptions
            function ELinkMissing(resource, rel) {
                var text = resource.rel + '/' + rel + ' link does not exist';
                return Exception.call(text, 'LinkMissing', { resource: resource, rel: rel });
            }
            function ESingleLinkExpected(resource, rel) {
                var text = 'one ' + resource.rel + '/' + rel + ' link expected, ' + resource.links(rel).length + ' found';
                return Exception.call(text, 'SingleLinkExpected', { resource: resource, rel: rel });
            }
            function EAttrMissing(resource, name) {
                var text = resource.rel + '.' + name + ' property does not exist';
                return Exception.call(text, 'AttrMissing', { resource: resource, name: name });
            }
            function EDiscoveryFailed(domain, reason) {
                var text = 'UCWA not found on ' + domain;
                return Exception.call(text, 'DiscoveryFailed', { reason: reason, domain: domain });
            }
            function ERequestFailed(req, rsp) {
                var text = req.type + ' ' + req.url + ' failed: ' + (rsp.statusText || rsp.status);
                return Exception.call(text, 'RequestFailed', { req: req, rsp: rsp });
            }
            function EMixedContent(url) {
                var text = 'Insecure resource at ' + url + ' cannot be loaded.';
                return Exception.call(text, 'MixedContent', { url: url });
            }
            //#endregion
            var Internal;
            (function (Internal) {
                /**
                 * Resource is what UCWA server normally returns.
                 *
                 * The Resource concept was introduced by "Hypertext Application Language"
                 * or "HAL" specification draft in
                 *
                 *      http://tools.ietf.org/html/draft-kelly-json-hal-05
                 *
                 * A resource has four aspects:
                 *
                 *      - it has a unique id (its "_links.self.href" attribute)
                 *      - it has a type (its "rel" attribute)
                 *      - it contains named properties (key-value pairs)
                 *      - it points to other related resources
                 *
                 * It's noteworthy, that the related resources to which a resource
                 * points, do not belong to the resource and are not embedded into
                 * it - they are just somehow related. For example the "people" resource
                 * is related to the "me" resource, a "contact" resource is related to
                 * the "people" resource and at the same time the "me" resource
                 * is related to the "contact" resource: the resource relations may
                 * form loops with one or many nodes. In the implementation this
                 * means that given a link to some related resource, this resource
                 * can be loaded from the server and the loaded resource will have
                 * links to other related resources, that can be also loaded and so on.
                 *
                 * @constructor Resource(raw) - Creates a resource based on its raw JSON representation.
                 * @constructor Resource(href, rel, revision) - Creates a resource with the given rel and href.
                 * @constructor Resource() - Creates an empty resource.
                 *
                 * @member {string} href - The URL (or the unique id) of the resource.
                 * @member {string} rel - The type of the resource.
                 * @member {String} revision - Same as .link("self").revision.
                 * @member {string} properties[name] - The value of the given named property.
                 * @member {string} related[rel][5].href - The href of the 5-th related resource with the given rel.
                 * @member {Resource} embedded[href] - The related embedded resource.
                 *
                 * @event deleted - Occurs after the resource gets deleted from the repository.
                 * @event updated - Occurs after the resource gets updated.
                 *
                 * @property dirty - Whether the cached state of the resource is obsolete.
                 *
                 * @collection {Resource} memberships - All resources where this resource belongs to.
                 *
                 *      For instance a rel=participant may belong to rel=typingParticipants or
                 *      rel=contact may belong to rel=subscribedContacts.
                 *
                 *      The collection is indexed by hrefs.
                 *
                 * @method remove - Marks the resource as removed.
                 * @method updateFrom(resource) - Updates the content of the resource from another resource.
                 * @method {string} relatedHref(rel) - the URL of a linked resource
                 * @method set(name, value) - Changes a property value.
                 * @method get(name, defaultValue) - Returns a property value.
                 * @method get() - Returns a copy of all properties as a dictionary.
                 * @method has(name) - Checks whether the resource has a property.
                 * @method link(rel) - Returns a single link with the given rel or throws an exception.
                 * @method {Boolean} hasLink(rel) - Checks whether the resource has a link with the given rel.
                 * @method {Resource} removeLink(rel, href) - Removes the given link.
                 * @method {Resource} addLink(rel, href) - Adds a link to the given resource.
                 *
                 *      res.addLink("mediaOffer", "data:application/sdp;charset=utf-8,v=0\r\n...");
                 *      res.relatedHref("mediaOffer") == "data:application/sdp;charset=utf-8,v=0\r\n...";
                 *
                 * @method {Object} getSnapshot - Returns a snapshot of the resource.
                 *
                 *  The snapshot doesn't include embedded resources.
                 *  The snapshot is usable as the argument to the Resource's constructor:
                 *
                 *      var r1 = Resource(...);
                 *      var r2 = Resource(r1.getSnapshot());
                 *
                 * @method {String} toString - Returns a string representation of the resource.
                 *
                 *  This method returns a serialized snapshot of the resource at the moment is was created.
                 *  This method is used for debugging only and has nothing to do with the getSnapshot method.
                 *
                 */
                function Resource(raw) {
                    var self = { toString: toString };
                    var dirty = BoolProperty(false);
                    var isRemoved = false;
                    var rel, href, revision;
                    var related = {};
                    var embedded = {};
                    var properties = {};
                    var memberships = Collection(); // resource objects
                    var updated = Event({
                        added: function (listener) {
                            listener();
                        }
                    });
                    var deleted = Event({
                        added: function (listener) {
                            if (isRemoved)
                                listener();
                        }
                    });
                    //#region initialization
                    // Resource(href, rel) creates an empty resource with a given href and rel
                    if (arguments.length > 1) {
                        raw = {
                            rel: arguments[1],
                            _links: {
                                self: { href: arguments[0] }
                            }
                        };
                        // the default value is revision=1, so if it's 1, it can be omitted
                        if (arguments[2] > 1) {
                            revision = arguments[2];
                            raw._links.self.revision = revision;
                        }
                    }
                    init();
                    // the server does not always provide the "rel" attribute
                    rel = raw.rel || null;
                    //#endregion
                    //#region internal methods
                    function init() {
                        var links, resources, r, i, rel;
                        // the "href" attribute is mandatory, because this is the
                        // unique id of the resource
                        try {
                            href = raw._links.self.href;
                        }
                        catch (err) {
                            throw ELinkMissing(raw, 'self');
                        }
                        // extract related resources from _links in which
                        // _links[rel] is a link or an array of links to
                        // related resources
                        for (rel in raw._links) {
                            links = raw._links[rel];
                            if (!isArray(links))
                                links = [links];
                            related[rel] = links;
                        }
                        // extract related resources from _embedded in which
                        // _embedded[rel] is a resource or an array of related
                        // resources
                        if (raw._embedded) {
                            for (rel in raw._embedded) {
                                resources = raw._embedded[rel];
                                if (!isArray(resources))
                                    resources = [resources];
                                for (i = 0; i < resources.length; i++) {
                                    r = Resource(resources[i]);
                                    // even if there is no property raw._embedded[rel].rel,
                                    // we know the type of the embedded resource
                                    r.rel = r.rel || rel;
                                    // Embedded mediaRelay resources of communication/mediaRelayAccessToken resource 
                                    // have the same href as the parent resource, so we fake the unique href:
                                    if (r.rel == 'mediaRelay' && r.href == href)
                                        r.href += '/' + r.properties.host + '/' + r.properties.location;
                                    embedded[r.href] = r;
                                    if (!related[rel])
                                        related[rel] = [];
                                    // the href entry may have already been added to related[rel] from raw._links
                                    if (!hasLink(rel, r.href))
                                        related[rel].push({ href: r.href });
                                }
                            }
                        }
                        // copy properties of the resource from its
                        // raw representation
                        for (i in raw)
                            properties[i] = raw[i];
                        // "rel" is the type name;
                        // "_links" and "_embedded" are not properties and
                        // just point to other related resources
                        delete properties.rel;
                        delete properties._links;
                        delete properties._embedded;
                    }
                    //#endregion
                    //#region public methods
                    //#region remove
                    function remove() {
                        if (!isRemoved) {
                            isRemoved = true;
                            deleted.fire();
                        }
                    }
                    //#endregion
                    //#region updateFrom
                    /**
                     * The server may return many incomplete representations of the same resource.
                     * The client must collect all properties from all representations of the same
                     * resource and put them into one resource object.
                     *
                     * This method takes another representation of the same resource and reads from it
                     * properties that this resource object is missing or have outdated.
                     *
                     * @param {Resource} source
                     */
                    function updateFrom(source) {
                        assert(self.href == source.href);
                        // override all properties and links of this resource
                        // with properties and links of the given resource
                        self.related = related = clone(source.related);
                        self.properties = properties = clone(source.properties);
                        embedded = {};
                        foreach(source.embedded, function (val, key) {
                            embedded[key] = Resource(val.getSnapshot());
                        });
                        self.embedded = embedded;
                        dirty(false);
                        updated.fire();
                    }
                    //#endregion
                    //#region relatedHref
                    /**
                     * Returns the URL of a linked resource
                     *
                     * @param {string} rel - linked resource name
                     * @returns {string} - the URL of a linked resource if found, undefined otherwise
                     *
                     * @example
                     *      if resource has following links
                     *          "_links": { "photo": { "href": "/ucwa/photo" } }
                     *          then relatedHref('photo') == '/ucwa/photo';
                     */
                    function relatedHref(rel) {
                        var link = related[rel];
                        if (link)
                            return link[0].href;
                    }
                    //#endregion
                    //#region getSnapshot
                    function getSnapshot() {
                        var i, links, snapshot = { rel: rel };
                        for (i in properties)
                            snapshot[i] = properties[i];
                        snapshot._links = {
                            self: { href: href }
                        };
                        for (i in related) {
                            links = related[i];
                            if (links.length > 0)
                                snapshot._links[i] = links.length > 1 ? links : links[0];
                        }
                        return snapshot;
                    }
                    //#endregion
                    //#region toString
                    function toString(indent) {
                        var snapshot = getSnapshot();
                        if (!isEmptyObject(embedded))
                            snapshot._embedded = {};
                        // reconstruct _embedded: if the original resource was 
                        //   { rel: 'contact', 
                        //     _links: {'self': {href: '\contacts\john'}, 
                        //     _embedded: {'contactGroup': {rel: 'group', _links: {self: '\groups\friends'}} } }
                        // its internal representation in Resource is
                        //   related = { 'self': {href: '\contacts\john'},
                        //               'contactGroup' : {href: '\groups\friends'} };
                        //   embedded = {'\groups\friends': Resource({rel: 'group', _links: {self: '\groups\friends'}})}; 
                        //
                        foreach(snapshot._links, function (lnkVal, lnkKey) {
                            var v = values(filter(embedded, function (embVal, embKey) {
                                return embKey == lnkVal.href;
                            }));
                            if (v.length > 0) {
                                assert(v.length == 1);
                                snapshot._embedded[lnkKey] = v[0].getSnapshot();
                                delete snapshot._links[lnkKey];
                            }
                        });
                        return JSON.stringify(snapshot, null, indent);
                    }
                    //#endregion
                    //#region forEachLink
                    /**
                     * Invokes a given callback for every link in the resource
                     * and all embedded resources. Every link has at least the "href"
                     * property.
                     *
                     * @param {Function} callback
                     */
                    function forEachLink(callback) {
                        foreach(related, function (links, rel) {
                            foreach(links, function (link) {
                                if (!embedded[link.href])
                                    callback(link, rel);
                            });
                        });
                        foreach(embedded, function (resource) {
                            resource.forEachLink(callback);
                        });
                    }
                    //#endregion
                    //#region addLink
                    function addLink(rel, href) {
                        if (!hasLink(rel, href)) {
                            if (!related[rel])
                                related[rel] = [];
                            related[rel].push({ href: href });
                            updated.fire();
                        }
                        return self;
                    }
                    //#endregion
                    //#region removeLink
                    function removeLink(rel, href) {
                        var i, links = related[rel];
                        if (links) {
                            for (i = 0; i < links.length; i++) {
                                if (links[i].href == href) {
                                    links.splice(i, 1);
                                    updated.fire();
                                    break;
                                }
                            }
                        }
                        return self;
                    }
                    //#endregion
                    //#region link
                    function link(rel) {
                        var links = related[rel];
                        if (!links || links.length == 0)
                            throw ELinkMissing(self, rel);
                        if (links.length > 1)
                            throw ESingleLinkExpected(self, rel);
                        return links[0];
                    }
                    //#endregion
                    //#region links
                    function links(rel) {
                        return related[rel] || [];
                    }
                    //#endregion
                    //#region hasLink
                    function hasLink(rel, href) {
                        var i, links = related[rel] || [];
                        if (!href)
                            return links.length > 0;
                        for (i = 0; i < links.length; i++)
                            if (links[i].href == href)
                                return true;
                        return false;
                    }
                    //#endregion
                    //#region set
                    function set(name, value) {
                        properties[name] = value;
                        updated.fire();
                        return self;
                    }
                    //#endregion
                    //#region get
                    function get(name, defaultValue) {
                        if (!name)
                            return clone(properties);
                        if (name in properties)
                            return properties[name];
                        if (arguments.length == 1)
                            throw EAttrMissing(self, name);
                        return defaultValue;
                    }
                    //#endregion
                    //#region has
                    function has(name) {
                        return name in properties;
                    }
                    //#endregion
                    //#endregion public methods
                    // TODO: The interface of this class desperately needs refactoring.
                    // In fact, Resource needs two interfaces: one with RW access for
                    // internal use in the stack layer and one RO for external use
                    // in the model layer. Currently both the stack and the model layer
                    // have RW access to every resource object.
                    return extend(self, {
                        href: href,
                        rel: rel,
                        revision: revision,
                        memberships: memberships,
                        properties: properties,
                        related: related,
                        embedded: embedded,
                        remove: remove,
                        updateFrom: updateFrom,
                        relatedHref: relatedHref,
                        updated: updated.observer,
                        deleted: deleted.observer,
                        forEachLink: forEachLink,
                        getSnapshot: getSnapshot,
                        dirty: dirty,
                        addLink: addLink,
                        removeLink: removeLink,
                        hasLink: hasLink,
                        link: link,
                        links: links,
                        has: has,
                        set: set,
                        get: get
                    });
                }
                Internal.Resource = Resource;
                //#endregion Resource
                //#region Repository
                /**
                 * Repository keeps all resources available to the transport layer.
                 * It provides functionality to search for existing resources.
                 *
                 * In UCWA terms, Repository acts as the Cache.
                 *
                 * @param [snapshot] - The initial state of the repository.
                 * @param [connection] - The source of UCWA events.
                 *
                 *  This is what Repository::getSnapshot returns.
                 *
                 * @method put(resource) - Adds or updates a resource in the repository.
                 * @method remove(href) - Removes a resource from the repository.
                 * @method {Resource[]} get(selector) - Finds all resources matching the selector.
                 *
                 *     - get({ rel: 'me' }) - finds all resources with rel="me"
                 *     - get('/me/car') - finds all resources with href="/me/car"
                 *
                 * @method getSnapshot - Returns a snapshot of the repository.
                 *
                 *  The snapshot is a mapping from resource rel to array of resource snapshots
                 *  with the given rel. This is how a snapshot can be used:
                 *
                 *      var snapshot = repository.getSnapshot();
                 *      var resource = Resource(snapshot.contact[0]);
                 *
                 */
                function Repository(options) {
                    // Every resource has a unique "href" value that is written in "r._links.self.href"
                    // if "r" refers to a resource returned by the server, then resources[href] is
                    // a Resource object which id is "href"
                    var resources = {};
                    // cache[rel] is an array of href values of all resources with the given "rel" attribute.
                    var cache = {};
                    //#region initialization
                    if (options) {
                        if (options.connection) {
                            options.connection.event(processEvent);
                            // Remove all resources from repository when disconnected
                            // from UCWA server to reset all properties.
                            options.connection.connected.when(false, function () {
                                foreach(resources, function (r) {
                                    // TODO: if statement must be removed when comprehensive fix is done for all properties. 
                                    // Its there to prevent breaking two unit tests.
                                    if (r.rel == 'me')
                                        remove(r.href);
                                });
                            });
                        }
                        if (options.snapshot) {
                            foreach(options.snapshot, function (rs, rel) {
                                foreach(rs, function (r) {
                                    r = clone(r);
                                    r.rel = rel;
                                    put(Resource(r));
                                });
                            });
                        }
                    }
                    //#endregion
                    //#region private methods
                    /**
                     * Handles a UCWA event and updates resource objects in the repository.
                     * This method must be the very first handler among all handlers of UCWA
                     * events because it may need to modify the original event object to make
                     * it refer to resource objects in the repository.
                     */
                    function processEvent(event) {
                        var type = event.type;
                        var sender = event.sender;
                        var target = event.target;
                        var context = event['in'];
                        // the resource object is added to the repository even for
                        // "deleted" and "completed" events because event handlers
                        // may reasonably expect the resource from the event to be
                        // present in the repository
                        put(Resource(sender.href, sender.rel), true);
                        if (event.resource) {
                            put(event.resource);
                            // an event handler may save a reference to event.resource
                            // and later check its state, so we want to replace event.resource
                            // with a reference to the resource in the repository, which
                            // may be updated later by UCWA events
                            event.resource = resources[event.resource.href];
                        }
                        else {
                            put(Resource(target.href, target.rel), true);
                            // an empty "updated" event indicates that the state of the target resource
                            // has changed, but UCWA isn't sending its new state in the event: to get
                            // that state the client needs to send a GET request; so the resource object
                            // is only marked as obsolete and the stack leaves it up to the model layer
                            // to decide whether it's worth sending the GET
                            if (type == 'updated')
                                resources[target.href].dirty(true);
                        }
                        if (context) {
                            put(Resource(context.href, context.rel), true);
                            if (type == 'added') {
                                resources[context.href].addLink(target.rel, target.href);
                                if (!resources[target.href].memberships(context.href))
                                    resources[target.href].memberships.add(resources[context.href], context.href);
                            }
                            if (type == 'deleted') {
                                resources[context.href].removeLink(target.rel, target.href);
                                if (resources[target.href].memberships(context.href))
                                    resources[target.href].memberships.remove(context.href);
                            }
                        }
                        if (type == 'deleted' || type == 'completed') {
                            // if the event target is a member of a collection then we should not delete it from
                            // the repository because the target may exist outside the collection; for instance
                            // when someone stops typing in a conversation, the server sends a "participant
                            // deleted in typingParticipants" event.
                            if (!context)
                                remove(target.href);
                        }
                    }
                    //#endregion
                    //#region public methods
                    /**
                     * Adds a new resource to the repository or updates an existing resource
                     * in the repository.
                     *
                     * Since the resource may point to related resources, the procedure of adding
                     * a resource into the repository is recursive.
                     *
                     * @param {Resource} r
                     * @param {Boolean} isLink - Whether `r` was created from an empty link.
                     *
                     *      TODO: consider moving this parameter out of `put` and moving it
                     *      into the parameters list of the Resource's ctor.
                     */
                    function put(r, isLink) {
                        if (isLink === void 0) { isLink = false; }
                        if (!r.links)
                            r = Resource(r);
                        if (!r.rel || !r.href)
                            return;
                        var href, rel, link, i, c;
                        var isNew = !resources[r.href];
                        if (isNew) {
                            r.isLink = isLink;
                            resources[r.href] = r;
                            // if the only thing we know about a resource is its href,
                            // then the cached state of this resource is obviously invalid
                            if (isLink)
                                r.dirty(true);
                            if (!cache[r.rel])
                                cache[r.rel] = [];
                            cache[r.rel].push(r.href);
                        }
                        // put into the repository the minimum info ("rel" and "href"
                        // attributes) of those resources known to the given resource
                        for (rel in r.related) {
                            for (i = 0; i < r.related[rel].length; i++) {
                                link = r.related[rel][i];
                                href = link.href;
                                // we know nothing about a related resource except
                                // its "rel" and "href" attributes, so create a resource
                                // with these attributes and put it into the repository
                                //
                                // however, if the same resource is embedded, do not add
                                // it here, because this will fire the "added" event now and
                                // the "updated" event later, when the same resource gets updated
                                // from the embedded resource; this is not harmful, but the
                                // unnecessary "updated" event can be easily avoided in this case
                                if (!resources[href] && !r.embedded[href])
                                    put(Resource(href, rel, link.revision), true);
                            }
                        }
                        // the resource also has embedded resources about which it knows
                        // more than just their "href" and "rel" attributes - put them
                        // into the repository as well
                        for (href in r.embedded)
                            put(r.embedded[href]);
                        // copy new properties of the resource into the repository
                        if (!isNew && !isLink) {
                            resources[r.href].updateFrom(r);
                            // UCWA may send a resource with one rel as a link of another resource
                            // and later send the same resource with a different rel. For instance
                            // when a rel=messagingInvitation arrives it has a rel=from link which
                            // in fact points to a rel=participant resource.
                            if (resources[r.href].isLink && resources[r.href].rel != r.rel) {
                                c = cache[resources[r.href].rel];
                                assert(c); // if this failed, `cache` and `resources` are unsynced
                                c.splice(indexOf(c, r.href), 1); // c.remove(r.href)
                                if (c.length == 0)
                                    delete cache[resources[r.href].rel];
                                if (!cache[r.rel])
                                    cache[r.rel] = [];
                                cache[r.rel].push(r.href);
                                resources[r.href].rel = r.rel;
                            }
                        }
                    }
                    /**
                     * Removes a resource from the repository.
                     *
                     * @param {string} href - The href of the resource.
                     */
                    function remove(href) {
                        assert(isNotEmptyString(href));
                        var c, r = resources[href];
                        if (r) {
                            c = cache[r.rel];
                            // remove href from cache[r.rel]
                            c.splice(indexOf(c, href), 1);
                            // remove r from resources
                            delete resources[href];
                            // mark the resource as removed
                            r.remove();
                        }
                    }
                    /**
                     * Finds all resources that match the given selector:
                     * The selector can be:
                     *
                     *      - the "rel" attribute
                     *      - the "href" attribute
                     *
                     * @param {string} selector - The selector.
                     * @returns {Resource[]} - The array of found resources, which can be empty.
                     *
                     * @remark
                     *
                     * In future, this method will be able to find resources that match
                     * some selector in jQuery style:
                     *
                     *      find('me > makeMeAvailable');
                     */
                    function get(selector) {
                        assert(isNotEmptyString(selector));
                        if (resources[selector])
                            return [resources[selector]];
                        if (cache[selector]) {
                            var hrefs = cache[selector];
                            var results = [];
                            for (var i = 0; i < hrefs.length; i++)
                                results.push(resources[hrefs[i]]);
                            return results;
                        }
                        return [];
                    }
                    /**
                     * Finds all resources that satisfies the given predicate
                     *
                     * @param {Resource => bool} predicate
                     * @returns {Resource[]} - The array of found resources, which can be empty.
                     */
                    function find(predicate) {
                        return values(filter(resources, predicate));
                    }
                    function getSnapshot() {
                        return map(cache, function (hrefs) {
                            return map(hrefs, function (href) {
                                var rs = resources[href].getSnapshot();
                                delete rs.rel; // no need to store "rel" as it can be inferred from the snapshot
                                return rs;
                            });
                        });
                    }
                    function toString(indent) {
                        return JSON.stringify(getSnapshot(), null, indent);
                    }
                    //#endregion
                    return {
                        put: put,
                        get: get,
                        find: find,
                        remove: remove,
                        getSnapshot: getSnapshot,
                        toString: toString
                    };
                }
                Internal.Repository = Repository;
                var Repository;
                (function (Repository) {
                    function expandSnapshot(snapshot) {
                        snapshot = clone(snapshot);
                        foreach(snapshot, function (resources, rel) {
                            if (!isArray(resources))
                                snapshot[rel] = resources = [resources];
                            foreach(resources, function (r, i) {
                                if (isString(r))
                                    resources[i] = r = { _links: { self: { href: r } } };
                            });
                        });
                        return snapshot;
                    }
                    Repository.expandSnapshot = expandSnapshot;
                })(Repository = Internal.Repository || (Internal.Repository = {}));
                //#endregion
                //#region ResourceEvent
                /**
                 * Represents an event received from UCWA.
                 */
                function ResourceEvent(options) {
                    return inherit(ResourceEvent.prototype, options);
                }
                Internal.ResourceEvent = ResourceEvent;
                extend(ResourceEvent.prototype, {
                    /**
                     * This method is used for writing unit tests and debugging only.
                     * When the stack receives an event, it stringifies it and prints
                     * to the browser's console as a plain string. Because this string
                     * is a valid JS expression that constructs an event, it can be
                     * copied into a JS file with unit tests.
                     */
                    toString: function () {
                        var pairs = [];
                        foreach(this, function (value, key) {
                            if (key == 'resource') {
                                if (value)
                                    pairs.push('"resource":' + value);
                            }
                            else if (!isFunction(value))
                                pairs.push('"' + key + '":' + JSON.stringify(value));
                        });
                        return '{' + pairs.reverse().join(',') + '}';
                    }
                });
                //#endregion ResourceEvent
                //#region EventCollection
                /**
                 * The event channel with the server (the one to which the "events" resource points)
                 * sends to the client resources that have the "sender" property. This property contains
                 * a batch of events.
                 *
                 * The EventCollection is essentially a parser for the "sender" property.
                 *
                 * @param {Object[]} senders - The value of the "sender" property from the event resource.
                 * @returns {ResourceEvent[]}
                 *
                 * @example
                 *
                 *      var events = EventCollection(...);
                 *      for (var i = 0; i < events.length; i++)
                 *          if (events[i].type == 'added')
                 *              ...
                 *
                 */
                function EventCollection(senders) {
                    assert(isArray(senders));
                    var sender, targets, i, j, target, resource, rel, e, name, events = [];
                    for (i = 0; i < senders.length; i++) {
                        sender = senders[i];
                        targets = sender.events;
                        for (j = 0; j < targets.length; j++) {
                            target = targets[j];
                            resource = null;
                            if (target._embedded)
                                for (rel in target._embedded) {
                                    assert(!resource, 'Only one resource is expected in _embedded');
                                    check(!resource, 'AlreadyExists', { item: 'embedded resource', resource: target });
                                    resource = Resource(target._embedded[rel]);
                                    // don't rely that the embedded resource
                                    // will have a proper rel attribute
                                    resource.rel = resource.rel || rel;
                                }
                            e = {
                                resource: resource,
                                sender: { rel: sender.rel, href: sender.href },
                                target: target.link
                            };
                            for (name in target)
                                e[name] = target[name];
                            delete e._embedded;
                            delete e.link;
                            events.push(ResourceEvent(e));
                        }
                    }
                    return events;
                }
                Internal.EventCollection = EventCollection;
                //#endregion EventCollection
                //#region Connection
                /**
                 * The Connection is a persistent channel with the server over which it
                 * sends events to the client.
                 *
                 * An event says that something has been changed in a particular resource.
                 * In UCWA there are 2 types of resources that are structurally identical, but
                 * have slightly different semantics and different sets of associated events.
                 *
                 * A regular resource, such as a rel=contact or a rel=participant, has three
                 * associated events:
                 *
                 *      An "added" event says that the resource has been created.
                 *      If the event contains the "in" link, then the resource has been
                 *      added to a collection indicated by that "in" link.
                 *
                 *      An "updated" event says that the resource state has been
                 *      invalidated and the next time the client needs to get any of
                 *      its properties or links the client should first fetch the new resource
                 *      state via a GET. The event may contain the new resource
                 *      state, so that the client wouldn't need to send an extra GET.
                 *
                 *      A "deleted" event says that the resource has been deleted.
                 *      If the event contains the "in" link, then the resource has
                 *      been deleted from a collection indicated by that "in" link
                 *      and can still belong to another collection or live outside
                 *      any collections.
                 *
                 * An operation resource, such as rel=messagingInvitation, tracks the progress
                 * of some asynchronous operation. Operation resources are usually returned
                 * in the Location header of 201 responses to some POST requests and then
                 * UCWA sends three type of events to update state of these resources:
                 *
                 *      A "started" event says that the operation has been started.
                 *      The operation resource usually has the `operationId` property
                 *      defined by the client when it sent a POST request to start the
                 *      operation. The server doesn't necessarily send the "started"
                 *      event: for instance when notifying of incoming messages it sends
                 *      a single "message completed" event.
                 *
                 *      An "updated" event says that the operation state has been
                 *      invalidated. Normally, the "updated" event for operation resources
                 *      contains these resources, so the client doesn't need to send an extra
                 *      GET to learn the new operation state.
                 *
                 *      A "completed" event says that the operation has succeeded or failed.
                 *      After that no other events regarding this operation are sent, so
                 *      the client may delete the resource.
                 *
                 * It's worth mentioning that the described semantics of events is implemented
                 * outside the Connection class: the purpose of Connection is to get events from the
                 * server and redirect them to listeners.
                 *
                 * The Connection is built on top of Endpoint, because it needs to seamlessly
                 * bypass the authentication and get responses from the server in the form of
                 * resources, and it's not built  on top of Application, because it doesn't
                 * need its capability to seamlessly update the repository with arriving
                 * events.
                 *
                 * @param {Endpoint} endpoint
                 *
                 * @method connect(url) - Starts getting events from the given URL.
                 *
                 * @property {Boolean} connected - Tells whether the event channel is connected.
                 *
                 * @event {ResourceEvent} event - Occurs when a new event arrives.
                 * @event {Error} error - Occurs when an arrived event from the server cannot be parsed.
                 *
                 */
                function Connection(endpoint) {
                    var eEvent = Event();
                    var eError = Event();
                    var pConnected = Property();
                    /**
                     * Sends a HTTP GET to the given URL and expects to get
                     * a resource in the form of the "event" resource.
                     *
                     * @param {string} url
                     */
                    function getEvent(url) {
                        endpoint.ajax({
                            type: 'GET',
                            url: url,
                            priority: Infinity
                        }).then(onRequestSucceeded, function (error) {
                            pConnected(false, error);
                        });
                    }
                    /**
                     * Responses from the server come in the form of resources
                     * with a URL from which the next set of events can be obtained.
                     *
                     * @param {Resource} eventBatch - The resource that contains the batch of events.
                     */
                    function onRequestSucceeded(eventBatch) {
                        try {
                            if (eventBatch.related.next)
                                // normally the server provides the "next" link
                                // from which the next event can be received
                                getEvent(eventBatch.related.next[0].href);
                            else if (eventBatch.related.resume)
                                // if the client disconnects and then reconnects to the
                                // server, the latter will provide the "resume" link
                                getEvent(eventBatch.related.resume[0].href);
                            else if (eventBatch.related.resync)
                                // if the client tries to obtain events from an improper
                                // URL, the server will send the "resync" link
                                getEvent(eventBatch.related.resync[0].href);
                            else
                                throw Exception('NextEventLinkMissing', { resource: eventBatch });
                        }
                        catch (error) {
                            pConnected(false, error);
                            return;
                        }
                        pConnected(true);
                        try {
                            notifyListeners(eventBatch.properties.sender);
                        }
                        catch (error) {
                            eError.fire(error);
                        }
                    }
                    function notifyListeners(sender) {
                        var i, hash, exists = {}, events = EventCollection(sender || []);
                        for (i = 0; i < events.length; i++) {
                            hash = events[i] + '';
                            // There was a version of UCWA that duplicated some events
                            // for the first signed in tab in the multitab scenario.
                            // That bug duplicated events in the same event batch.
                            if (!exists[hash]) {
                                exists[hash] = true;
                                eEvent.fire(events[i]);
                            }
                        }
                    }
                    return {
                        connect: getEvent,
                        connected: pConnected.asReadOnly(),
                        error: eError.observer,
                        event: eEvent.observer
                    };
                }
                Internal.Connection = Connection;
                //#endregion Connection
                //#region Batch
                /**
                 * The Batch is responsible for composing a single HTTP batch request
                 * from several separate HTTP requests and for decomposing a HTTP batch
                 * response into separate HTTP responses.
                 *
                 * Batch requests are sent to the "batch" UCWA resource, which is discussed
                 * here: http://ucwa.lync.com/documentation/gettingstarted-batching
                 *
                 * @method compose - Composes a batch request.
                 * @method parse - Parses a batch response.
                 *
                 */
                function Batch(url) {
                    /**
                     * Returns a string with the request body.
                     */
                    function getRequestBody(request) {
                        if (isVoid(request.data) || request.type == 'GET')
                            return '';
                        if (isString(request.data))
                            return request.data;
                        if (isDictionary(request.data))
                            return JSON.stringify(request.data);
                        return request.data + '';
                    }
                    /**
                     * Returns an array with all HTTP headers.
                     */
                    function getRequestHeaders(request) {
                        var headers = HttpHeaders(request.headers);
                        if (request.contentType)
                            headers.add('Content-Type', request.contentType);
                        else if (isDictionary(request.data))
                            headers.add('Content-Type', 'application/json');
                        if (request.dataType == 'json')
                            headers.add('Accept', 'application/json');
                        // the server requires this header to be present,
                        // but does not seem to use it
                        headers.add('Host', 'Host');
                        return headers + '';
                    }
                    /**
                     * Constructs a URL based on the request type, its URL and query.
                     */
                    function getRequestUrl(request) {
                        var query = '';
                        if (request.type == 'GET') {
                            foreach(request.data || {}, function (value, name) {
                                query += (query ? '&' : '?') + name + '=' + value;
                            });
                        }
                        return request.url + query;
                    }
                    /**
                     * Serializes a given ajax (HTTP) request into a string.
                     */
                    function serializeRequest(request) {
                        var headers = getRequestHeaders(request);
                        var body = getRequestBody(request);
                        var url = getRequestUrl(request);
                        return request.type + ' ' + url + ' HTTP/1.1\r\n' + headers + body;
                    }
                    /**
                     * Composes the body of the batch request using the given boundary.
                     */
                    function composeBatchRequestBody(requests, boundary) {
                        var text, lines = [];
                        for (var i = 0; i < requests.length; i++) {
                            text = serializeRequest(requests[i]);
                            lines.push('--' + boundary);
                            lines.push('Content-Type: application/http; msgtype=request');
                            lines.push('');
                            lines.push(text);
                        }
                        return lines.join('\r\n') + '\r\n--' + boundary + '--\r\n';
                    }
                    /**
                     * @param {Request[]} requests
                     * @returns {Number|Void} The max priority or undefined.
                     */
                    function getMaxPriority(requests) {
                        var i, priority;
                        for (i = 0; i < requests.length; i++)
                            if (requests[i].priority > priority || priority === undefined)
                                priority = requests[i].priority;
                        return priority;
                    }
                    /**
                     * Composes one batch request from a set of separate requests.
                     *
                     * @param {array} requests - The array of requests. Each item in this array
                     *      is the argument for the jQuery.ajax function, i.e. it has properties
                     *      "type", "url", "headers" and so on.
                     *
                     * @returns
                     *
                     *      A batch request, which can be sent with jQuery.ajax or any other
                     *      method supporting the same signature, e.g. Transport.ajax.
                     *      The composed request has a properly set priority, that equals the
                     *      highest priority of the requests.
                     */
                    function compose(requests) {
                        assert(isArrayOf(requests, isAjaxRequest));
                        var boundary = guid();
                        var body = composeBatchRequestBody(requests, boundary);
                        var priority = getMaxPriority(requests);
                        return {
                            type: 'POST',
                            priority: priority,
                            url: url,
                            data: body,
                            headers: {},
                            accepts: { '*': 'multipart/batching' },
                            contentType: 'multipart/batching;boundary=' + boundary,
                            dataType: 'text'
                        };
                    }
                    /**
                     * This util function takes a string representing one response in a batch response
                     * and splits it into the four parts: the outer headers, the http status line,
                     * the inner headers, and the response body.
                     *
                     * @param {string} block - A part of the batch response that represents a single HTTP response:
                     *
                     *      Content-Type: application/http; msgtype=response\r\n
                     *      \r\n
                     *      HTTP/1.1 200 OK\r\n
                     *      Cache-Control: no-cache\r\n
                     *      Content-Type: application/json; charset=utf-8\r\n
                     *      \r\n
                     *      {"location":"Office"}\r\n
                     */
                    function split(block) {
                        block = block.substring(2, block.length - 2);
                        var i = block.indexOf('\r\n\r\n');
                        var j = block.indexOf('\r\n', i + 4);
                        var k = block.indexOf('\r\n\r\n', i + 4);
                        assert(i > 0 && j > 0 && k > 0);
                        return {
                            outer: block.substring(0, i),
                            status: block.substring(i + 4, j),
                            inner: block.substring(j + 2, k),
                            body: block.substring(k + 4)
                        };
                    }
                    /**
                     * Parses a batch response. The batch response contains several
                     * separated HTTP responses.
                     *
                     * @param response - The jQuery response.
                     * @returns {array} The array of jQuery responses.
                     */
                    function parse(response) {
                        assert(isAjaxResponse(response));
                        var headers = HttpHeaders(response.headers);
                        var boundary = headers.get('Content-Type').match(/boundary="(.*?)"/i)[1];
                        var blocks = response.responseText.split('--' + boundary);
                        assert(blocks.length > 2);
                        assert(blocks[blocks.length - 1] == '--\r\n');
                        var i, parts, status, responses = [];
                        for (i = 1; i < blocks.length - 1; i++) {
                            try {
                                parts = split(blocks[i]);
                                status = +parts.status.match(/(\d{3})/)[1];
                                assert(status >= 0);
                                responses.push({
                                    status: status,
                                    headers: parts.inner,
                                    responseText: parts.body
                                });
                            }
                            catch (error) {
                                responses.push({
                                    status: HttpStatus.ExpectationFailed,
                                    headers: '',
                                    responseText: error + ''
                                });
                            }
                        }
                        return responses;
                    }
                    return {
                        compose: compose,
                        parse: parse
                    };
                }
                Internal.Batch = Batch;
                //#endregion
                //#region XFrame
                /**
                 * Wraps the cross-domain UCWA's <iframe> element.
                 *
                 * The implementation is so complicated because it needs to switch
                 * between xframes on different domains without dropping requests
                 * that have already been sent to the previous xframe. To handle that
                 * this implementation creates a new iframe when it's asked to switch
                 * to a new xframe and keeps the old xframe if there are pending requests
                 * in it. Once an xframe has no pending requests and is not current,
                 * it's removed.
                 *
                 * @property {String} src - The URL of the xframe.
                 * @method {Promise<Response>} send - Sends a request to the UCWA's xframe.
                 * @method reset - Removes the iframe without waiting for pending requests.
                 *
                 */
                function XFrame(wnd) {
                    var window = wnd || global;
                    var document = window.document;
                    var iframe; // the current <iframe> element
                    var iframes = {}; // iframes[iid] = an <iframe> element
                    var pending = {}; // pending[iid] = the number of pending requests for the iframe
                    var loaded = {}; // loaded[iid] = a task to track the progress of loading the iframe
                    var ready = {}; // ready[iid] = a task to track the progress of loading the xframe
                    var responses = {}; // responses[iid + ":" + rid] = Task<Response>
                    var pSrc = Property({
                        set: function (url) {
                            var uri = URI(url);
                            // http: URLs are not allowed even if the parent
                            // page was loaded from a http: URL as it is the
                            // MS wide commitment for https: for end user
                            // communication; since all traffic goes thru the
                            // xframe, it's enough to block non-https URLs here
                            if (uri.scheme() != 'https')
                                throw EMixedContent(url);
                            // The src URL changes instantly because all further
                            // requests will be sent to the new URL.
                            pSrc._set(url);
                            // However the caller may track the progress of redirecting
                            // the xframe and get notified once the new xframe is loaded.
                            return async(redirect)(url).then(function () {
                                return url;
                            });
                        }
                    });
                    function reset() {
                        var error = Exception('Reset');
                        function reject(task) {
                            try {
                                task.reject(error);
                            }
                            catch (err) {
                            }
                        }
                        foreach(loaded, reject);
                        foreach(ready, reject);
                        foreach(responses, reject);
                        foreach(iframes, removeElement);
                        // We need to clear iframe onload handler if it exists
                        // it may be triggered and inside try to resolve promise that is already rejected
                        if (iframe)
                            iframe.onload = null;
                        iframe = null;
                        pending = {};
                        loaded = {};
                        ready = {};
                        responses = {};
                    }
                    /**
                     * Changes the "src" attribute of the <iframe>.
                     *
                     * Under the hood, it actually replaces the old <iframe>
                     * with a new one and does this in such a way that all pending
                     * requests sent thru the previous iframe don't get terminated.
                     *
                     * The `src` attribute of an iframe cannot be changed to a URL
                     * on a different domain: the same origin policy prohibits this.
                     * If JS code tries to change `src` in such a way, the browser
                     * silently removes the iframe without throwing any exceptions,
                     * keeps all the HTTP sessions initiated by the iframe open, but
                     * closes corresponding XMLHttpRequest objects with status 0, to make
                     * an impression that sessions have been terminated.
                     *
                     * To handle this the client creates a new iframe and sends all
                     * further requests thru it once it's loaded. The old iframe gets
                     * removed once all requests that were sent thru complete.
                     *
                     * @param {String} url - The new value for the "src" attribute of the <iframe>.
                     */
                    function redirect(url) {
                        var iid = random();
                        // `loaded` and `ready` are different because old xframes
                        // don't support the PING request; `loaded` gets resolved when
                        // the iframe gets something from the server and `ready`
                        // gets resolved when the iframe gets the actual UCWA's xframe
                        var tLoaded = Task('iframe at ' + url);
                        var tReady = Task('xframe at ' + url);
                        if (iframe && !pending[iframe.id])
                            remove(iframe.id);
                        iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.title = (new Date).toJSON();
                        iframe.src = url;
                        iframe.id = iid;
                        // this event can be fired multiple times the server sends
                        // intermediate redirects or does full page posts
                        iframe.onload = function () {
                            if (tLoaded) {
                                tLoaded.resolve();
                                tLoaded = null;
                            }
                            post(this, { type: 'PING' });
                        };
                        document.body.appendChild(iframe);
                        iframes[iid] = iframe;
                        pending[iid] = 0;
                        loaded[iid] = tLoaded;
                        ready[iid] = tReady;
                        return tReady.promise;
                    }
                    function send(request) {
                        var target = iframe, id, task;
                        if (!target)
                            throw Exception('NoTarget');
                        id = target.id + ':' + random();
                        task = Task({
                            cancel: function (reason) {
                                cleanup(id);
                                task.reject(reason);
                            }
                        });
                        responses[id] = task;
                        pending[target.id]++;
                        loaded[target.id].promise.then(function () {
                            task.status(request.type + ' ' + request.url);
                            post(target, request, id);
                        }, null, task.status);
                        return task.promise;
                    }
                    function post(iframe, request, id) {
                        request.messageId = id || iframe.id + ':' + random();
                        iframe.contentWindow.postMessage(JSON.stringify(request), '*');
                    }
                    function cleanup(id) {
                        var iid = id.split(':')[0]; // iframe id
                        delete responses[id];
                        pending[iid]--;
                        if (iid != iframe.id && !pending[iid])
                            remove(iid);
                    }
                    function processMessage(message) {
                        var data, id, iid, task;
                        try {
                            data = JSON.parse(message.data);
                            id = data.messageId;
                            iid = id.split(':')[0]; // iframe id
                            task = responses[id];
                            if (task) {
                                cleanup(id);
                                delete data.messageId;
                                task.resolve(data);
                            }
                            if (ready[iid]) {
                                ready[iid].resolve();
                                ready[iid] = null;
                            }
                        }
                        catch (_) {
                            // an error indicates that this message
                            // was sent to someone else and thus should
                            // be ignored
                            return;
                        }
                    }
                    function removeElement(element) {
                        try {
                            document.body.removeChild(element);
                        }
                        catch (err) {
                        }
                    }
                    function remove(iid) {
                        removeElement(iframes[iid]);
                        delete iframes[iid];
                        delete pending[iid];
                        delete loaded[iid];
                        delete ready[iid];
                    }
                    // when the iframe gets a request for the server, sends it to the server
                    // and gets a response, it sends that response via the "postMessage"
                    // function of the "window" object, so the message arrives in the "onmessage"
                    // event for "window"
                    if (window.addEventListener)
                        window.addEventListener('message', processMessage);
                    else
                        window.attachEvent('onmessage', processMessage); // IE
                    return {
                        src: pSrc,
                        send: async(send),
                        reset: reset
                    };
                }
                Internal.XFrame = XFrame;
                //#endregion XFrame
                //#region MTChannel
                /**
                 * The multi-tab data channel.
                 *
                 * @method broadcast - Sends a message to all other tabs.
                 * @event data - Gets a message from another tab.
                 *
                 */
                function MTChannel(send, url) {
                    var data = Event();
                    var state = Property({ value: 'Connected' });
                    function broadcast() {
                        var args = [].slice.call(arguments, 0);
                        return send({
                            type: ':SEND',
                            url: url,
                            data: JSON.stringify(args)
                        });
                    }
                    repeat(function () {
                        return send({
                            type: ':PEEK',
                            url: url
                        }).then(function (rsp) {
                            var args = JSON.parse(rsp.data);
                            data.fire.apply(data, args);
                            state('Connected');
                        });
                    }).catch(function (err) {
                        state('Disconnected', err);
                        debug.log('%c mtchannel ' + url + ' is disconnected', 'color:red;font-weight:bold', err);
                    });
                    return {
                        broadcast: broadcast,
                        data: data.observer,
                        state: state.asReadOnly() // it's not used, but simplifies debugging
                    };
                }
                Internal.MTChannel = MTChannel;
                //#endregion
                //#region Transport
                /**
                 * Transport allows to send cross-domain requests to the UCWA server only.
                 * The UCWA server provides an iframe for this purpose, so as a web app
                 * registered on the server can use its iframe to send cross domain requests
                 * to it.
                 *
                 * @param {XFrame} xframe
                 * @param {Number} [buffer=0] - Size of the throttling buffer.
                 *
                 *      If the web app tries to send too many requests to the server
                 *      some of the may be cancelled by the browser and some by the
                 *      server with "HTTP 503 Too Many Requests"
                 *
                 *      To workaround this problem, Transport can keep requests
                 *      in a queue and send to the server up to a certain number
                 *      requests at a time.
                 *
                 * @param [delay000] - Returns delays for retries on status = 0 errors.
                 * @param [delay503] - Returns delays for retries on status = 503 errors.
                 *
                 * @method {Promise<Response>} ajax - Sends a HTTP request and returns the response.
                 *
                 * @example
                 *
                 *      var xframe = XFrame('mydomain.com');
                 *      var transport = Transport(xframe);
                 *      transport.ajax({type:'GET', url:'/my/request?q=123'}).then(function(response){
                 *          alert('response arrived');
                 *      });
                 *
                 */
                function Transport(xframe, buffer, delay000, delay503) {
                    var send = xframe.send;
                    function ErrHandler(send, delay, status) {
                        return function (req) {
                            var next = delay();
                            return repeatAndExit(function (exit) {
                                return send(req).then(function (rsp) {
                                    if (rsp.status != status)
                                        exit(rsp);
                                    return sleep(next());
                                });
                            });
                        };
                    }
                    // this stack layer throttles requests and browsers
                    // do not like when there are too many pending requests;
                    // throttling is disabled only in some unit tests
                    send = !buffer ? send : (function (send, size) {
                        var throttled = throttle(send, size);
                        return function (request) {
                            return throttled(request, request.priority);
                        };
                    })(send, buffer);
                    // if the laptop's lid is closed and reopened, xhr
                    // will terminate all requests with status = 0;
                    // such requests need to be sent again
                    send = !delay000 ? send : ErrHandler(send, delay000, 0);
                    // A 503 service unavailable indicates that there is some maintenance activity
                    // in the data center, and the application should retry with an exponential back off.
                    // After about 10 minutes of receiving 503 responses, the application should quit
                    // retrying and start the sign in process from the beginning (using auto discovery).
                    // If the application receives another response before the retry algorithm abandons
                    // the retries, such as 404.ApplicationNotFound, it should process this response as
                    // it usually would.
                    send = !delay503 ? send : ErrHandler(send, delay503, 503);
                    return {
                        ajax: send
                    };
                }
                Internal.Transport = Transport;
                //#endregion Transport
                //#region AutoDiscovery
                /**
                 * Discovers the UCWA service URL.
                 *
                 * An instance of this class takes a domain name and
                 * discovers the UCWA server. The result of the discovery is
                 * the "root" resource received from the server and the "root"
                 * resource has a link to the "user" resource from which the
                 * authentication starts and from which the client gets links to
                 * all other resources.
                 *
                 * @param {XFrame} xframe - The auto-discovery process updates the source of the xframe.
                 * @param {string} [domain] - The domain name, e.g. "contoso.com"
                 * @param {Array} [origins] - Autodiscover URLs.
                 * @param {Function} [XFrame] - Constructor of XFrame. Used by unit tests.
                 * @param {Function} [Transport] - Constructor of Transport. Used by unit tests.
                 *
                 * @member {Promise<Resource>} root - The "root" resource with a link to the "user" resource.
                 *
                 */
                function AutoDiscovery(options) {
                    var domain = options.domain;
                    var origins = options.origins;
                    var createTransport = options.Transport || Transport;
                    var createXFrame = options.XFrame || XFrame;
                    var xframe = options.xframe;
                    function discoverRoot(options) {
                        var internal = options.internal;
                        var xframeUrl = options.xframe;
                        var originUrl = options.origin;
                        var xframe = createXFrame();
                        var transport = createTransport(xframe);
                        xframe.src(xframeUrl);
                        // send a GET request to the current discovery URL,
                        // such as https://lyncdiscover.contoso.com
                        return transport.ajax({
                            type: 'GET',
                            url: originUrl
                        }).then(function (response) {
                            // extract the response text and parse it:
                            // it's supposed to be a valid UCWA resource
                            var root = Resource(JSON.parse(response.responseText));
                            // the UCWA server doesn't always specify the rel for the root resource
                            root.rel = root.rel || 'root';
                            root.set('internal', internal);
                            // the UCWA server may provide a new URL of the iframe
                            if (root.related.xframe)
                                xframe.src(root.related.xframe[0].href);
                            else
                                root.addLink('xframe', xframe.src());
                            return root;
                        }).catch(function (error) {
                            // wrap the error into a specific discovery-related error
                            throw EDiscoveryFailed(domain || origins[0].origin, error);
                        }).finally(function () {
                            // remove the xframe no matter whether the discovery succeeded or not:
                            // the caller of this function will create another xframe based on what
                            // this function returned
                            xframe.reset();
                        });
                    }
                    function discoverUcwa() {
                        // http://ucwa.lync.com/documentation/GettingStarted-RootURL
                        if (!origins) {
                            origins = [];
                            origins.push({
                                internal: true,
                                origin: 'https://lyncdiscoverinternal.' + domain,
                                xframe: 'https://lyncdiscoverinternal.' + domain + '/xframe'
                            });
                            origins.push({
                                internal: false,
                                origin: 'https://lyncdiscover.' + domain,
                                xframe: 'https://lyncdiscover.' + domain + '/xframe'
                            });
                            origins.push({
                                internal: true,
                                origin: 'http://lyncdiscoverinternal.' + domain,
                                xframe: 'http://lyncdiscoverinternal.' + domain + '/xframe'
                            });
                            origins.push({
                                internal: false,
                                origin: 'http://lyncdiscover.' + domain,
                                xframe: 'http://lyncdiscover.' + domain + '/xframe'
                            });
                        }
                        // try all auto-discovery URLs concurrently and if one
                        // succeeds, stop trying all other pending URLs
                        return Task.waitAny(map(origins, async(discoverRoot)));
                    }
                    return {
                        root: discoverUcwa().then(function (root) {
                            // The current implementation of concurrent autodiscovery
                            // creates a separate xframe for every auto-discovery URL
                            // and tries to get the rel=root resource. After one of
                            // xframes finds the rel=root, all xframes are removed and a
                            // completely separate xframe is directed to the found URL.
                            // This behavior is somewhat suboptimal and it would be better
                            // to change the interface of the auto-discovery class and
                            // make it return a pair [xframe, root] to avoid recreating
                            // an already existing xframe. But changing the interface would
                            // require to change all the stack-level samples and since I'm
                            // going to wrap all the stack layer into a UCWA class anyway,
                            // I'm postponing the change of the auto-discovery interface
                            // until that moment. But anyway, the auto-discovery time is
                            // reduced dramatically even with this suboptimal implementation.
                            xframe.src(root.link('xframe').href);
                            return root;
                        })
                    };
                }
                Internal.AutoDiscovery = AutoDiscovery;
                //#endregion
                //#region Endpoint
                /**
                 * Endpoint exposes the "ajax" function that behaves like jQuery.ajax
                 * and allows to send JSON requests to the UCWA server seamlessly passing
                 * thru the authorization - Endpoint obtains the auth token.
                 *
                 * @param {Transport} transport
                 * @param {() => Promise<void>} restore
                 * @param {Function} auth - The authorization middleware. It has the following signature:
                 *
                 *      {Promise<Response>} auth(request, getResponse)
                 *
                 *          - {Request} request - A request without auth information.
                 *          - {Promise<Response>} getResponse(request) - The transport layer's function.
                 *
                 *      The <auth> function is invoked whenever layers above it need to send an HTTP
                 *      <request>. The <request> does not have any auth-related HTTP headers and the <auth>
                 *      function is supposed to add these auth headers, then invoke the <getResponse>
                 *      function and return the result of <getResponse>.
                 *
                 *      The <auth> function may need to send a few extra requests to obtain the auth token
                 *      that may be missing or expired. To send these extra requests it should use the
                 *      <getResponse> function, because <getResponse> belongs to the transport layer that
                 *      supports priorities of the requests and has an internal throttling queue.
                 *
                 *      The <auth> function may use an external library to send extra HTTP requests (e.g. jQuery.ajax),
                 *      but the <auth> function then will need to make sure that it returns a Promise/A+
                 *      with the <then> function. This is the case for jQuery/1.8.* - it returns a Promise/A+:
                 *
                 *          function auth(request, getResponse) {
                 *              return jQuery.ajax(request); // works for jQuery/1.8.*
                 *          }
                 *
                 *      To implement a pass-thru auth function that does nothing and only monitors traffic:
                 *
                 *          function auth(request, getResponse) {
                 *              return getResponse(request);
                 *          }
                 *
                 * @param {Number} [batchRetryDelay=3.0] - A delay before a batch failed with HTTP 429 gets resent.
                 *
                 * @method {Promise<Resource>} ajax(request) - Sends a request via the Transport.
                 * @method {Promise<Promise<Resource>[]>} batch(composer, requests) - Sends a batch request.
                 *
                 * @event renewed - Occurs after the web ticket expires and gets renewed.
                 *
                 */
                function Endpoint(args) {
                    var renewed = Event();
                    var transport = args.transport;
                    var batchRetryDelay = args.batchRetryDelay || 3.0;
                    var authorize = async(args.auth);
                    var restore = args.restore && debounced(args.restore);
                    var send, sendBatch;
                    /**
                     * Sends a batch request and parses the batch response.
                     *
                     * Under the hood it modifies each request, composes them
                     * into a single batch request, adds the authorization header
                     * to it and sends to the batch URL. When the batch response
                     * arrives, it decomposes it into separate responses, parses them
                     * and resolves the returned promise object with the array
                     * of responses.
                     *
                     * @param {Batch} composer - The composer of the batch requests.
                     * @param requests - The array of requests.
                     *
                     * @returns {Promise<Promise<Resource>[]>}
                     *
                     *      The function returns a promise that resolves to an array of
                     *      promises. Each of these promises resolve to a resource.
                     */
                    function batch(composer, requests) {
                        foreach(requests, prepare);
                        var batchreq = composer.compose(requests);
                        return sendBatch(batchreq).then(function (batchrsp) {
                            // Batch requests often fail with HTTP 429 Too Many Requests
                            // and if this happens, resend the request in a few seconds.
                            // The batch request must be sent eventually, as it may contain
                            // requests that are crucial for normal operating of the web app,
                            // such as a POST .../makeMeAvailable request.
                            if (batchrsp.status == HttpStatus.TooManyRequests) {
                                return sleep(batchRetryDelay).then(function () {
                                    return batch(composer, requests);
                                });
                            }
                            if (!HttpStatus.isSuccess(batchrsp.status))
                                throw ERequestFailed(batchreq, batchrsp);
                            return decompose(composer, requests, batchrsp);
                        });
                    }
                    /**
                     * Decomposes a batch response into separate responses and
                     * parses them.
                     */
                    function decompose(composer, requests, batchrsp) {
                        var responses = composer.parse(batchrsp);
                        assert(requests.length == responses.length);
                        return map(requests, async(function (request, i) {
                            return process(requests[i], responses[i]);
                        }));
                    }
                    //#region prepare
                    function prepare(request) {
                        // the UCWA server always returns JSON
                        // except when it replies for the batch request
                        request.dataType = 'json';
                        if (!request.headers)
                            request.headers = {};
                        // TODO: the requested version is supported only if _links.self.revision
                        // is greater than or equal to it or the requested version is 1; at this
                        // point it's too late to check the revision, but somewhere above in the
                        // stack it should be possible
                        if (request.version > 1)
                            request.headers['X-MS-RequiresMinResourceVersion'] = request.version;
                        // specify the Content-Type header
                        if (isString(request.data)) {
                            // if a plain text is sent, assume that this is "text/plain"
                            request.contentType = 'text/plain';
                        }
                        else if (isObject(request.data)) {
                            // for POST requests put the data into the body in the JSON format;
                            // for GET requests let jQuery put the data into the query string in the URL
                            if (request.type == 'POST' || request.type == 'PUT') {
                                if (request.type == 'PUT')
                                    request.headers['If-Match'] = '"' + request.data.etag + '"';
                                // if an object is sent, assume that this is a "application/json"
                                request.data = JSON.stringify(request.data);
                                request.contentType = 'application/json';
                            }
                        }
                    }
                    //#endregion
                    function parseResponse(rsp) {
                        try {
                            // all responses from UCWA are in the JSON format
                            rsp.data = JSON.parse(rsp.responseText);
                        }
                        catch (_) {
                        }
                    }
                    //#region process
                    /**
                     * Handles a response for a request sent by "ajax".
                     *
                     * The response may be a "HTTP 401 Unauthorized" challenge, so
                     * the endpoint must seamlessly obtain an auth token from the server
                     * and send the same request with the auth token.
                     *
                     * @param response - The response that corresponds to the request.
                     *
                     * @returns {Promise<Resource>}
                     */
                    function process(request, response) {
                        assert(response);
                        var parsed, result, headers = HttpHeaders(response.headers);
                        parseResponse(response);
                        if (!HttpStatus.isSuccess(response.status)) {
                            // if the status code doesn't indicate the success,
                            // don't even try to parse the response text
                            throw ERequestFailed(request, response);
                        }
                        else if (!response.responseText) {
                            // in most cases the server responds with a resource,
                            // however when the client sends a POST request to the sendMessage
                            // resource, the server replies with "HTTP 201 Created" and with
                            // empty response body, but with the Location HTTP header that contains
                            // the href of the created message
                            return Resource(headers.get('Location'), null);
                        }
                        else {
                            // if the UCWA server sends a successful response,
                            // its contents are expected to be a JSON string and
                            // the JSON string must represent a Resource
                            try {
                                parsed = response.data;
                                // TODO: What if the server returns the same mime type but with a different version, e.g. v=1.1?
                                result = headers.get('Content-Type') == 'application/vnd.microsoft.rtc.autodiscover+json; v=1' ?
                                    Endpoint.parseAutodiscoverResource(parsed) :
                                    Resource(parsed);
                            }
                            catch (_) {
                                // If the response is not a regular resource,
                                // maybe it is a multipart resource?
                                parsed = Endpoint.parseMultipartRelatedResponse(response);
                                result = Endpoint.parseMultipartResources(parsed)[0];
                            }
                            // Endpoint provides server responses as resources
                            return result;
                        }
                    }
                    //#endregion
                    //#region send
                    send = async(transport.ajax);
                    // this layer simply adds the X-Ms-Namespace:internal header
                    // which is needed by the media model
                    send = (function (send) {
                        return function (req) {
                            // TODO: consider moving this to specific (media) requests that need this
                            req.headers = req.headers || {};
                            req.headers['X-Ms-Namespace'] = 'internal';
                            return send(req);
                        };
                    })(send);
                    // this layer adds seamless authorization:
                    // if the server requires authorization, the endpoint
                    // seamlessly obtains an auth token and resends the request
                    // again with the token
                    send = (function (send) {
                        return function (req) {
                            return authorize(req, send).then(function (rsp) {
                                if (rsp.webTicketRenewed)
                                    renewed.fire(req, rsp);
                                return rsp;
                            });
                        };
                    })(send);
                    // this layer parses .responseText if it's in the JSON format
                    send = (function (send) {
                        return function (req) {
                            return send(req).then(function (rsp) {
                                parseResponse(rsp);
                                return rsp;
                            });
                        };
                    })(send);
                    // this layer adds resiliency to the 404.ApplicationNotFound error
                    // that occurs whenever a UCWA instance crashes and gets recreated
                    // on another server machine
                    send = (function (send) {
                        function is404(rsp) {
                            return rsp && rsp.status == 404 && rsp.data.subcode == 'ApplicationNotFound';
                        }
                        return function (req) {
                            return send(req).then(function (rsp) {
                                // whenever this error occurs, it sends a POST to restore the app,
                                // waits for the POST and then resends the request; if the request
                                // fails again, it doesn't try to repeat the steps as it's likely
                                // that the app has been permanently deleted
                                return is404(rsp) ? restore().then(bind(send, req)) : rsp;
                            });
                        };
                    })(send);
                    // batch requests are sent thru this layer
                    sendBatch = send;
                    // This layer sends JSON requests: it serializes args.data
                    // into a JSON string and sends it with "Content-Type: application/json"
                    // The response is always a Resource: this method parses the
                    // JSON string returned by the server and turns it into a Resource.
                    send = (function (send) {
                        return function (req) {
                            prepare(req);
                            return send(req).then(bind(process, req));
                        };
                    })(send);
                    //#endregion
                    return {
                        renewed: renewed.observer,
                        ajax: send,
                        batch: batch
                    };
                }
                Internal.Endpoint = Endpoint;
                var Endpoint;
                (function (Endpoint) {
                    //#region parseMultipartRelatedResponse
                    /**
                     * Parses a multipart/related response that has the following form:
                     *
                     *      HTTP/1.1 200 OK
                     *      Content-Type: multipart/related; charset=utf-8; boundary=e6c28643-44ea-45c8-b62e-6a56bd22b3aa
                     *
                     *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa
                     *      Content-Type: application/vnd.microsoft.com.ucwa+json; charset=utf-8
                     *
                     *      {"_links":{"self":{"href":"/ucwa/v1/applications/111415042852/events?ack=4"},"next...
                     *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa
                     *      Content-Type: application/sdp; charset=utf-8
                     *      Content-ID: 0fced42f-b345-4294-95f0-9fc2f7882ade
                     *
                     *      v=0...
                     *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa--
                     *
                     * @param {Response} response
                     * @returns {Response[]}
                     *
                     *      Returns an array of responses that were embedded into the multipart/related response.
                     *      Every returned response has the "headers" and "responseText" properties.
                     */
                    function parseMultipartRelatedResponse(response) {
                        var rxCRLF2 = /(\r\n|\n){2}/;
                        var rxCRLFL = /^(\r\n|\n)/;
                        var rxCRLFR = /(\r\n|\n)$/;
                        var rxEnding = /--\s*$/;
                        var parts, contentType;
                        try {
                            contentType = ContentTypeHeader(HttpHeaders(response.headers).get('Content-Type'));
                            check.equals(contentType.mimeType, 'multipart/related');
                            check.belongs('boundary', contentType.attributes);
                            parts = response.responseText.split('--' + contentType.attributes.boundary);
                            check(rxEnding.test(parts[parts.length - 1]));
                            check(parts.length >= 3);
                            return map(parts.slice(+1, -1), function (part, index) {
                                var crlf2 = rxCRLF2.exec(part);
                                if (!crlf2)
                                    throw Exception('SingleHeaderExpected', { part: part, index: index });
                                var headers = part.substr(0, crlf2.index);
                                var content = part.substr(crlf2.index + crlf2[0].length);
                                return {
                                    headers: headers.replace(rxCRLFL, ''),
                                    responseText: content.replace(rxCRLFR, '')
                                };
                            });
                        }
                        catch (error) {
                            throw Exception('InvalidMultipartRelatedResponse', { response: response, reason: error });
                        }
                    }
                    Endpoint.parseMultipartRelatedResponse = parseMultipartRelatedResponse;
                    //#endregion
                    //#region parseMultipartResources
                    /**
                     * Converts a multi part representation of resources into an array of resources.
                     *
                     * UCWA may return an HTTP response of the multipart/related type with parts
                     * in the response text. Some parts contain JSON serialized resources,
                     * while other parts contain data with Content-ID and Content-Type headers.
                     * Resources may have links of form "cid:ABC" where "ABC" is the value of one of
                     * Content-ID headers in the multipart response.
                     *
                     * This function parses those parts that represent resources, then checks every link
                     * in these resources and if that link is something like "cid:ABC" the function looks for
                     * a part with Content-ID:ABC and if such a part exists, it replaces the link with
                     * a data URI that containing the found part. For example, if there was
                     * a link of the following form:
                     *
                     *      "_links": {
                     *          "mediaAnswer":{"href":"cid:0fced42f-b345-4294-95f0-9fc2f7882ade"}
                     *      }
                     *
                     * and if there was a corresponding part:
                     *
                     *      Content-Type: application/sdp; charset=utf-8
                     *      Content-ID: 0fced42f-b345-4294-95f0-9fc2f7882ade
                     *
                     *      v=0
                     *      s=session
                     *
                     * the link will be converted to a data URI:
                     *
                     *      "_links": {
                     *          "mediaAnswer":{"href":"data:application/sdp;charset=utf-8,v=0\r\ns=session"}
                     *      }
                     *
                     * which can be parsed with the DataUri class.
                     *
                     * @param {Response[]} parts - parseMultipartRelatedResponse returns this array.
                     * @returns {Resource[]}
                     */
                    function parseMultipartResources(parts) {
                        var resources = [];
                        var contents = {};
                        foreach(parts, function (part) {
                            var content = part.responseText;
                            var headers = HttpHeaders(part.headers);
                            var contentId = headers.get('Content-ID');
                            var contentType = headers.get('Content-Type');
                            if (!contentId)
                                resources.push(Resource(JSON.parse(content)));
                            else {
                                contents['cid:' + contentId] = {
                                    data: content,
                                    mime: contentType.replace(/\s/g, '')
                                };
                            }
                        });
                        foreach(resources, function (resource) {
                            resource.forEachLink(function (link) {
                                var content = contents[link.href];
                                if (content)
                                    link.href = 'data:' + content.mime + ',' + content.data;
                            });
                        });
                        return resources;
                    }
                    Endpoint.parseMultipartResources = parseMultipartResources;
                    //#endregion
                    //#region parseAutodiscoverResource
                    /**
                     * Parses the "application/vnd.microsoft.rtc.autodiscover+json;v=1" format
                     * of the resource object. This format is used in a special auto-discovery
                     * flow. An example of such a resource:
                     *
                     *      {
                     *          "User": {
                     *              "Links": [
                     *                  { "href": "http://webdir1D.tip.lync.com/.../root", "token": "Redirect" },
                     *                  { "href": "https://webdir0d.tip.lync.com/.../root/user", "token": "Self" },
                     *                  { "href": "http://webdir1D.tip.lync.com/.../root/xframe", "token": "XFrame" }],
                     *              "SipClientExternalAccess": null,
                     *              "SipClientInternalAccess": null,
                     *              "SipServerExternalAccess": null,
                     *              "SipServerInternalAccess": null
                     *          }
                     *      }
                     *
                     * The Resource object created from this sample input will have rel=user
                     * and will have links rel=redirect and rel=xframe. Rels are lowercased.
                     *
                     * @param {Object} json
                     * @returns {Resource}
                     */
                    function parseAutodiscoverResource(json) {
                        var res, rel, href, selfs, root, roots;
                        roots = filter(json, isObject);
                        check(values(roots).length == 1, 'single root expected');
                        rel = keys(roots)[0];
                        root = roots[rel];
                        selfs = filter(root.Links, function (link) {
                            return link.token == 'Self';
                        });
                        check(selfs.length == 1, 'single self href expected');
                        href = selfs[0].href;
                        res = Resource(href, rel.toLowerCase());
                        foreach(root.Links, function (link) {
                            if (link.href != href)
                                res.addLink(link.token.toLowerCase(), link.href);
                        });
                        return res;
                    }
                    Endpoint.parseAutodiscoverResource = parseAutodiscoverResource;
                })(Endpoint = Internal.Endpoint || (Internal.Endpoint = {}));
                //#endregion  Endpoint
                //#region Application
                /**
                 * This class wraps the corresponding rel=application resource that
                 * represents a signed in UCWA endpoint. The rel=application resource
                 * has links to other resources, such as rel=me and rel=conversations,
                 * that can be used to get the user name, the list of active conversations
                 * and so on.
                 *
                 * The sign in process starts with the rel=root resource returned by the
                 * auto discovery step and then sends a few requests to create a rel=application
                 * resource. The diagram below shows the relationships between all these resources:
                 *
                 *      rel=root
                 *          rel=xframe
                 *          rel=user
                 *              rel=xframe
                 *              rel=applications
                 *                  rel=application
                 *                      rel=me
                 *                      rel=batch
                 *                      rel=events
                 *                      rel=conversations
                 *                      ...
                 *
                 * So to create a rel=application resource the stack sends two requests:
                 *
                 *      GET rel=user
                 *      POST rel=applications
                 *      GET rel=events
                 *
                 * In the case when rel=application already exists in the repository,
                 * the client gets the current state of it instead of creating a new
                 * rel=application:
                 *
                 *      GET rel=application
                 *      GET rel=events
                 *
                 * Note, that getting rel=user is also skipped in this case.
                 *
                 * @param {String} [id] - The endpoint id. Can be used to fork an app.
                 * @param {string} culture - The locale of the application, e.g. "en-us"
                 * @param {string} version - The version of the application, e.g. "MyApp/1.0"
                 * @param {XFrame} xframe
                 * @param {Endpoint} endpoint
                 * @param {Repository} repository
                 * @param {Connection} connection
                 * @param {Resource|Promise<Resource>|Void} root - The rel=root resource.
                 * @param {Number} [maxBatchSize=0]
                 *
                 *      If this parameter is set, the application will queue all requests and
                 *      send them in batches. Note, that UCWA has an upper limit of the batch
                 *      size, which is 20, and if maxBatchSize is set to a higher value
                 *      the stack may send batches of this size and these batches will be rejected
                 *      by UCWA. The stack layer does not have any logic to handle this: the model
                 *      layer will just find that all requests sent in that batch failed.
                 *
                 * @method {Promise<Resource>} ajax(request) - Sends an HTTP request to UCWA.
                 *
                 *      request.priority - A number indicating the priority of the request.
                 *      request.nobatch - If set, the request is sent right away via Endpoint::ajax.
                 *
                 *      Unless the <nobatch> parameter is set, the request is inserted into
                 *      an internal queue and its position is defined by its priority - the higher
                 *      the priority, the sooner the request will be sent to Endpoint.
                 *
                 * @member {Promise} ready - It resolves after the sign in succeeds.
                 *
                 */
                function Application(args) {
                    assert(!args.maxBatchSize || args.maxBatchSize > 0);
                    var repository = args.repository;
                    var xframe = args.xframe;
                    var endpoint = args.endpoint;
                    var connection = args.connection;
                    var maxBatchSize = args.maxBatchSize || 0;
                    var endpointId = args.id || guid(); // requires version=2 of POST /applications
                    var instanceId = args.id && guid(); // a forked app has the same endpoint id, but a unique instance id
                    var version = args.version;
                    var culture = args.culture;
                    var send;
                    var batcher;
                    var ready = 
                    // the regular flow: sign in, create a rel=application and subscribe to rel=events
                    args.root ? Task.wait(args.root).then(addRoot).then(getUser).then(createApp).then(init) :
                        // the resurrection flow: fetch an existing rel=application and subscribe to rel=events
                        repository.get('application')[0] ? Task.wait(null).then(getApp).then(init) :
                            // the partial sign in flow: when the rel=applications link is known, but rel=user isn't
                            Task.wait(null).then(createApp).then(init);
                    args = null; // reduce the visibility scope of this variable
                    //#region addRoot
                    function addRoot(root) {
                        repository.put(root);
                        return root;
                    }
                    //#endregion
                    //#region fixScheme
                    /**
                     * Changes the URI's scheme to https if the URI has a scheme.
                     * If it doesn't, returns the original URI.
                     */
                    function fixScheme(link) {
                        var uri = URI(link);
                        return uri.scheme() == 'http' ?
                            uri.scheme('https') + '' :
                            link;
                    }
                    //#endregion
                    //#region getUser
                    /**
                     * This GET request is supposed to return a link to rel=applications.
                     * In certain cases, however, the rel=applications link is missing in
                     * the response. If this link is missing, the client may assume that
                     * it's observing a server bug for which there is a workaround:
                     *
                     *      1. The client needs to send the GET to rel=user again,
                     *         but this time with a special Accept header.
                     *
                     *      2. The response will contain a specially formatted resource
                     *         with rel=redirect and rel=xframe links that point to another pool.
                     *
                     *      3. The client needs to send a regular GET to the rel=redirect link
                     *         and the response will contain a link to rel=user on another pool.
                     *
                     * @returns {Promise<Resource>} - Returns the rel=user resource.
                     */
                    function getUser(root) {
                        return endpoint.ajax({
                            type: 'GET',
                            url: root.link('user').href
                        }).then(function (user) {
                            // if the user/applications link is missing, try to get it
                            // via the private auto discovery flow
                            return user.hasLink('applications') ? user :
                                endpoint.ajax({
                                    type: 'GET',
                                    url: root.link('user').href,
                                    headers: { 'Accept': 'application/vnd.microsoft.rtc.autodiscover+json; v=1' }
                                }).then(function (user1) {
                                    user1.rel = user1.rel || 'user'; // the server may omit "rel" for this resource
                                    if (user1.hasLink('xframe'))
                                        // the server-side auto-d code is handcrafting URLs
                                        // and may mistakenly return an HTTP link here
                                        xframe.src(fixScheme(user1.link('xframe').href));
                                    return endpoint.ajax({
                                        type: 'GET',
                                        // the server-side auto-d code is handcrafting URLs
                                        // and may mistakenly return an HTTP link here
                                        url: fixScheme(user1.link('redirect').href)
                                    });
                                }).then(function (redirect) {
                                    redirect.rel = redirect.rel || 'redirect'; // the server may omit "rel" for this resource
                                    if (redirect.hasLink('xframe'))
                                        xframe.src(redirect.link('xframe').href);
                                    return endpoint.ajax({
                                        type: 'GET',
                                        url: redirect.link('user').href
                                    });
                                });
                        }).then(function (user) {
                            user.rel = user.rel || 'user'; // the server may omit "rel" for this resource
                            repository.put(user);
                            if (user.hasLink('xframe'))
                                xframe.src(user.link('xframe').href);
                            return user;
                        });
                    }
                    //#endregion
                    //#region createApp
                    function createApp() {
                        // if the server doesn't support forking an application, the client
                        // falls back to the regular POST /applications request that creates
                        // a new endpoint or resumes an existing one with the given id
                        var r = repository.get('applications')[0];
                        var v = (instanceId && r.revision >= 2) ? 2 : 1;
                        return endpoint.ajax({
                            type: 'POST',
                            url: r.href,
                            version: v,
                            data: {
                                UserAgent: version,
                                Culture: culture,
                                EndpointId: endpointId,
                                InstanceId: v == 2 ? instanceId : void 0
                            }
                        }).then(function (app) {
                            repository.put(app);
                            return app;
                        });
                    }
                    //#endregion
                    //#region getApp
                    function getApp() {
                        return endpoint.ajax({
                            type: 'GET',
                            url: repository.get('application')[0].href
                        }).then(function (app) {
                            repository.put(app);
                            return app;
                        });
                    }
                    //#endregion
                    //#region init
                    function init(app) {
                        // if rel=batch is available, then batch requests are supported
                        if (app.hasLink('batch'))
                            batcher = Batch(app.link('batch').href);
                        // if rel=events available, start listening to events
                        if (app.hasLink('events'))
                            connection.connect(app.link('events').href);
                    }
                    //#endregion
                    //#region ajax
                    /**
                     * Sends an HTTP request to the given URL.
                     * The resource returned by the server is cached in the repository.
                     *
                     * @param request - Same options as of jQuery.ajax.
                     * @returns {Promise<Resource>}
                     */
                    function ajax(request) {
                        return endpoint.ajax(request).then(function (resource) {
                            repository.put(resource);
                            return resource;
                        });
                    }
                    //#endregion
                    //#region batch
                    /**
                     * Sends a batch request.
                     *
                     * @param {Request[]} requests - An array of HTTP requests to send.
                     * @returns {async (async Resource)[]} - An array of promises.
                     */
                    function batch(requests) {
                        assert(requests.length > 0);
                        // if the batch contains only 1 request or batching is not enabled,
                        // send the requests separately
                        if (requests.length == 1 || !batcher || !maxBatchSize)
                            return map(requests, ajax);
                        return endpoint.batch(batcher, requests).then(function (results) {
                            foreach(results, function (r) {
                                Task.wait(r).then(repository.put);
                            });
                            return results;
                        });
                    }
                    //#endregion
                    //#region renewing cwt_ucwa cookie
                    // A response to the first "POST applications" request
                    // contains not only the "application" resource but also
                    // a Set-Cookie header that sets a cwt_ucwa cookie needed
                    // to get contact photos. This cookie looks like this:
                    //
                    //      POST .../applications HTTP/1.1
                    //      {"UserAgent":"...","Culture":"en-us","EndpointId":"..."}
                    //
                    //      HTTP/1.1 201 Created
                    //      Set-Cookie: cwt_ucwa=AAE...b3M; path=.../photos; secure; HttpOnly
                    //
                    // So whenever the client creates an <img> element pointing to
                    // a contact photo, the browser sends a GET request to that URL
                    // including the cwt_ucwa cookie in the Cookie header:
                    //
                    //      GET .../photos/johndoe HTTP/1.1
                    //      Cookie: cwt_ucwa=AAE...b3M
                    //
                    // However this cwt_ucwa cookie has a limited lifetime and eventually
                    // it expires. A right way to renew this cookie was suggested by
                    // the server team: whenever the primary web ticket expires, renew it
                    // and sends a "GET application" request - the response will contain
                    // a new value of the cwt_ucwa cookie:
                    //
                    //      GET .../applications/... HTTP/1.1
                    //      Authorization: Bearer cwt=AAE...1Vo
                    //
                    //      HTTP/1.1 200 OK
                    //      Set-Cookie: cwt_ucwa=AAE...b3M
                    //
                    // So the code snippet below sends this GET request whenever the primary
                    // web ticket expires.
                    endpoint.renewed(function () {
                        var apps = repository.get('application');
                        if (apps.length > 0)
                            send({ type: 'GET', url: apps[0].href, nobatch: true });
                    });
                    //#endregion
                    //#region send
                    send = async(ajax);
                    // this is the batching layer that accumulates all requests
                    // without nobatch=true and sends them in one batch on the
                    // next event cycle
                    send = (function (send) {
                        var sendInBatch = !maxBatchSize ? send :
                            batched(async(batch), maxBatchSize);
                        return function (req) {
                            req.priority = req.priority || 0;
                            return req.nobatch ? send(req) :
                                sendInBatch(req, req.priority);
                        };
                    })(send);
                    // this is debouncing layer that merges identical GET requests
                    // into one; this is possible because GET requests do not modify
                    // the state on the server
                    send = (function (send) {
                        var reqs = {};
                        return function (req) {
                            if (req.type != 'GET')
                                return send(req);
                            // JSON.stringify acts here as a hash function; since request
                            // objects are very small, JSON.stringify is just better than
                            // any other hash function
                            var uid = JSON.stringify(req);
                            reqs[uid] = reqs[uid] || send(req).finally(function () {
                                delete reqs[uid];
                            });
                            return reqs[uid];
                        };
                    })(send);
                    //#endregion
                    return {
                        ajax: send,
                        id: ConstProperty(endpointId),
                        restore: createApp,
                        ready: ready
                    };
                }
                Internal.Application = Application;
            })(Internal = Stack.Internal || (Stack.Internal = {}));
            //#region UCWA
            /**
             * Encapsulates the UCWA stack.
             *
             * This object brings together various pieces of the stack,
             * such as Connection, XFrame, Transport and so on. The model
             * layer uses this stack as the data source.
             *
             * Parameters to the constructor specify how the UCWA::init method
             * will sign in to the server. Note, that the sign in starts with
             * the autodiscovery step that uses the domain FQDN as the starting point.
             * If the domain FQDN is not known it's possible to skip the autodiscovery
             * step by specifying URLs of rel=user and rel=xframe (these URLs are what
             * the autodiscovery step finds):
             *
             *      UCWA({
             *          root: {
             *              user: "https://contoso.com/.../user?originalDomain=contoso.com",
             *              xframe: "https://contoso.company.com/.../XFrame.html"
             *          }
             *      });
             *
             * Here is the list of supported authentication flows:
             *
             *  - basic authentication
             *
             *      UCWA({
             *          username: "johndoe@contoso.com",
             *          password: "sjd8239jKJwk"
             *      });
             *
             *  - integrated windows authentication (IWA)
             *
             *      UCWA({
             *          domain: "contoso.com"
             *      });
             *
             *  - anonymous authentication to join an online meeting
             *
             *      UCWA({
             *          meeting: "sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:QHJ72TKK"
             *      });
             *
             *  - custom authentication
             *
             *      UCWA({
             *          domain: "contoso.com",
             *          auth: function (request, getResponse) {
             *              request.headers["Authorization"] = "Bearer cwt=ABbacxa7187";
             *              return getResponse(request);
             *          }
             *      });
             *
             *  - implicit authentication
             *
             *      UCWA({
             *          client_id: '123-456',
             *          oauth_uri: 'https://login.windows-ppe.net/common/oauth2/authorize',
             *          origins: [{
             *              origin: 'https://webdir.tip.lync.com/AutoDiscover/AutoDiscoverservice.svc/root?originalDomain=contoso.com',
             *              xframe: 'https://webdir.tip.lync.com/xframe'
             *          }]
             *      });
             *
             * @param {Number} [throttle=5]
             *
             *      If the web app tries to send too many requests to the server
             *      some of them may be cancelled by the browser and some by the
             *      server with "HTTP 503 Too Many Requests"
             *
             *      To workaround this problem, Transport can keep requests
             *      in a queue and send to the server up to a certain number
             *      requests at a time.
             *
             * @param [delay000] - Returns delays for retries on status = 0 errors.
             * @param [delay503] - Returns delays for retries on status = 503 errors.
             *
             * @param {String} [id] - The endpoint id. Can be used to fork an app.
             *
             *      A forked app shares the endpoint id and most of the internal state
             *      on the server with the original app, but has a unique event channel
             *      link and a unique instance id. A forked app gets the same events
             *      in the same sequence.
             *
             *      Forking an app is done by a version=2 POST /applications. If this
             *      version isn't supported, the client sends a regular POST request.
             *
             * @param {String} [culture="en-us"]
             *
             *      The UCWA server will localize some strings (for example error messages)
             *      in the given language.
             *
             * @param {String} [version]
             *
             *      The version of the client that registers an endpoint on the UCWA server.
             *
             * @param {Number} [maxBatchSize=20]
             *
             *      By default our UCWA stack queues all requests and sends them in batches. This parameter
             *      changes the default batch size of 20 (the UCWA-defined upper limit). If the parameter
             *      value is higher than the default, the batch size is reset to default. Note that if the
             *      stack sent batches with over 20 requests these batches would be rejected by UCWA. The stack
             *      layer does not have any logic to handle this: the model layer will just find that all
             *      requests sent in that batch failed.
             *
             * @param {String} [username] - The user name, e.g. "user@company.com"
             * @param {String} [password] - The password.
             * @param {String} [domain] - FQDN of the server.
             * @param {Array} [origins] - Autodiscover URLs.
             *
             *      Multiple autodiscover URLs are useful when it's not clear where the user belongs to.
             *      If the user is known to belong to a specific topology, it might be simpler to specify
             *      the correct autodiscover URL and make the sign in a bit faster.
             *
             *      They can be specified in the verbose form in which both the root and the xframe URL
             *      are written explicitly:
             *
             *          UCWA({
             *              origins: [{
             *                  origin: 'https://webdir.online.lync.com/.../root?originalDomain=...',
             *                  xframe: 'https://webdir.online.lync.com/xframe'
             *              }]
             *          });
             *
             *      Or they can be specified in the short form in which the root URL is written
             *      explicitly and the xframe URL is calculated by the API:
             *
             *          UCWA({
             *              origins: [
             *                  'https://webdir.online.lync.com/.../root?originalDomain=...',
             *                  'https://webdir.tip.lync.com/.../root?originalDomain=...',
             *              ]
             *          });
             *
             * @param {Function} [auth] - The auth method. OAuth for instance.
             * @param {String} [client_id] - The client_id parameter for OAuth2.
             * @param {String} [oauth_uri] - Overrides the OAuth URI.
             * @param {String} [state] - The state parameter for OAuth. Used by unit tests.
             * @param {String} [root.user] - The href for the user resource. It would be only provided by office 365 users.
             * @param {String} [root.xframe] - The href for the xframe. It would be only provided by office 365 users.
             * @param {Boolean} [root.internal] - Whether the UCWA root is internal or external.
             * @param {String} [meeting] - URI of the online meeting to join anonymously.
             * @param [snapshot] - The initial state previously returned by UCWA::getSnapshot.
             *
             *      Restoring the state of the stack from a snapshot is completely
             *      unrelated to the authentication process, as it's possible to
             *      sign in via ADFS, take a snapshot, then sign in via OAuth and
             *      restore the state from that snapshot.
             *
             *      Thus the authentication related parameters (such as `domain` or `auth`)
             *      are necessary when providing the `snapshot` parameter.
             *
             * @method {Promise} init - Signs in and connects to the server.
             * @method uninit - Disconnects from the server and cleans up resources.
             *
             * @method {Promise} wait(pattern) - Waits for a specific event from UCWA.
             *
             *      ucwa.wait({
             *          type: 'completed',
             *          target: { rel: 'message' }
             *      }).then(function (event) {
             *          console.log(event.target.href);
             *      });
             *
             * @method {Promise<Resource>} send(method, selector, options)
             *
             *      Sends an HTTP request and returns the resource object
             *      given by the server in response. The options allow to
             *      control the request priority, set headers, define whether
             *      it should go to the batching queue and so on.
             *
             *          ucwa.send("POST", ".../audioVideoInvitations", {
             *              nobatch: true,  // SDP offers cannot be batched
             *              priority: 3,    // some random priority for the throttling queue
             *              data: "v=0\r\nsession=1\r\n...",
             *              query: { operationId: "12-342-232" },
             *              headers: { "Content-Type": "application/sdp; charset=utf-8" }
             *          });
             *
             *      `selector` can be either a URI/URL or an object of the form { rel: '...' }
             *      to make the stack find the resource with the specified rel and send the
             *      request to its href:
             *
             *          ucwa.send("GET", { rel: "me" });
             *
             * @method {Resource} get(selector)
             *
             *      Finds an existing resource object by href or rel in the repository.
             *      If there is no such resource or there are several such resources,
             *      the method throws an exception.
             *
             *          ucwa.get(".../messages/2"); // lookup the resource by its href
             *          ucwa.get({ rel: "me" }); // lookup the resource by its rel
             *
             * @method {Resource[]} find(selector)
             *
             *      Finds all resource objects in the repository matching the selector.
             *      The selector may contain the rel or the href of the resource.
             *
             * @method {Boolean} exists(selector)
             *
             *      Checks whether the resource object exists in the repository.
             *
             * @method getSnapshot - Returns a snapshot of the repository.
             *
             *      The snapshot is a mapping from a rel to an array of resource snapshots
             *      which are raw objects. This is how a snapshot can be used:
             *
             *          var snapshot = ucwa.getSnapshot();
             *          var resource = Resource(snapshot.contact[0]);
             *
             * @method {MTChannel} mtchannel(id) - Connects to the specified multitab channel.
             *
             *      The method can be safely invoked multiple times for the same channel id.
             *
             * @property {Boolean} connected - Tells whether the UCWA endpoint is still alive.
             *
             * @event {ResourceEvent} event - An event from the UCWA server. Check event.type.
             *
             */
            function UCWA() {
                var self = this instanceof UCWA ? this : inherit(UCWA.prototype);
                var eEvent = Event();
                var restored = Event();
                var pConnected = BoolProperty(false);
                var _xframe;
                var _repository;
                var _application;
                var mtchannels = {};
                var nReq = 0;
                var tInit = Task();
                var pInit;
                var XFrame = Internal.XFrame, AutoDiscovery = Internal.AutoDiscovery, Resource = Internal.Resource, Transport = Internal.Transport, Endpoint = Internal.Endpoint, Connection = Internal.Connection, Repository = Internal.Repository, Application = Internal.Application, MTChannel = Internal.MTChannel;
                //#region class methods
                /**
                 * Initializes the UCWA stack.
                 *
                 * If invoked without arguments, returns a promise that
                 * resolves after the client gets signed in.
                 */
                function init(options) {
                    if (options) {
                        assert(!pInit);
                        connect(options);
                    }
                    return tInit.promise;
                }
                function connect(options) {
                    var auth = options.auth;
                    var id = options.id; // UCWA's endpoint id
                    var client_id = options.client_id; // OAuth client_id
                    var oauth_uri = options.oauth_uri; // OAuth URI
                    var oauth_state = options.state; // OAuth state
                    var username = options.username;
                    var password = options.password;
                    var domain = options.domain; // auto d
                    var origins = options.origins; // auto d
                    var conf_uri = options.meeting; // conference URI
                    var root = options.root; // rel=root
                    var snapshot = options.snapshot; /// UCWA::getSnapshot
                    var culture = options.culture || 'en-us';
                    var version = 'SkypeWeb/' + ver + (options.version ? ' ' + options.version : '');
                    var throttle = getOption(options, 'throttle', 5); // the number of requests in the throttling queue            
                    var xframector = options.XFrame || XFrame;
                    var batchRetryDelay = getOption(options, 'batchRetryDelay', 5.0); // seconds
                    var maxBatchSize = getOptParamBound(options, 'maxBatchSize', 20); // UCWA limits batch size to 20 requests
                    var delay000 = options.delay000 || function () {
                        return function () {
                            // fixed delay of 1.5 seconds
                            return 1.5;
                        };
                    };
                    var delay503 = options.delay503 || function () {
                        var delay = 1;
                        return function () {
                            // exponetial back off with the 10 mins upper limit
                            if (delay > 600)
                                throw Exception('MaxRetryDelayReached');
                            else
                                return delay *= 1.5;
                        };
                    };
                    options = null; // reduce the visibility scope of this variable
                    var routes = map(origins || [null], function (origin) {
                        return Task.wait().then(function () {
                            var dfdroot, transport, endpoint, xframe, connection, repository, application, authfn;
                            if (snapshot)
                                snapshot = Repository.expandSnapshot(snapshot);
                            // in most cases the xframe URL can be inferred from the root URL
                            if (isString(origin)) {
                                origin = {
                                    origin: origin,
                                    xframe: URI(origin).path('/xframe').query('').hash('') + ''
                                };
                            }
                            xframe = xframector();
                            if (snapshot) {
                                xframe.src(snapshot.xframe[0]._links.self.href);
                            }
                            else if (!root) {
                                if (!domain) {
                                    domain =
                                        username ? username.match(/@(.+?)$/)[1] :
                                            conf_uri ? conf_uri.match(/@(.+?);/)[1] :
                                                null;
                                    if (!domain && !origins)
                                        throw Exception('NoFQDN');
                                }
                                dfdroot = AutoDiscovery({
                                    transport: transport,
                                    XFrame: xframector,
                                    xframe: xframe,
                                    domain: domain,
                                    origins: origin && [origin]
                                }).root;
                            }
                            else {
                                // these parameters are provided by UI, so
                                // a meaningful error message is required
                                assert(root.user, 'root.user URL is missing');
                                assert(root.xframe, 'root.xframe URL is missing');
                                xframe.src(root.xframe);
                                dfdroot = Resource('root:1', 'root')
                                    .addLink('user', root.user)
                                    .addLink('xframe', root.xframe)
                                    .set('internal', !!root.internal);
                            }
                            authfn = isFunction(auth) ? auth :
                                auth == 'passive' ? PassiveAuth() :
                                    password ? BasicAuth(username, password) :
                                        conf_uri ? AnonMeetingAuth(conf_uri) :
                                            client_id ? ImplicitAuth(xframe, client_id, oauth_uri, oauth_state) :
                                                IntegratedAuth();
                            transport = Transport(xframe, throttle, delay000, delay503);
                            endpoint = Endpoint({
                                batchRetryDelay: batchRetryDelay,
                                transport: transport,
                                auth: authfn,
                                restore: function () {
                                    // The handler of 404.ApplicationNotFound requests needs to be implemented
                                    // right on top of the auth layer, as its used by the batching layer and
                                    // by the event channel, and it's implementation needs to send the POST to
                                    // restore the app. The first requirement makes Ednpoint as the natural
                                    // place for this handler, while the second requirement makes Application as
                                    // the proper place. The `restore` function, which is essentially an indirect
                                    // reference from endpoint to application, is the least hacky way to solve this.
                                    // A better solution would be to merge Transport, Endpoint and Application.
                                    return application.restore().then(function () {
                                        restored.fire();
                                    });
                                }
                            });
                            connection = Connection(endpoint);
                            repository = Repository({
                                snapshot: snapshot,
                                connection: connection
                            });
                            application = Application({
                                maxBatchSize: maxBatchSize,
                                xframe: xframe,
                                endpoint: endpoint,
                                repository: repository,
                                connection: connection,
                                root: dfdroot,
                                id: id,
                                culture: culture,
                                version: version
                            });
                            return application.ready.then(function () {
                                // Application must subscribe to Connection first
                                // in order to receive events first and update the
                                // repository correspondingly before other event
                                // listeners get the event. This logic must be moved
                                // into Repository (it should take Connection as a ctor argument)
                                /* istanbul ignore next */
                                if (Settings.logEvents) {
                                    eEvent.observer(function (event) {
                                        var name = event.target.rel + ' ' + event.type;
                                        var ctx = event['in'];
                                        if (ctx)
                                            name += ' in ' + ctx.rel;
                                        debug.log('%c ' + name, 'color:magenta;font-weight:bold');
                                        debug.log(JSON.parse(event + ''));
                                    });
                                }
                                // This subscription has to be synchronous because async delivery of Connection events to UCWA object 
                                // combined with sync delivery of these events to Repository results in incorrect events to the model layer.
                                //
                                // If two related events refer to that same resource but carry a different resource content and if these 
                                // events arrive in the same batch we will wind up with the following chain:
                                //
                                //  1. Event 1 is handed to Repository - resource is saved in Repository and event.resource is replaced 
                                //     by a reference to the resource in the repository.
                                //  2. Event 1 delivery to UCWA is postponed until the next event cycle.
                                //  3. Event 2  is handed to Repository - resource is updated in Repository and event.resource is replaced 
                                //     by a reference to the resource in the repository. Now both Event 1 and 2 refer to the same resource 
                                //     copy in Repository.
                                //  4. Event 2  delivery to UCWA is postponed until the next event cycle.
                                //
                                // When Event 1 and 2 reach UCWA they both have the reference to the same resource content received in  
                                // Event2, which is wrong.
                                //
                                connection.event(function (event) {
                                    eEvent.fire(event);
                                });
                                connection.connected.changed(pConnected);
                                _xframe = xframe;
                                _repository = repository;
                                _application = application;
                            }).catch(function (err) {
                                xframe.reset();
                                throw err;
                            });
                        });
                    });
                    pInit = Task.waitAny(routes).finally(function () {
                        pInit = null;
                    });
                    pInit.then(function (res) { tInit.resolve(res); }, function (err) { tInit.reject(err); }, tInit.status);
                }
                function uninit(reason) {
                    if (pInit)
                        pInit.cancel(reason);
                    if (_xframe)
                        _xframe.reset();
                    pInit = null;
                    tInit = Task();
                    _xframe = null;
                    _repository = null;
                    _application = null;
                }
                function send(method, selector, options) {
                    var url = isString(selector) ? selector : get(selector).href;
                    var req, uri, query, promise, id = ++nReq;
                    if (options && options.query) {
                        uri = URI(url); // parse the URL
                        query = URI.Query(uri.query()); // parse the query part of the URL
                        extend(query, options.query); // amend it with the given query params
                        uri.query(query + ''); // change the query of the original URL
                        url = uri + ''; // serialize the URL with the amended query
                    }
                    req = extend(clone(options || {}), {
                        type: method,
                        url: url
                    });
                    /* istanbul ignore next */
                    if (Settings.logRequests) {
                        debug.log('%c -> ' + id + ' ' + method, 'color:blue;font-weight:bold', url);
                        if (req.data)
                            debug.log(req.data);
                    }
                    promise = _application.ajax(req);
                    /* istanbul ignore next */
                    if (Settings.logRequests) {
                        promise.then(function (rsp) {
                            var s;
                            debug.log('%c <- ' + id + ' ' + method, 'color:green;font-weight:bold', url);
                            if (rsp.href) {
                                s = rsp.getSnapshot();
                                // do not log user credentials if present 
                                delete s.userName;
                                delete s.password;
                                debug.log(s);
                            }
                        }, function (err) {
                            var rsp = err && err.rsp || {};
                            debug.log('%c <- ' + id + ' ' + method, 'color:red;font-weight:bold', url, rsp.status, rsp.statusText);
                            debug.log(err);
                        });
                    }
                    return promise;
                }
                function mtchannel(url) {
                    // All tabs in the multitab scenario share the same endpoint id,
                    // so it can be used to avoid unnecessary interference between
                    // unrelated tabs. The data channel doesn't have to use the same
                    // xframe that was used to connect to UCWA, but the domain of the
                    // xframe must be same as of in other tabs. This usually works because
                    // in all tabs autodiscovery results in the same UCWA's domain.
                    // If this appears to be not the case, then a separate dummy xframe
                    // with a known domain will need to be created.
                    return mtchannels[url] = mtchannels[url] ||
                        MTChannel(_xframe.send, _application.id() + ':' + url);
                }
                function get(selector, defaults) {
                    var r = find(selector);
                    if (!r || r.length < 1) {
                        if (defaults === null)
                            return null;
                        assert(false, 'The resource does not exist: ' + getSelName(selector));
                    }
                    assert(r.length < 2, 'There are ' + r.length + ' resources matching ' + getSelName(selector));
                    return r[0];
                }
                function find(selector) {
                    return isFunction(selector) ? _repository.find(selector) :
                        _repository.get(isString(selector) ? selector : selector.rel);
                }
                function exists(selector) {
                    return find(selector).length > 0;
                }
                function getSnapshot() {
                    var snapshot = _repository.getSnapshot();
                    // During auto discovery and sign in, UCWA may have redirected
                    // the client between pools a few times, each time giving a new
                    // xframe URL, so after sign in is completed, the repository may
                    // contain several rel=xframe resources and only one of them is used.            
                    snapshot.xframe = [{ _links: { self: { href: _xframe.src() } } }];
                    return snapshot;
                }
                /*
                 * Get value of the "revision" property associated with the given resource.
                 */
                function getRevisionOf(r) {
                    // the resource may not contain revision info due to lazy-loading,
                    // so have to load again if initially not found
                    var link = r.link('self');
                    return Task.wait().then(function () {
                        return +link.revision || r.dfdDebounced || (r.dfdDebounced = send('GET', r.href));
                    }).then(function () {
                        return +link.revision || 1; // default revision is 1
                    });
                }
                //#endregion
                function getSelName(selector) {
                    return isString(selector) ? selector : selector.rel;
                }
                function getOptParamBound(params, name, upperBound) {
                    var val = getOption(params, name, upperBound);
                    return val <= upperBound ? val : upperBound;
                }
                return extend(self, {
                    init: async(init),
                    uninit: uninit,
                    send: async(send),
                    get: get,
                    find: find,
                    exists: exists,
                    getSnapshot: getSnapshot,
                    getRevisionOf: getRevisionOf,
                    mtchannel: mtchannel,
                    event: eEvent.observer,
                    restored: restored.observer,
                    connected: pConnected.asReadOnly()
                });
            }
            Stack.UCWA = UCWA;
            extend(UCWA.prototype, {
                wait: function (pattern) {
                    var ucwa = this, task;
                    var pres = pattern.resource;
                    var ptar = pattern.target;
                    var ptyp = pattern.type;
                    var psts = pattern.status;
                    function matches(event) {
                        var eres = event.resource;
                        var etar = event.target;
                        var etyp = event.type;
                        var ests = event.status;
                        return !(etyp != ptyp ||
                            psts && psts != ests ||
                            etar.rel != ptar.rel ||
                            ptar.href && etar.href != ptar.href ||
                            isFunction(pres) && !pres(eres) ||
                            isObject(pres) && !all(pres, function (v, n) { return eres.get(n) == v; }));
                    }
                    function handler(event) {
                        if (matches(event)) {
                            ucwa.event.off(handler);
                            task.resolve(event);
                        }
                    }
                    ucwa.event(handler);
                    task = Task(ptar.rel + ' ' + ptyp, {
                        mode: 'sync',
                        cancel: function (reason) {
                            ucwa.event.off(handler);
                            task.reject(reason);
                        }
                    });
                    return task.promise;
                }
            });
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=ucwa.js.map

/// <reference path="./utils.ts" />
/**
 * Encapsulates the native LWA media plugin.
 *
 * PluginManager:
 *
 *      loads/unloads the plugin into the browser, controls the plugin lifetime and allows the application to
 *      load individual plugin components
 *
 *
 * PluginComponent:
 *
 *      A wrapper around a plugin component. Each component implements a certain subset of plugin functionality,
 *      for example: Media configuration, Tuning Wizard, Audio/Video Call, App sharing, etc.
 *
 *
 * PluginObject:
 *
 *      A wrapper around a platform-specific scriptable plugin object which is at the heart of each plugin component.
 *      It is a COM object for IE and a scriptable plugin object for NPAPI browsers.
 *
 *
 * PluginDataHandler:
 *
 *      A static object responsible for marshalling data between JS and the native plugin.
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            
            var Settings = Skype.Web.Settings;
            //#region Imports (from Skype.Web.Utils)
            var Utils = Skype.Web.Utils;
            var isArray = Utils.isArray;
            var isString = Utils.isString;
            var isBoolean = Utils.isBoolean;
            var isNotEmptyString = Utils.isNotEmptyString;
            var isNumber = Utils.isNumber;
            var isVoid = Utils.isVoid;
            var extend = Utils.extend;
            var Event = Utils.Event;
            var guid = Utils.guid;
            var assert = Utils.assert;
            var Enum = Utils.Enum;
            var StringEnum = Utils.StringEnum;
            var Property = Utils.Property;
            var singleton = Utils.singleton;
            var Task = Utils.Task;
            var async = Utils.async;
            var check = Utils.check;
            var debug = Utils.debug;
            var Exception = Utils.Exception;
            Utils = null;
            //#endregion
            function log() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (Settings.logMedia)
                    debug.log.apply(null, args);
            }
            Media.log = log;
            //#region LocalUtils
            /**
             * A simple string formatter - replaces {ordinal} in the format string with the argument at
             * the ordinal position in the param list following the format string
             *
             * @param {string} format - the format string
             * @param variable list of parameters to be inserted into the format string
             *
             * @example
             *
             *      var s = formatString('Xbox {0} or {1}', 'One', 360);
             *      assert(s == 'Xbox One or 360');
             */
            function formatString(format) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (arguments.length == 0)
                    throw new Error('Invalid arguments');
                return format.replace(/{(\d+)}/g, function (substr, index) {
                    // substr is the found substring, index is the first capture group
                    // ex: substr is '{0}', index is '0'
                    return (index in args) ? args[index] : substr;
                });
            }
            Media.formatString = formatString;
            //#endregion
            //#region UserAgent
            /**
             * A singleton object that aggregates platform and browser information from
             * window.navigator properties.
             *
             *  @method isIE - returns true if this is Internet Explorer(IE) browser, false otherwise
             *  @method isSupportedIE - returns true if this is a supported version of IE, false otherwise
             *  @method isWindows - return true if this is a Windows OS, false otherwise
             *  @method isMac - return true if this is a Mac OS, false otherwise
             *  @method is32bit - return true if this is a 32-bit browser, false otherwise
             *  @method is64bit - return true if this is a 64-bit browser, false otherwise
             *  @method reset - resets the state of UserAgent. Platform/browser info will be read anew when any
             *                  of the other methods are called again. This method is needed for unit testing only.
             *  @example
             *      if (UserAgent().isWindows() && UserAgent().is64bit())
             *         // do something specific to 64-bit Windows
             */
            Media.UserAgent = singleton(function () {
                var OsType = Enum('Unknown', 'Windows', 'Mac', 'Linux', 'Mobile'), BrowserBitness = Enum('Unknown', 'Win32', 'Wow64', 'Win64'), BrowserName = Enum('IE', 'Other');
                var browserName = BrowserName.Other, browserBitness = BrowserBitness.Unknown, osType = OsType.Unknown;
                var isInitialized = false;
                function init() {
                    if (isInitialized)
                        return;
                    var userAgent = window.navigator.userAgent.toLowerCase();
                    var platform = window.navigator.platform ? window.navigator.platform.toLowerCase() : '';
                    // detect IE
                    if (userAgent.match(/msie \d+\.\d+/)) {
                        browserName = BrowserName.IE;
                    }
                    else if (userAgent.match(/trident\/\d+\.\d+/) &&
                        userAgent.match(/\brv:\d+\.\d+/)) {
                        // IE11 dropped MSIE token, its user-agent string looks like: 
                        // "Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko"
                        browserName = BrowserName.IE;
                    }
                    // detect browser bitness on windows
                    if (userAgent.match(/wow64/))
                        browserBitness = BrowserBitness.Wow64;
                    else if (platform.match(/win64/) || userAgent.match(/win64/))
                        browserBitness = BrowserBitness.Win64;
                    else if (platform.match(/win32/))
                        browserBitness = BrowserBitness.Win32;
                    // detect OS
                    if (userAgent.match(/mobi/))
                        osType = OsType.Mobile;
                    else if (userAgent.match(/windows nt/) || browserBitness != BrowserBitness.Unknown)
                        osType = OsType.Windows;
                    else if (platform.match(/mac/) || userAgent.match(/macintosh/))
                        osType = OsType.Mac;
                    else if (platform.match(/linux/) || userAgent.match(/linux/))
                        osType = OsType.Linux;
                    isInitialized = true;
                }
                function isIE() {
                    init();
                    return browserName == BrowserName.IE;
                }
                function isSupportedIE() {
                    return (isIE() && document.documentMode); // IE8+
                }
                function isWindows() {
                    init();
                    return osType == OsType.Windows;
                }
                function isMac() {
                    init();
                    return osType == OsType.Mac;
                }
                function is64bit() {
                    init();
                    return browserBitness == BrowserBitness.Win64;
                }
                function is32bit() {
                    init();
                    return browserBitness == BrowserBitness.Win32 ||
                        browserBitness == BrowserBitness.Wow64;
                }
                function reset() {
                    browserName = BrowserName.Other;
                    browserBitness = BrowserBitness.Unknown;
                    osType = OsType.Unknown;
                    isInitialized = false;
                }
                init();
                return {
                    isIE: isIE,
                    isSupportedIE: isSupportedIE,
                    isWindows: isWindows,
                    isMac: isMac,
                    is64bit: is64bit,
                    is32bit: is32bit,
                    reset: reset
                };
            });
            //#endregion UserAgent
            //#region BigInt
            /**
             * JavaScript supports signed integers |x| < 2^53. BigInt represents a signed 64-bit
             * integer (__int64 or "long long" in C++) as high and low 32-bit parts (+ sign)
             *
             * @constructor BigInt(string) - initialize the object from a string
             * @constructor BigInt(long) - initialize the object from a long
             * @constructor BigInt(high, low, [sign]) - initialize the object from high and low parts and an optional sign
             *
             * @method empty() - reset the object
             * @method fromString(string) - reset the object from a string
             * @method toString(string) - serialize the object to string
             *
             * @example
             *
             *   var bigInt = BigInt(1024, 2048);
             *   assert(bigInt.toString() == '1024,2048,false');
             *
             */
            function BigInt(_lo, _hi, _sign) {
                var high = 0, low = 0, isNegative = false;
                if (arguments.length == 1) {
                    if (isString(arguments[0]))
                        fromString(arguments[0]);
                    else if (isNumber(arguments[0]))
                        fromLong(arguments[0]);
                    else
                        throw new Error('invalid argument');
                }
                else if (arguments.length >= 2) {
                    assert(isNumber(arguments[0]));
                    assert(isNumber(arguments[1]));
                    assert(!arguments[2] || isBoolean(arguments[2]));
                    high = arguments[0];
                    low = arguments[1];
                    isNegative = arguments[2] || false;
                }
                function empty() {
                    high = 0;
                    low = 0;
                    isNegative = false;
                }
                function toString() {
                    return high + ',' + low + ',' + isNegative;
                }
                function fromString(str) {
                    assert(isString(str));
                    var args = str.split(',');
                    if (args.length < 2)
                        throw new Error('invalid argument format');
                    empty();
                    high = parseInt(args[0]);
                    low = parseInt(args[1]);
                    isNegative = sign(args[2]);
                }
                function sign(arg) {
                    var negative = false;
                    if (arg === undefined)
                        return false;
                    assert(isString(arg));
                    switch (arg) {
                        case 'true':
                            negative = true;
                            break;
                        case 'false':
                            negative = false;
                            break;
                        default:
                            throw new Error('invalid argument format');
                    }
                    return negative;
                }
                function fromLong(value) {
                    assert(isNumber(value));
                    if (value > 0x80000000 || value <= -0x80000000) {
                        throw new RangeError('out of range');
                    }
                    high = 0;
                    isNegative = false;
                    if (value < 0) {
                        value = -value;
                        isNegative = true;
                    }
                    low = value & 0xFFFFFFFF;
                }
                return {
                    toString: toString,
                    fromString: fromString,
                    empty: empty
                };
            }
            Media.BigInt = BigInt;
            //#endregion BigInt
            //#region ByteArray
            /**
             * Contains static methods for conversion of UTF-16 strings to UTF-8 byte arrays
             *
             * @method byteArrayToString - converts a UTF-8 byte array to a UTF-16 string
             * @method stringToByteArray - converts a UTF-16 string to a UTF-8 byte array
             */
            var ByteArray;
            (function (ByteArray) {
                /**
                 * Converts a byte array representation of a Unicode (UTF-8) string to a Unicode (UTF-16) string
                 */
                function byteArrayToString(value) {
                    assert(isArray(value));
                    var str = '', curByte, byte1, byte2, byte3, i = 0;
                    while (i < value.length) {
                        curByte = value[i];
                        if ((curByte < 0) || (curByte > 0xFF))
                            throw new Error('Unexpected utf8 byte');
                        // 1 byte, < 128, up to U+007F, ascii values
                        if (curByte < 0x80) {
                            str += String.fromCharCode(curByte);
                            i++;
                        }
                        else if ((curByte & 0xE0) == 0xC0) {
                            if ((i + 1) >= value.length)
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // extract 5 bits from curByte and 6 bits from byte1
                            str += String.fromCharCode(((curByte & 0x1F) << 6) | (byte1 & 0x3F));
                            i += 2;
                        }
                        else if ((curByte & 0xF0) == 0xE0) {
                            if (((i + 1) >= value.length) || ((i + 2) >= value.length))
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            byte2 = value[i + 2];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte2 < 0) || (byte2 > 0xFF) || ((byte2 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // extract 4 bits from curByte and 6 bits from byte1 and byte 2
                            str += String.fromCharCode(((curByte & 0x0F) << 12) | ((byte1 & 0x3F) << 6) | (byte2 & 0x3F));
                            i += 3;
                        }
                        else if ((curByte & 0xF8) == 0xF0) {
                            if (((i + 1) >= value.length) || ((i + 2) >= value.length) || ((i + 3) >= value.length))
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            byte2 = value[i + 2];
                            byte3 = value[i + 3];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte2 < 0) || (byte2 > 0xFF) || ((byte2 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte3 < 0) || (byte3 > 0xFF) || ((byte3 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // Extract 3 bits from curByte and 6 bits from byte1 and byte 2 and byte 3
                            var unicodeValue = ((curByte & 0x07) << 18) | ((byte1 & 0x3F) << 12) | ((byte2 & 0x3F) << 6) | (byte3 & 0x3F);
                            // From unicode.org utf faq
                            var lead_offset = 0xD800 - (0x10000 >> 10);
                            // Equivalent of - Subtract 0x10000, split into two 10-bit pieces
                            // Add D800 to the high 10 bit piece, Add DC00 to the low 10 bit piece
                            // to get the surrogate pairs
                            // From http://download.microsoft.com/download/2/8/6/2867ae90-9b10-4a6c-b70e-58238be9edc6/Supplementary%20Character%20Support%20in%20Microsoft%20Products_c.ppt
                            var lead = lead_offset + (unicodeValue >> 10);
                            var trail = 0xDC00 + (unicodeValue & 0x3FF);
                            str += String.fromCharCode(lead);
                            str += String.fromCharCode(trail);
                            i += 4;
                        }
                        else {
                            throw new Error('Illegal utf8 converter input');
                        }
                    }
                    return str;
                }
                ByteArray.byteArrayToString = byteArrayToString;
                /**
                 * Converts a UTF-16 string to a UTF-8 byte array
                 */
                function stringToByteArray(value) {
                    assert(isString(value));
                    var bytes = [];
                    var i = 0;
                    while (i < value.length) {
                        // JavaScript encodes strings in UTF-16 - each character is represented with one or two 16-bit values
                        // Sample - "\uD834\uDD2A" //U+1D12A represented by a UTF-16 surrogate pair
                        // Sample - "\uD800\uDC00" //U+10000 (65536) represented by a UTF-16 surrogate pair
                        // A surrogate pair needs to be converted into 4-byte utf-8
                        // Illegal to take each surrogate separately and convert into two 3-byte utf-8
                        var curChar = value.charCodeAt(i);
                        // 1 byte, < 128, upto U+007F, ascii values
                        if (curChar < 0x80) {
                            bytes.push(curChar);
                            i++;
                        }
                        else if (curChar < 0x800) {
                            // 11000000 | curchar >> 6
                            bytes.push((0xC0 | (curChar >> 6)));
                            // 10000000 | curChar & 00111111
                            bytes.push((0x80 | (curChar & 0x3F)));
                            i++;
                        }
                        else if (0xD800 <= curChar && curChar <= 0xDBFF) {
                            var highSurrogate = curChar;
                            if ((i + 1) >= value.length)
                                throw new Error('High Surrogate at the end of string');
                            var lowSurrogate = value.charCodeAt(i + 1);
                            if (!(0xDC00 <= lowSurrogate && lowSurrogate <= 0xDFFF))
                                throw new Error('High Surrogate followed by invalid low surrogate');
                            // From unicode.org utf faq
                            // (highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000
                            var surrogate_offset = 0x10000 - (0xD800 << 10) - 0xDC00;
                            var unicodeValue = (highSurrogate << 10) + lowSurrogate + surrogate_offset;
                            // 11110000 | (unicodeValue >> 18)
                            bytes.push(0xF0 | (unicodeValue >> 18));
                            // 10000000 | (unicodeValue >> 12) & 00111111
                            bytes.push(0x80 | ((unicodeValue >> 12) & 0x3F));
                            // 10000000 | (unicodeValue >> 6) & 00111111
                            bytes.push(0x80 | ((unicodeValue >> 6) & 0x3F));
                            // 10000000 | unicodeValue & 00111111
                            bytes.push(0x80 | (unicodeValue & 0x3F));
                            // Skip the next value (already account for the low surrogate)
                            i = i + 2;
                        }
                        else if (0xDC00 <= curChar && curChar <= 0xDFFF) {
                            throw new Error("Low Surrogate not preceded by high surrogate");
                        }
                        else if (curChar < 0x10000) {
                            // 11100000 | (curchar >> 12)
                            bytes.push(0xE0 | (curChar >> 12));
                            // 10000000 | (curchar >> 6) & 00111111
                            bytes.push(0x80 | ((curChar >> 6) & 0x3F));
                            // 10000000 | curChar & 00111111
                            bytes.push(0x80 | (curChar & 0x3F));
                            i++;
                        }
                        else {
                            throw new Error('Illegal utf8 converter input');
                        }
                    }
                    return bytes;
                }
                ByteArray.stringToByteArray = stringToByteArray;
            })(ByteArray = Media.ByteArray || (Media.ByteArray = {}));
            //#endregion ByteArray
            //#region Base64
            /**
             * Base64 encoder for Unicode (UTF-16) strings
             *
             * @method encode - converts a Unicode (UTF-16) string to a base64-encoded string
             * @method decode - converts a base64-encoded string to a Unicode (UTF-16) string
             *
             * @example
             *
             *      var base64str = Base64().encode('Hello');
             *      var str = Base64().decode(base64str);
             *      assert(str == 'Hello');
             */
            Media.Base64 = singleton(function () {
                var keyString = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                /**
                 * Converts a Unicode string to a Base64-encoded string
                 */
                function encode(str) {
                    if (isNotEmptyString(str)) {
                        var strArray = ByteArray.stringToByteArray(str);
                        return encodeBytes(strArray);
                    }
                    else
                        return str;
                }
                /**
                 * Converts a Base64-encoded string to a Unicode (UTF-16) string
                 */
                function decode(str) {
                    if (isNotEmptyString(str)) {
                        var strArray = decodeBytes(str);
                        return ByteArray.byteArrayToString(strArray);
                    }
                    else
                        return str;
                }
                function encodeBytes(input) {
                    assert(isArray(input));
                    var output = '';
                    var chr1, chr2, chr3, encoding1, encoding2, encoding3, encoding4, i = 0;
                    while (i < input.length) {
                        chr1 = input[i++];
                        chr2 = i < input.length ? input[i++] : 0;
                        chr3 = i < input.length ? input[i++] : 0;
                        // first six bits of the first character
                        encoding1 = chr1 >> 2;
                        // last two bits of the first character and first four of the second
                        encoding2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                        // last four of the second and first two of the third
                        encoding3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                        // last six of the third character
                        encoding4 = chr3 & 63;
                        if (i == input.length) {
                            if (mod(input.length, 3) == 1) {
                                encoding3 = 64;
                                encoding4 = 64;
                            }
                            else if (mod(input.length, 3) == 2) {
                                encoding4 = 64;
                            }
                        }
                        output += keyString.charAt(encoding1) + keyString.charAt(encoding2) +
                            keyString.charAt(encoding3) + keyString.charAt(encoding4);
                    }
                    return output;
                }
                function decodeBytes(input) {
                    assert(isNotEmptyString(input));
                    var output = [];
                    var chr1, chr2, chr3, encoding1, encoding2, encoding3, encoding4, i = 0;
                    while (i < input.length) {
                        encoding1 = keyString.indexOf(input.charAt(i++));
                        encoding2 = keyString.indexOf(input.charAt(i++));
                        encoding3 = keyString.indexOf(input.charAt(i++));
                        encoding4 = keyString.indexOf(input.charAt(i++));
                        chr1 = (encoding1 << 2) | (encoding2 >> 4);
                        chr2 = ((encoding2 & 15) << 4) | (encoding3 >> 2);
                        chr3 = ((encoding3 & 3) << 6) | encoding4;
                        output.push(chr1);
                        if (encoding3 != 64)
                            output.push(chr2);
                        if (encoding4 != 64)
                            output.push(chr3);
                    }
                    return output;
                }
                // fix for JavaScript modulo operation bug (wrong result for negative values)
                function mod(value, modulo) {
                    return ((value % modulo) + modulo) % modulo;
                }
                return {
                    encode: encode,
                    decode: decode
                };
            });
            //#endregion Base64
            //#region PluginDataHandler
            /**
             * Converts a list of data values to/from an xml representation
             *
             * This static object is used for marshalling data between js and the native
             * media plugin.
             *
             * Supported data types:
             *
             *     - boolean     <bool>true</bool>
             *     - number      <int>11</int> or <double>11.11</double>
             *     - string      <string>SGVsbG8=</string> (base64-encoded 'Hello')
             *     - bigint      <bigint>8,4,false</bigint>  // 8*2^32 + 4
             *
             * @example
             *
             *  11, Hello, false converts to
             *  <args>
             *      <int>11</int>
             *      <string>SGVsbG8=</string>
             *      <bool>false</bool>
             *  </args>
             *
             *  @method generateBlob - generates an XML DOM document from the argument list
             *  @method parseBlob - reconstructs the value list from its XML DOM document representation
             */
            var PluginDataHandler;
            (function (PluginDataHandler) {
                /**
                 * Builds an xml representation of a list of data values
                 */
                function generateBlob() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    try {
                        return PluginDataHandler.generateBlob.impl1.apply(null, args);
                    }
                    catch (error1) {
                        return PluginDataHandler.generateBlob.impl2.apply(null, args);
                    }
                }
                PluginDataHandler.generateBlob = generateBlob;
                var generateBlob;
                (function (generateBlob) {
                    function impl1() {
                        var doc, docRootNode, childNode, childValue, tagName, tagValue, xmls, xmlStr, err;
                        if (arguments.length == 0)
                            return '';
                        if (!document.implementation || !document.implementation.createDocument)
                            throw new Error('XML DOM API not supported by this browser');
                        try {
                            doc = document.implementation.createDocument('', '', null);
                            docRootNode = doc.createElement(PluginDataHandler.ROOT_TAG);
                            for (var i = 0; i < arguments.length; i++) {
                                switch (typeof arguments[i]) {
                                    case 'number':
                                        tagValue = arguments[i].toString();
                                        tagName = (tagValue.indexOf('.') == -1) ?
                                            PluginDataHandler.INT_TAG :
                                            PluginDataHandler.DOUBLE_TAG;
                                        break;
                                    case 'boolean':
                                        tagName = PluginDataHandler.BOOL_TAG;
                                        tagValue = arguments[i].toString();
                                        break;
                                    case 'string':
                                        tagName = PluginDataHandler.STRING_TAG;
                                        tagValue = Media.Base64().encode(arguments[i]);
                                        break;
                                    case 'object':
                                        tagName = PluginDataHandler.BIGINT_TAG;
                                        tagValue = arguments[i].toString();
                                        break;
                                    default:
                                        assert(false);
                                }
                                childNode = doc.createElement(tagName);
                                childValue = doc.createTextNode(tagValue);
                                childNode.appendChild(childValue);
                                docRootNode.appendChild(childNode);
                            }
                            xmls = new XMLSerializer();
                            xmlStr = xmls.serializeToString(docRootNode);
                            // free up doc memory
                            while (docRootNode.firstChild)
                                docRootNode.removeChild(docRootNode.firstChild);
                            docRootNode = null;
                            doc = null;
                        }
                        catch (error) {
                            err = new Error('Could not create xml');
                            err.inner = error;
                            throw err;
                        }
                        return xmlStr;
                    }
                    generateBlob.impl1 = impl1;
                    // IE8 does not have XML DOM API and this function serves
                    // as a fallback from PluginDataHandler.generateBlob.impl1
                    function impl2() {
                        var i, a, xml = '';
                        for (i = 0; i < arguments.length; i++) {
                            a = arguments[i];
                            switch (typeof a) {
                                case 'number':
                                    xml += (a | 0) == a ?
                                        '<int>' + a + '</int>' :
                                        '<double>' + a + '</double>';
                                    break;
                                case 'string':
                                    xml += '<string>' + Media.Base64().encode(a) + '</string>';
                                    break;
                                case 'boolean':
                                    xml += '<bool>' + a + '</bool>';
                                    break;
                                case 'object':
                                    xml += '<bigint>' + a + '</bigint>';
                                    break;
                            }
                        }
                        return xml && '<args>' + xml + '</args>';
                    }
                    generateBlob.impl2 = impl2;
                })(generateBlob = PluginDataHandler.generateBlob || (PluginDataHandler.generateBlob = {}));
                /**
                 * Returns a list of data values from its xml representation
                 */
                function parseBlob(str) {
                    try {
                        return PluginDataHandler.parseBlob.impl1(str);
                    }
                    catch (error) {
                        return PluginDataHandler.parseBlob.impl2(str);
                    }
                }
                PluginDataHandler.parseBlob = parseBlob;
                var parseBlob;
                (function (parseBlob) {
                    function impl1(str) {
                        assert(isString(str));
                        if (str == '')
                            return str;
                        var args = [], err;
                        try {
                            var xmlParser = new DOMParser();
                            var doc = xmlParser.parseFromString(str, 'application/xml');
                            var docRootNode = doc.firstChild;
                            if (docRootNode.nodeName != PluginDataHandler.ROOT_TAG)
                                throw new Error('Root node is not of correct type');
                            var childNodes = docRootNode.childNodes, childNode, val;
                            for (var i = 0; i < childNodes.length; i++) {
                                childNode = childNodes[i];
                                switch (childNode.nodeName) {
                                    case PluginDataHandler.INT_TAG:
                                        val = parseInt(childNode.firstChild.nodeValue);
                                        break;
                                    case PluginDataHandler.DOUBLE_TAG:
                                        val = parseFloat(childNode.firstChild.nodeValue);
                                        break;
                                    case PluginDataHandler.STRING_TAG:
                                        // In Firefox, strings longer than 4097 bytes are being divided into
                                        // multiple sub child nodes. So we need to accumulate data from all sub child
                                        // nodes instead of picking just the first child.
                                        val = '';
                                        for (var j = 0; j < childNode.childNodes.length; j++)
                                            val += childNode.childNodes[j].nodeValue;
                                        val = Media.Base64().decode(val);
                                        break;
                                    case PluginDataHandler.BOOL_TAG:
                                        val = childNode.firstChild.nodeValue;
                                        if (val == 'true')
                                            val = true;
                                        else if (val == 'false')
                                            val = false;
                                        else
                                            throw new Error('Incorrect bool type');
                                        break;
                                    case PluginDataHandler.BIGINT_TAG:
                                        val = BigInt(childNode.firstChild.nodeValue);
                                        break;
                                    default:
                                        throw new Error('Incorrect argument type');
                                }
                                args.push(val);
                            }
                            // free up doc memory
                            while (docRootNode.firstChild)
                                docRootNode.removeChild(docRootNode.firstChild);
                            doc.removeChild(docRootNode);
                            doc = null;
                        }
                        catch (error) {
                            err = new Error('Could not get data from xml');
                            err.inner = error;
                            throw err;
                        }
                        return args;
                    }
                    parseBlob.impl1 = impl1;
                    // IE8 does not have XML DOM API and this function serves
                    // as a fallback from PluginDataHandler.generateBlob.impl1
                    function impl2(str) {
                        var m, t, v, a = [], s = str.replace(/^<args>|<\/args>$/gmi, '');
                        while (m = s.match(/^<(\w+)>(.*?)<\/\1>/)) {
                            s = s.slice(m[0].length);
                            t = m[1]; // type
                            v = m[2]; // value
                            if (t == 'int')
                                a.push(+v);
                            if (t == 'bool')
                                a.push(v == 'true');
                            if (t == 'double')
                                a.push(+v);
                            if (t == 'string')
                                a.push(Media.Base64().decode(v));
                            if (t == 'bigint')
                                a.push(BigInt(v));
                        }
                        return a;
                    }
                    parseBlob.impl2 = impl2;
                })(parseBlob = PluginDataHandler.parseBlob || (PluginDataHandler.parseBlob = {}));
                // these constants are used in native plugin code 
                PluginDataHandler.ROOT_TAG = "args";
                PluginDataHandler.INT_TAG = "int";
                PluginDataHandler.BIGINT_TAG = "bigint";
                PluginDataHandler.DOUBLE_TAG = "double";
                PluginDataHandler.STRING_TAG = "string";
                PluginDataHandler.BOOL_TAG = "bool";
            })(PluginDataHandler = Media.PluginDataHandler || (Media.PluginDataHandler = {}));
            //#endregion PluginDataHandler
            //#region PluginEnums
            // matches enum values in the native plugin
            var PluginLoadResult = Enum('LoadSuccessful', 'NoInstanceManager', 'ComponentNotFound', 'ComponentLoadFailed', 'ComponentInitFailed', 'ComponentLoadCancelled');
            //#endregion PluginEnums
            //#region PluginMethodResult
            /**
             * Represents plugin method result
             */
            function PluginMethodResult(res) {
                var i, s = '0x', hr = res[0];
                for (i = 7; i >= 0; i--)
                    s += ((hr >> (i * 4)) & 15).toString(16);
                res.hresultstr = s;
                res.succeeded = res[0] >= 0;
                res.failed = res[0] < 0;
                res.hresult = res[0];
                return res;
            }
            Media.PluginMethodResult = PluginMethodResult;
            //#endregion PluginMethodResult
            //#region PluginManager
            /**
             * Manages native media plugin
             */
            Media.PluginManager = singleton(function () {
                var components = {}, pluginObj = null, state = Property({ value: Media.PluginManager.State.Deinitialized }), language, isRtl, loadTimerId = 0, loadTimeout = 5000, pingTimerId = 0, pingTimeout = 5000, task, isCanceled = false;
                /**
                 * Initializes PluginManager by creating PluginManager plugin object
                 *
                 * @param {string} specs.language - language, i.e. "en-us", "ru-ru"
                 * @param {bool}   specs.rtl - is a right-to-left script?
                 *
                 * @returns {Promise}
                 */
                function init(specs) {
                    if (state() == Media.PluginManager.State.Deinitialized) {
                        var id = '__mainPluginManager_' + guid().replace(/-/g, '_');
                        log('PluginManager::init - id = ' + id);
                        language = (specs && specs.language) || "en-us";
                        isRtl = (specs && specs.rtl) || false;
                        assert(!task || task.promise.state() != 'pending');
                        task = Task('Loading the media plugin.', {
                            cancel: function (reason) {
                                log('PluginManager::init canceled ' + id);
                                isCanceled = true;
                                stopLoadTimer();
                                cleanupPluginObject();
                                state.set(Media.PluginManager.State.Deinitialized);
                                task.reject(reason);
                            }
                        });
                        state.set(Media.PluginManager.State.Initializing);
                        pluginObj = PluginObject({
                            id: id,
                            managerId: '_'
                        });
                        pluginObj.event(onPluginObjectEvent, 'async');
                        pluginObj.state.changed(onPluginObjectState);
                        log('PluginManager::init - creating inner object');
                        try {
                            pluginObj.createInnerObject({
                                hide: true,
                                hookEvents: true,
                                inproc: false
                            });
                        }
                        catch (err) {
                            if (task.promise.state() == 'pending')
                                task.reject(err);
                        }
                    }
                    else {
                        // init has already been called and the plugin is either 
                        // initializing or is already initialized; in either case
                        // we will return an existing promise
                        assert(task);
                    }
                    return task.promise;
                }
                /**
                 * Uninitializes PluginManager by unloading all loaded components and
                 * the main plugin object
                 */
                function uninit() {
                    log('PluginManager::uninit');
                    if (state() == Media.PluginManager.State.Deinitialized)
                        return;
                    assert(!task || task.promise.state() != 'pending');
                    task = Task('Unloading the media plugin.');
                    try {
                        // unload components
                        for (var id in components)
                            components[id].unload();
                        pluginObj.innerObject().UnLoad();
                    }
                    catch (error) {
                        cleanupPluginObject();
                        state.set(Media.PluginManager.State.Deinitialized);
                        if (!isCanceled)
                            task.reject();
                    }
                    stopLoadTimer();
                    stopPingTimer();
                    return task.promise;
                }
                /**
                 * main plugin object cleanup
                 */
                function cleanupPluginObject() {
                    log('PluginManager::cleanupPluginObject');
                    if (isVoid(pluginObj))
                        return;
                    pluginObj.event.off(onPluginObjectEvent);
                    pluginObj.state.changed.off(onPluginObjectState);
                    pluginObj.destroyInnerObject();
                    pluginObj = null;
                }
                /**
                 * returns the identifier of the main plugin object
                 */
                function id() {
                    assert(pluginObj);
                    return pluginObj.id();
                }
                /**
                 * Creates a plugin component
                 */
                function createComponent(specs) {
                    assert(specs);
                    assert(isString(specs.type));
                    assert(isBoolean(specs.hide));
                    assert(isBoolean(specs.inproc));
                    assert(state() == Media.PluginManager.State.Initialized);
                    log('PluginManager::createComponent ' + specs.type);
                    extend(specs, { pluginManager: Media.PluginManager() });
                    var component = PluginComponent(specs);
                    var thisId = component.id();
                    var onComponentState = function (stateValue) {
                        log('PluginManager::onComponentState ' + stateValue);
                        if (stateValue == PluginComponent.State.Unloaded) {
                            if (components[thisId]) {
                                components[thisId].state.changed.off(onComponentState);
                                delete components[thisId];
                            }
                        }
                        else if (stateValue == PluginComponent.State.Loaded) {
                        }
                    };
                    // do not change the order of the next two statements - if you do, the immediate execution  
                    // of the component state event handler while component is 'Unloaded' will orphan the component 
                    component.state.changed(onComponentState);
                    components[thisId] = component;
                    return component;
                }
                /**
                 * main plugin object event handler
                 */
                function onPluginObjectEvent(type, data) {
                    var args = PluginDataHandler.parseBlob(data), arg0;
                    switch (type) {
                        case '__FxLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isNumber(arg0));
                            log('PluginManager::onPluginObjectEvent ' + type);
                            stopLoadTimer();
                            if (arg0 == PluginLoadResult.LoadSuccessful &&
                                state() == Media.PluginManager.State.Initializing) {
                                state.set(Media.PluginManager.State.Initialized);
                                startPingTimer();
                                task.resolve();
                            }
                            else {
                                //TODO: examine arg0 to determine the failure reason
                                cleanupPluginObject();
                                state.set(Media.PluginManager.State.Deinitialized);
                                if (!isCanceled)
                                    task.reject();
                            }
                            break;
                        case '__FxUnLoadComplete':
                            assert(args.length == 0);
                            log('PluginManager::onPluginObjectEvent ' + type);
                            stopLoadTimer();
                            stopPingTimer();
                            cleanupPluginObject();
                            state.set(Media.PluginManager.State.Deinitialized);
                            if (!isCanceled)
                                task.resolve();
                            break;
                        case '__FxComponentLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isString(arg0));
                            log('PluginManager::onPluginObjectEvent ' + type + ' ' + arg0);
                            if (components[arg0]) {
                                components[arg0].onLoaded();
                            }
                            break;
                        case '__FxComponentUnLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isString(arg0));
                            log('PluginManager::onPluginObjectEvent ' + type + ' ' + arg0);
                            if (components[arg0])
                                components[arg0].onUnloaded();
                            break;
                        case '__FxPing':
                            startPingTimer();
                            break;
                    }
                }
                /**
                 * main plugin object state change event handler
                 */
                function onPluginObjectState(value) {
                    log('PluginManager::onPluginObjectState ' + value);
                    switch (value) {
                        case PluginObject.State.None:
                            // initial state - ignore
                            break;
                        case PluginObject.State.Created:
                            // nothing interesting - ignore
                            break;
                        case PluginObject.State.Attached:
                            window.setTimeout(loadManager, 0);
                            break;
                        case PluginObject.State.NotInstalled:
                            cleanupPluginObject();
                            state.set(Media.PluginManager.State.Deinitialized);
                            if (!isCanceled && task.promise.state() == 'pending')
                                task.reject(Exception('MediaPluginNotInstalled'));
                            break;
                        default:
                            stopLoadTimer();
                            cleanupPluginObject();
                            state.set(Media.PluginManager.State.Deinitialized);
                    }
                }
                /**
                 * Loads plugin component manager
                 */
                function loadManager() {
                    log('PluginManager::loadManager');
                    if (state() != Media.PluginManager.State.Initializing ||
                        pluginObj.state() != PluginObject.State.Attached)
                        return;
                    var options = PluginDataHandler.generateBlob(language, isRtl);
                    try {
                        startLoadTimer();
                        pluginObj.innerObject().Load('__pluginFx', options);
                    }
                    catch (error) {
                        stopLoadTimer();
                        cleanupPluginObject();
                        state.set(Media.PluginManager.State.Deinitialized);
                    }
                }
                /**
                 * Checks the existence of the main plugin object
                 */
                function pluginObjectExists() {
                    var exists = false;
                    try {
                        exists = pluginObj.innerObject().CheckExistence();
                    }
                    catch (error) { }
                    return exists;
                }
                function startLoadTimer() {
                    stopLoadTimer();
                    loadTimerId = window.setTimeout(onLoadTimeout, loadTimeout);
                }
                function stopLoadTimer() {
                    if (loadTimerId != 0) {
                        window.clearTimeout(loadTimerId);
                        loadTimerId = 0;
                    }
                }
                function onLoadTimeout() {
                    if (pluginObjectExists()) {
                        startLoadTimer();
                    }
                    else {
                        stopLoadTimer();
                        cleanupPluginObject();
                        state.set(Media.PluginManager.State.Deinitialized);
                    }
                }
                function startPingTimer() {
                    stopPingTimer();
                    pingTimerId = window.setTimeout(onPingTimeout, pingTimeout);
                }
                function stopPingTimer() {
                    if (pingTimerId != 0) {
                        window.clearTimeout(pingTimerId);
                        pingTimerId = 0;
                    }
                }
                function onPingTimeout() {
                    if (Media.UserAgent().isMac()) {
                        //On mac there is no native timeout, so we use this timer to track the existence of the plugin
                        startPingTimer();
                    }
                    else {
                        //On windows this will get hit if the plugin loaded/pinged once but not again for 5 seconds.
                        stopPingTimer();
                    }
                    if (!pluginObjectExists())
                        uninit();
                }
                return {
                    init: async(init),
                    uninit: async(uninit),
                    createComponent: createComponent,
                    state: state.asReadOnly(),
                    id: id
                };
            });
            Media.PluginManager.State = Enum('Deinitialized', 'Deinitializing', 'Initializing', 'Initialized');
            //#endregion PluginManager
            //#region PluginComponent
            /**
             * Wraps an individual native plugin component like MediaPlatformConfig or AVComponent
             *
             * @method {string} id() - returns component id
             * @method load() - loads component
             * @method unload() - unloads component
             * @property {PluginComponent.State} state - component state
             * @event event - raised by a contained plugin object
             */
            function PluginComponent(specs) {
                assert.args(specs, {
                    type: 'String',
                    hide: 'Boolean',
                    inproc: 'Boolean'
                });
                assert(specs.type == 'MediaPlatformConfig' || specs.type == 'AVComponent' ||
                    specs.type == 'VideoUI' || specs.type == 'TuningWizard' ||
                    specs.type == 'AppShareCore' || specs.type == 'AppShareViewerUI');
                var state = Property({ value: PluginComponent.State.Unloaded }), event = Event(), pluginMgr, pluginObj, parent, loadParams = [], task, isCanceled = false;
                pluginMgr = specs.pluginManager;
                pluginObj = PluginObject({
                    id: '_' + specs.type,
                    managerId: pluginMgr.id()
                });
                pluginObj.event(onPluginObjectEvent, 'async');
                pluginObj.state.changed(onPluginObjectState);
                /**
                 * Returns component id
                 */
                function id() {
                    return (pluginObj && pluginObj.id()) || "";
                }
                /**
                 * Starts loading plugin component
                 */
                function load() {
                    log('PluginComponent::load ' + id());
                    assert(state() == PluginComponent.State.Unloaded, 'invalid component state');
                    assert(pluginMgr.state() == Media.PluginManager.State.Initialized);
                    assert(!task || task.promise.state() != 'pending');
                    state.set(PluginComponent.State.Loading);
                    task = Task('Loading ' + specs.type + '.', {
                        cancel: function (reason) {
                            log('PluginComponent::load canceled ' + id());
                            isCanceled = true;
                            unload();
                            task.reject(reason);
                        }
                    });
                    // TODO: figure why LWA merges options passed to this method with ctor options
                    //extend the array 
                    loadParams = [].slice.call(arguments, 0);
                    try {
                        pluginObj.createInnerObject({
                            hide: specs.hide,
                            hookEvents: true,
                            inproc: specs.inproc
                        });
                    }
                    catch (err) {
                        if (task.promise.state() == 'pending')
                            task.reject(err);
                    }
                    return task.promise;
                }
                /**
                 * Unloads component
                 */
                function unload() {
                    log('PluginComponent::unload ' + id());
                    if (state() == PluginComponent.State.Loading ||
                        state() == PluginComponent.State.Loaded) {
                        state.set(PluginComponent.State.Unloading);
                        try {
                            pluginObj.innerObject().UnLoad();
                        }
                        catch (error) {
                            debugger;
                            cleanupPluginObject();
                            state.set(PluginComponent.State.Unloaded);
                        }
                    }
                }
                /**
                 * Called by PluginManager upon receiving the __FxComponentLoadComplete event
                 */
                function onLoaded() {
                    log('PluginComponent::onLoaded ' + id());
                    assert(pluginObj);
                    pluginObj.onObjectLoaded();
                }
                /**
                 * Called by PluginManager upon receiving the __FxComponentUnLoadComplete event
                 */
                function onUnloaded() {
                    log('PluginComponent::onUnloaded ' + id());
                    assert(pluginObj);
                    pluginObj.onObjectUnloaded();
                }
                /**
                 * Sets the hosting DOM element for a visible component
                 */
                function setContainer(parentElem) {
                    check(!specs.hide, 'setContainer called for a hidden component');
                    check(state() != PluginComponent.State.Loaded, 'setContainer called after component is already loaded');
                    parent = parentElem;
                    if (state() == PluginComponent.State.Loading &&
                        pluginObj.state() == PluginObject.State.Created)
                        pluginObj.attach(parent, true);
                }
                /**
                 * Handles native plugin object events
                 */
                function onPluginObjectEvent(type, data) {
                    var args = PluginDataHandler.parseBlob(data), arg0;
                    log('%c' + id() + ' ' + type, 'color:blue', args);
                    switch (type) {
                        case '__FxLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isNumber(arg0));
                            if (arg0 == PluginLoadResult.LoadSuccessful &&
                                state() == PluginComponent.State.Loading) {
                                if (!isCanceled)
                                    task.resolve();
                                state.set(PluginComponent.State.Loaded);
                                setLogLevel(PluginComponent.LogLevel.Error |
                                    PluginComponent.LogLevel.Info);
                            }
                            else {
                                //TODO: examine arg0 to determine the failure reason
                                cleanupPluginObject();
                                if (!isCanceled)
                                    task.reject(arg0);
                                state.set(PluginComponent.State.Unloaded);
                            }
                            break;
                        case '__FxUnLoadComplete':
                            assert(args.length == 0);
                            cleanupPluginObject();
                            state.set(PluginComponent.State.Unloaded);
                            break;
                        default:
                            event.fire({ type: type, args: args });
                            break;
                    }
                }
                /**
                 * Plugin object state change event handler
                 */
                function onPluginObjectState(value) {
                    log('PluginComponent::onPluginObjectState ' + id() + ' ' + value);
                    switch (value) {
                        case PluginObject.State.None:
                            // initial state - ignore
                            break;
                        case PluginObject.State.Created:
                            // attach the div element hosting the visible component to the parent DOM element
                            if (!specs.hide && !isVoid(parent))
                                pluginObj.attach(parent, true);
                            break;
                        case PluginObject.State.Attached:
                            // load component
                            window.setTimeout(loadComponent, 0);
                            break;
                        case PluginObject.State.Destroyed:
                            state.set(PluginComponent.State.Unloaded);
                            break;
                        default:
                            cleanupPluginObject();
                            state.set(PluginComponent.State.Unloaded);
                    }
                }
                /**
                 * Loads component for real
                 */
                function loadComponent() {
                    log('PluginComponent::loadComponent ' + id());
                    assert(state() == PluginComponent.State.Loading);
                    assert(pluginObj.state() == PluginObject.State.Attached);
                    var args;
                    try {
                        args = PluginDataHandler.generateBlob.apply(null, loadParams);
                        pluginObj.innerObject().Load(specs.type, args);
                    }
                    catch (error) {
                        debugger;
                        cleanupPluginObject();
                        state.set(PluginComponent.State.Unloaded);
                    }
                }
                /**
                 * plugin object cleanup
                 */
                function cleanupPluginObject() {
                    log('PluginComponent::cleanupPluginObject ' + id());
                    if (pluginObj) {
                        pluginObj.event.off(onPluginObjectEvent);
                        pluginObj.state.changed.off(onPluginObjectState);
                        pluginObj.destroyInnerObject();
                        pluginObj = null;
                    }
                }
                /**
                 * Invokes component method
                 *
                 * @param {string} method - method name
                 * @param {arguments} - list of method parameters
                 *
                 * @returns [] - results array
                 */
                function invoke(method) {
                    assert(pluginObj);
                    assert(isNotEmptyString(method));
                    assert(state() == PluginComponent.State.Loaded);
                    var args = [].slice.call(arguments, 1), strArgs, strRes, res, ret;
                    log('PluginComponent::invoke %c' + method, 'color:red', args, id());
                    try {
                        strArgs = PluginDataHandler.generateBlob.apply(null, args);
                        strRes = pluginObj.innerObject().ProcessMethod(method, strArgs);
                        res = PluginDataHandler.parseBlob(strRes);
                        ret = PluginMethodResult(res);
                    }
                    catch (error) {
                        log(id() + ' error executing ' + method + ' ' + error.message);
                        throw error;
                    }
                    if (ret.failed)
                        throw new Error(method + ' : error = ' + ret.hresultstr);
                    return ret;
                }
                /**
                 * Sets logger level
                 * @param {Number} level - logger level, may be a combo of any levels defined by
                 *                         PluginComponent.LogLevel enumeration
                 */
                function setLogLevel(level) {
                    check(level > 0 && level <= PluginComponent.LogLevel.All, 'Invalid level');
                    if (pluginObj)
                        try {
                            pluginObj.innerObject().SetLogLevel(level);
                        }
                        catch (error) {
                            log('SetLogLevel(' + level + ') failed: ', error);
                        }
                }
                return {
                    id: id,
                    state: state.asReadOnly(),
                    load: load,
                    unload: unload,
                    onLoaded: onLoaded,
                    onUnloaded: onUnloaded,
                    event: event.observer,
                    setContainer: setContainer,
                    setLogLevel: setLogLevel,
                    invoke: invoke
                };
            }
            Media.PluginComponent = PluginComponent;
            var PluginComponent;
            (function (PluginComponent) {
                PluginComponent.State = Enum('Unloaded', 'Unloading', 'Loading', 'Loaded');
                PluginComponent.UnloadReason = Enum('None', 'CreateFailed', 'LoadFailed', 'UserInitiated', 'PluginInitiated', 'PluginClosedUnexpectedly');
                PluginComponent.LogLevel = {
                    'Error': 1,
                    'Info': 2,
                    'Noise': 4,
                    'All': 1 | 2 | 4
                };
            })(PluginComponent = Media.PluginComponent || (Media.PluginComponent = {}));
            //#endregion PluginComponent
            //#region PluginObject
            /**
             * Wraps an LWA plugin object instance created by either <object> (ActiveX control) or
             * <embed> (NPAPI plugin) tag
             *
             * @property {PluginObject.State} state - returns plugin object state
             *
             * @method innerObject - returns the DOM object representing the plugin object
             * @method {string} id - returns object id
             * @method createInnerObject - creates the plugin DOM object
             * @method destroyInnerObject - destroys the plugin DOM object
             * @method attach(parent, hookEvents) - attaches a visible plugin DOM object to the parent DOM element and
             *                                      optionally hooks up object events
             * @method onObjectLoaded - called by the wrapping PluginComponent after component is loaded
             * @method onObjectUnLoaded - called by the wrapping PluginComponent after component is unloaded
             * @event  event - raised by native plugin object
             *
             * @example
             *
             *    var po = PluginObject( {id: 'mainPluginObject', managerId: '_'} );
             *    po.event(onPOEvent);
             *    po.state.changed(onPOStateChanged);
             *    po.createInnerObject({ hide: true, hookEvents: true, inproc: false });
             */
            function PluginObject(specs) {
                var state = Property({ value: PluginObject.State.None }), id = ((specs && specs.id) || '_plugin') + '_' + PluginObject.nextCount(), managerId = (specs && specs.managerId) ? specs.managerId : '_', event = Event(), div, innerObject, isObjectLoaded = false, hookEvents = false, _self;
                function getInnerObject() {
                    return (state() == PluginObject.State.Attached) ? innerObject : null;
                }
                function isManager() {
                    return managerId == '_';
                }
                /**
                 * Creates the scriptable plugin object
                 */
                function createInnerObject(options) {
                    log('PluginObject::createInnerObject ' + id);
                    assert(options);
                    assert(!isVoid(options.hide));
                    assert(!isVoid(options.hookEvents));
                    assert(!isVoid(options.inproc));
                    // we can start from uninitialized state only
                    assert(state() == PluginObject.State.None, 'invalid state');
                    // create html tag that embeds the plugin object
                    var tagHtml = getPluginObjectTag({
                        id: id,
                        managerId: managerId,
                        inproc: options.inproc,
                        logLevel: Media.UserAgent().isIE() ? 1 : 0
                    });
                    // create a "div" element to host that object tag
                    div = options.hide ? createHiddenWrapper(tagHtml) :
                        createWrapper(tagHtml);
                    log('PluginObject::createInnerObject ' + id + ' ' + div);
                    state.set(PluginObject.State.Created);
                    // if the object is hidden (i.e. the caller does not care where it is hosted) 
                    // attach our "div" element to the document.body
                    if (options.hide) {
                        attach(document.body, options.hookEvents);
                    }
                }
                /**
                 * Destroys the scriptable plugin object
                 */
                function destroyInnerObject() {
                    log('PluginObject::destroyInnerObject ' + id);
                    cleanup();
                    state.set(PluginObject.State.Destroyed);
                }
                /**
                 * Removes the scriptable plugin object from the DOM tree
                 */
                function cleanup() {
                    log('PluginObject::cleanup ' + id);
                    //window.setTimeout(function () {
                    try {
                        if (div)
                            div.parentNode.removeChild(div);
                    }
                    catch (error) {
                        log(error.message);
                    }
                    div = null;
                    //}, 0);
                    innerObject = null;
                    isObjectLoaded = false;
                    hookEvents = false;
                }
                /**
                 * Attaches the "div" element containing the plugin object tag to the document body
                 */
                function attach(parent, fHookEvents) {
                    log('PluginObject::attach ' + id);
                    assert(state() == PluginObject.State.Created);
                    assert(!isVoid(fHookEvents));
                    try {
                        parent.appendChild(div);
                        innerObject = div.firstChild;
                        if (isVoid(innerObject))
                            throw new Error('object missing');
                    }
                    catch (error) {
                        cleanup();
                        state.set(PluginObject.State.AttachFailed);
                        return;
                    }
                    hookEvents = fHookEvents;
                    // The manager plugin object is good to go upon creation, while plugin objects representing
                    // components should wait till components are actually loaded.
                    if (isManager()) {
                        isObjectLoaded = true;
                        validateAndAttachEvents();
                    }
                }
                /**
                 * Validates the created object and attaches events
                 * @remark this is the first place where we start calling methods of the native plugin object
                 */
                function validateAndAttachEvents() {
                    log('PluginObject::validateAndAttachEvents ' + id);
                    // wait for the correct state
                    if (!innerObject || !isObjectLoaded)
                        return;
                    // check plugin object existence by making a plugin call
                    try {
                        if (!innerObject.CheckExistence()) {
                            cleanup();
                            state.set(PluginObject.State.ExistenceCheckFailed);
                            return;
                        }
                    }
                    catch (error) {
                        cleanup();
                        state.set(PluginObject.State.NotInstalled, error);
                        return;
                    }
                    // start listening to plugin object events
                    if (hookEvents) {
                        try {
                            // OnEvent and OnPing are LWA plugin callbacks
                            innerObject.OnEvent = eventHandler;
                            innerObject.OnPing = pingHandler;
                        }
                        catch (error) {
                            cleanup();
                            state.set(PluginObject.State.AttachFailed, error);
                            return;
                        }
                    }
                    state.set(PluginObject.State.Attached);
                }
                /**
                 * Called by the PluginComponent after it is loaded
                */
                function onObjectLoaded() {
                    log('PluginObject::onObjectLoaded ' + id);
                    if (!isManager()) {
                        isObjectLoaded = true;
                        //need to delay the calling of this so that the entire
                        //path to the plugin is first freed and the loading is
                        //finalized before starting to call methods on the plugin
                        window.setTimeout(validateAndAttachEvents, 0);
                    }
                }
                /**
                 * Called by the PluginComponent after it is unloaded
                 */
                function onObjectUnloaded() {
                    log('PluginObject::onObjectUnloaded ' + id);
                    if (!isManager()) {
                        isObjectLoaded = false;
                        //need to delay the calling of this so that the entire
                        //path to the plugin is first freed and the loading is
                        //finalized before starting to call methods on the plugin
                        //window.setTimeout(destroyInnerObject, 0);
                        destroyInnerObject();
                    }
                }
                /**
                 * Handles native plugin object events
                 */
                function eventHandler(type, data) {
                    // if you want to see raw xml data add + ' ' + trim(data) to the output
                    // log('PluginObject::eventHandler - ' + id + ' ' + type); 
                    event.fire(type, data);
                }
                /**
                 * Handles native plugin object pings
                */
                function pingHandler() {
                    try {
                        innerObject.PingResponse();
                        event.fire('__FxPing', '');
                    }
                    catch (error) {
                        destroyInnerObject();
                        return false;
                    }
                    return true;
                }
                /**
                 * Verifies that LWA NPAPI plugin is installed
                 */
                function isNpPluginInstalled() {
                    return PluginObject.LwaPlugin.MIME_TYPE in window.navigator.mimeTypes;
                }
                /**
                 * Creates an <embed> tag for the NPAPI plugin or an <object> tag for the ActiveX control
                 */
                function getPluginObjectTag(params) {
                    assert(params);
                    var tagHtml;
                    if (Media.UserAgent().isIE()) {
                        assert(Media.UserAgent().isWindows());
                        if (Media.UserAgent().is32bit()) {
                            tagHtml = formatString(PluginObject.IE_HTML_TEMPLATE, params.id, PluginObject.LwaPlugin.CLSID, params.managerId, params.inproc, params.logLevel);
                        }
                        else if (Media.UserAgent().is64bit()) {
                            tagHtml = formatString(PluginObject.IE_HTML_TEMPLATE, params.id, PluginObject.LwaPlugin.CLSID64, params.managerId, params.inproc, params.logLevel);
                        }
                        else
                            throw Exception('UnsupportedBrowser');
                    }
                    else {
                        assert(Media.UserAgent().isWindows() || Media.UserAgent().isMac());
                        // we can quickly check whether the plugin is installed
                        if (!isNpPluginInstalled()) {
                            state.set(PluginObject.State.NotInstalled);
                            throw Exception('MediaPluginNotInstalled');
                        }
                        tagHtml = formatString(PluginObject.FF_HTML_TEMPLATE, params.id, PluginObject.LwaPlugin.MIME_TYPE, params.managerId, params.inproc, params.logLevel);
                    }
                    return tagHtml;
                }
                /**
                 * Creates a hidden "div" element containing the passed-in html fragment
                 */
                function createHiddenWrapper(html) {
                    var div = document.createElement('div');
                    div.style.position = 'absolute';
                    div.style.width = '1px';
                    div.style.height = '1px';
                    div.style.left = '-100px';
                    div.style.top = '0px';
                    div.style.overflow = 'hidden';
                    div.style.visibility = 'hidden';
                    div.innerHTML = html;
                    return div;
                }
                /**
                 * Creates a visible "div" element containing the passed-in html fragment
                 */
                function createWrapper(html) {
                    var div = document.createElement('div');
                    div.style.width = '100%';
                    div.style.height = '100%';
                    div.innerHTML = html;
                    return div;
                }
                _self = {
                    id: function () { return id; },
                    state: state.asReadOnly(),
                    innerObject: getInnerObject,
                    createInnerObject: createInnerObject,
                    destroyInnerObject: destroyInnerObject,
                    attach: attach,
                    event: event.observer,
                    onObjectLoaded: onObjectLoaded,
                    onObjectUnloaded: onObjectUnloaded
                };
                return _self;
            }
            Media.PluginObject = PluginObject;
            var PluginObject;
            (function (PluginObject) {
                PluginObject.nextCount = (function () {
                    var count = 0;
                    return function () {
                        return count++;
                    };
                })();
                PluginObject.State = StringEnum('None', 'ConfigNotSupported', 'NotInstalled', 'CreateFailed', 'ExistenceCheckFailed', 'AttachFailed', 'Created', 'Attached', 'Destroyed');
                PluginObject.IE_HTML_TEMPLATE = '<object id=\"{0}\" classid=\"CLSID:{1}\" width=\"100%\" height=\"100%\"><param name=\"managerID\" value=\"{2}\"><param name=\"componentID\" value=\"{0}\"><param name=\"inprocComponent\" value=\"{3}\"><param name=\"logLevel\" value=\"{4}\"></object>';
                PluginObject.FF_HTML_TEMPLATE = '<embed id=\"{0}\" type=\"{1}\" width=\"100%\" height=\"100%\" managerID=\"{2}\" componentID=\"{0}\" logLevel=\"{4}\"></embed>';
                // This object is provided by each plugin build (<build-name>.js). Update it when the plugin is changed.
                PluginObject.LwaPlugin = {
                    MIME_TYPE: "application/x-lwa-nativeplugin15.8",
                    PROGID: "Microsoft.LWAPlugin15.8",
                    PROGID64: "Microsoft.LWA64Plugin15.8",
                    PROGID_VERSION: "Microsoft.LWAPlugin15.8.VersionQuery",
                    PROGID_VERSION64: "Microsoft.LWA64Plugin15.8.VersionQuery",
                    CLSID: "40C37B6C-D273-41E2-8122-A338BBDB2528",
                    CLSID64: "7ECF6F97-B4F3-4168-9835-F59C06D7875F",
                    CLSID_VERSION: "53C06A7B-FC1E-40E6-9668-31CD219BAEA7",
                    CLSID_VERSION64: "1542FC7D-8D51-43D5-B757-67C763F27BF4",
                    EXTENSION_NAME: "LyncPlugin",
                    EXTENSION_CLIENT: "LyncPluginClient",
                    EXTENSION_SERVER: "LyncPluginServer"
                };
            })(PluginObject = Media.PluginObject || (Media.PluginObject = {}));
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=media.js.map

/// <reference path="./utils.ts" />
/**
 * Parts of the model layer common for both
 * media-dependent and media-independent models.
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_1) {
            var Internal;
            (function (Internal) {
                
                //#region Imports (from Skype.Web.Utils)
                var Utils = Skype.Web.Utils;
                var StringEnum = Utils.StringEnum;
                var foreach = Utils.foreach;
                var Command = Utils.Command;
                var Property = Utils.Property;
                var ConstProperty = Utils.ConstProperty;
                var Model = Utils.Model;
                var Exception = Utils.Exception;
                var batched = Utils.batched;
                var isFunction = Utils.isFunction;
                var deepEqual = Utils.deepEqual;
                var Symbol = Utils.Symbol;
                var ENotSupported = Utils.ENotSupported;
                Utils = null;
                //#endregion
                //#region Common Exceptions
                function EInvitationFailed(reason) {
                    var text = reason && reason.message;
                    return Exception.call(text, 'InvitationFailed', { reason: reason });
                }
                Internal.EInvitationFailed = EInvitationFailed;
                //#endregion
                //#region ObservableResource
                /**
                 * Wraps a UCWA resource into an observable model by mapping properties of the
                 * resource to observable properties of the model.
                 *
                 * Resources that contain an `etag` will have access to update supplied properties
                 * (that are not marked as read-only) which will create a PUT request to send an aggregated update.
                 *
                 * @param {UCWA} ucwa
                 * @param {Object|String} source - Resource selector.
                 * @param {Object} properties - Properties that need to be exposed in the model.
                 *
                 *  This is a mapping from a property name to a parsing function which is,
                 *  in most cases, the identity function that returns whatever it's given:
                 *
                 *      properties: {
                 *          name: function (value) { return value },
                 *          uri: function (value) { return value },
                 *          id: function (value) { return +value }
                 *      }
                 *
                 *  Each property can provide the following additional information:
                 *
                 *      parse - method to change resource value to property representation
                 *      convert - method to change property value to resource value
                 *      prepare - method to change value prior to sending PUT
                 *      readOnly - the property is read-only even if other properties are not
                 *
                 *  Example:
                 *
                 *      expirationTime: {
                 *          parse: timeStampToDate,
                 *          convert: dateToTimeStamp,
                 *          prepare: function (val) {
                 *              return val.toJSON();
                 *          }
                 *      }
                 *
                 *  The property may be set using a Date object which will need to be compared against the
                 *  resource representation and modified to properly send in the PUT request.
                 *
                 * @param {Object} commands - Commands that need to be exposed in the model.
                 *
                 *  In the current version, only the 'enabled' property in each exposed command
                 *  is implemented. This read-only property is associated with whether the
                 *  resource contains the corresponding link.
                 *
                 */
                function ObservableResource(ucwa, options) {
                    var source = options.source;
                    var defProperties = options.properties || {};
                    var defCommands = options.commands || {};
                    options = null;
                    var self = Model();
                    var dfd; // resolves after GET succeeds
                    var resource;
                    var properties = {};
                    var commands = {};
                    var writable = Property({ value: false, reason: Exception('Disconnected') });
                    var sResourceUpdated = {}; // it acts as a unique identifier
                    // the client may not be signed in at the moment
                    var initialized = ucwa.init().then(function () {
                        if (ucwa.exists(source))
                            resource = ucwa.get(source);
                    });
                    var changeProperty = batched(function (requests) {
                        var snapshot = resource.getSnapshot();
                        var data = {}; // this is what will be sent in the PUT request
                        var changed = false;
                        foreach(requests, function (r) {
                            var p = properties[r.name];
                            var oldVal = snapshot[r.name];
                            var newVal = p.convert ? p.convert(r.value) : r.value; // new Date(123) => "/Date(123)/"
                            // TODO: if the user changes a property value multiple times:
                            // model.prop(1), model.prop(2), model.prop(1) then this code
                            // will send the PUT request anyway, despite it's not needed
                            if (!deepEqual(newVal, oldVal)) {
                                changed = true;
                                snapshot[r.name] = newVal;
                            }
                        });
                        if (changed) {
                            foreach(snapshot, function (value, name) {
                                var p = properties[name];
                                data[name] = p && p.prepare ?
                                    p.prepare(p.parse(value)) :
                                    value;
                            });
                            return ucwa.send('PUT', resource.href, { data: data });
                        }
                    }, Infinity);
                    function fetchValues() {
                        if (!dfd) {
                            dfd = initialized.then(function () {
                                return ucwa.send('GET', resource.href);
                            });
                            // if GET fails, allow further attempts to send it again
                            dfd.then(null, function () {
                                dfd = null;
                            });
                        }
                        return dfd;
                    }
                    foreach(defProperties, function (data, name) {
                        var p, isSetterEnabled;
                        if (isFunction(data))
                            data = { parse: data };
                        if (!data.parse)
                            data.parse = function (x) { return x; };
                        p = Property({
                            subscribed: fetchValues,
                            get: function () {
                                return initialized.then(function () {
                                    return resource.has(name) ?
                                        p() :
                                        fetchValues().then(function () {
                                            return p(); // the fetched value is already in `p`
                                        });
                                });
                            },
                            set: function (value, reason) {
                                return initialized.then(function () {
                                    return reason === sResourceUpdated ? value : changeProperty({
                                        name: name,
                                        value: value
                                    }, 0).then(function () {
                                        return p();
                                    });
                                });
                            }
                        });
                        p.parse = data.parse;
                        p.convert = data.convert;
                        p.prepare = data.prepare;
                        properties[name] = p;
                        isSetterEnabled = data.readOnly ? ConstProperty(false) : writable;
                        self[name] = p.fork(Command(function (x) { return x; }, isSetterEnabled));
                    });
                    foreach(defCommands, function (data, name) {
                        var enabled = Property({
                            get: function () {
                                return initialized.then(function () {
                                    return resource.hasLink(name) ||
                                        fetchValues().then(function () {
                                            return resource.hasLink(name);
                                        });
                                });
                            }
                        });
                        commands[name] = { enabled: enabled };
                        self[name] = Command(function () { throw ENotSupported(); }, enabled.asReadOnly());
                    });
                    initialized.then(function () {
                        resource.updated(function () {
                            writable(resource.has('etag'), Exception('ETagMissing'));
                            foreach(properties, function (p, name) {
                                var value = resource.has(name) ? p.parse(resource.get(name)) : void 0;
                                p(value, sResourceUpdated);
                            });
                            foreach(defCommands, function (data, name) {
                                commands[name].enabled(resource.hasLink(name));
                            });
                        });
                    });
                    return self;
                }
                Internal.ObservableResource = ObservableResource;
                //#endregion
                //#region Modality
                var Modality;
                (function (Modality) {
                    Modality.State = StringEnum('Disconnected', 'Disconnecting', 'Connecting', 'Ringing', 'Connected', 'Notified', 'Created');
                })(Modality = Internal.Modality || (Internal.Modality = {}));
                //#endregion
                /** model[sHref] = href of the underlying resource */
                Internal.sHref = Symbol('href');
                /** model[sInternal] - an object exposing internal model properties and methods */
                Internal.sInternal = Symbol('internal');
            })(Internal = Model_1.Internal || (Model_1.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=model.common.js.map

/* jshint -W004 */
/* jshint -W098 */
/* global DataView: false */
/* global XDomainRequest: false */
/* global ArrayBuffer: false */
/* global Uint8Array: false */


var clienttelemetry_build;
(function (clienttelemetry_build) {
    clienttelemetry_build.version = "1.6.3.0";
})(clienttelemetry_build || (clienttelemetry_build = {}));
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : bond.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        var SerializableExceptionBase = (function () {
            function SerializableExceptionBase() {
                // 8189: optional string m_message
                this.m_message = "";
            }
            SerializableExceptionBase.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            SerializableExceptionBase.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (this.m_message != "") {
                    writer.WriteFieldBegin(9 /* BT_STRING */, 8189, null);
                    writer.WriteString(this.m_message);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(9 /* BT_STRING */, 8189, null);
                }
                writer.WriteStructEnd(isBase);
            };

            SerializableExceptionBase.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            SerializableExceptionBase.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 8189:
                            this.m_message = reader.ReadString();
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return SerializableExceptionBase;
        })();
        Bond.SerializableExceptionBase = SerializableExceptionBase;

        var Void = (function () {
            function Void() {
            }
            Void.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            Void.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                writer.WriteStructEnd(isBase);
            };

            Void.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            Void.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return Void;
        })();
        Bond.Void = Void;

        var GUID = (function () {
            function GUID() {
                // 0: optional uint32 Data1
                this.Data1 = 0;
                // 1: optional uint16 Data2
                this.Data2 = 0;
                // 2: optional uint16 Data3
                this.Data3 = 0;
                // 3: optional uint64 Data4
                this.Data4 = new Microsoft.Bond.UInt64("0");
            }
            GUID.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            GUID.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (this.Data1 != 0) {
                    writer.WriteFieldBegin(5 /* BT_UINT32 */, 0, null);
                    writer.WriteUInt32(this.Data1);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(5 /* BT_UINT32 */, 0, null);
                }
                if (this.Data2 != 0) {
                    writer.WriteFieldBegin(4 /* BT_UINT16 */, 1, null);
                    writer.WriteUInt16(this.Data2);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(4 /* BT_UINT16 */, 1, null);
                }
                if (this.Data3 != 0) {
                    writer.WriteFieldBegin(4 /* BT_UINT16 */, 2, null);
                    writer.WriteUInt16(this.Data3);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(4 /* BT_UINT16 */, 2, null);
                }
                if (!this.Data4.Equals("0")) {
                    writer.WriteFieldBegin(6 /* BT_UINT64 */, 3, null);
                    writer.WriteUInt64(this.Data4);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(6 /* BT_UINT64 */, 3, null);
                }
                writer.WriteStructEnd(isBase);
            };

            GUID.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            GUID.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            this.Data1 = reader.ReadUInt32();
                            break;

                        case 1:
                            this.Data2 = reader.ReadUInt16();
                            break;

                        case 2:
                            this.Data3 = reader.ReadUInt16();
                            break;

                        case 3:
                            this.Data4 = reader.ReadUInt64();
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return GUID;
        })();
        Bond.GUID = GUID;

        (function (Modifier) {
            Modifier[Modifier["Optional"] = 0] = "Optional";
            Modifier[Modifier["Required"] = 1] = "Required";
            Modifier[Modifier["RequiredOptional"] = 2] = "RequiredOptional";
        })(Bond.Modifier || (Bond.Modifier = {}));
        var Modifier = Bond.Modifier;

        var Variant = (function () {
            function Variant() {
                // 0: optional uint64 uint_value
                this.uint_value = new Microsoft.Bond.UInt64("0");
                // 1: optional int64 int_value
                this.int_value = new Microsoft.Bond.Int64("0");
                // 2: optional double double_value
                this.double_value = 0;
                // 3: optional string string_value
                this.string_value = "";
                // 4: optional wstring wstring_value
                this.wstring_value = "";
                // 5: optional bool nothing
                this.nothing = false;
            }
            Variant.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            Variant.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (!this.uint_value.Equals("0")) {
                    writer.WriteFieldBegin(6 /* BT_UINT64 */, 0, null);
                    writer.WriteUInt64(this.uint_value);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(6 /* BT_UINT64 */, 0, null);
                }
                if (!this.int_value.Equals("0")) {
                    writer.WriteFieldBegin(17 /* BT_INT64 */, 1, null);
                    writer.WriteInt64(this.int_value);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(17 /* BT_INT64 */, 1, null);
                }
                if (this.double_value != 0) {
                    writer.WriteFieldBegin(8 /* BT_DOUBLE */, 2, null);
                    writer.WriteDouble(this.double_value);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(8 /* BT_DOUBLE */, 2, null);
                }
                if (this.string_value != "") {
                    writer.WriteFieldBegin(9 /* BT_STRING */, 3, null);
                    writer.WriteString(this.string_value);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(9 /* BT_STRING */, 3, null);
                }
                if (this.wstring_value != "") {
                    writer.WriteFieldBegin(18 /* BT_WSTRING */, 4, null);
                    writer.WriteWString(this.wstring_value);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(18 /* BT_WSTRING */, 4, null);
                }
                if (this.nothing != false) {
                    writer.WriteFieldBegin(2 /* BT_BOOL */, 5, null);
                    writer.WriteBool(this.nothing);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(2 /* BT_BOOL */, 5, null);
                }
                writer.WriteStructEnd(isBase);
            };

            Variant.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            Variant.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            this.uint_value = reader.ReadUInt64();
                            break;

                        case 1:
                            this.int_value = reader.ReadInt64();
                            break;

                        case 2:
                            this.double_value = reader.ReadDouble();
                            break;

                        case 3:
                            this.string_value = reader.ReadString();
                            break;

                        case 4:
                            this.wstring_value = reader.ReadWString();
                            break;

                        case 5:
                            this.nothing = reader.ReadBool();
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return Variant;
        })();
        Bond.Variant = Variant;

        var Metadata = (function () {
            function Metadata() {
                // 0: optional string name
                this.name = "";
                // 1: optional string qualified_name
                this.qualified_name = "";
                // 2: optional map<string, string> attributes
                this.attributes = new Microsoft.Bond.Collections.Map();
                // 3: optional Microsoft.Bond.Modifier modifier
                this.modifier = 0 /* Optional */;
                // 4: optional Microsoft.Bond.Variant default_value
                this.default_value = new Microsoft.Bond.Variant();
            }
            Metadata.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            Metadata.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (this.name != "") {
                    writer.WriteFieldBegin(9 /* BT_STRING */, 0, null);
                    writer.WriteString(this.name);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(9 /* BT_STRING */, 0, null);
                }
                if (this.qualified_name != "") {
                    writer.WriteFieldBegin(9 /* BT_STRING */, 1, null);
                    writer.WriteString(this.qualified_name);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(9 /* BT_STRING */, 1, null);
                }
                if (this.attributes.Count()) {
                    writer.WriteFieldBegin(13 /* BT_MAP */, 2, null);
                    writer.WriteMapContainerBegin(this.attributes.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                    for (var i0 = 0; i0 < this.attributes.GetBuffer().length; ++i0) {
                        writer.WriteString(this.attributes.GetBuffer()[i0].Key);
                        writer.WriteString(this.attributes.GetBuffer()[i0].Value);
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(13 /* BT_MAP */, 2, null);
                }
                if (this.modifier != 0 /* Optional */) {
                    writer.WriteFieldBegin(16 /* BT_INT32 */, 3, null);
                    writer.WriteInt32(this.modifier);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(16 /* BT_INT32 */, 3, null);
                }
                if (true) {
                    writer.WriteFieldBegin(10 /* BT_STRUCT */, 4, null);
                    this.default_value.WriteImpl(writer, false);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(10 /* BT_STRUCT */, 4, null);
                }
                writer.WriteStructEnd(isBase);
            };

            Metadata.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            Metadata.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            this.name = reader.ReadString();
                            break;

                        case 1:
                            this.qualified_name = reader.ReadString();
                            break;

                        case 2:
                            var i2 = reader.ReadKeyValueContainerBegin();
                            for (var i1 = 0; i1 < i2.Size; ++i1) {
                                var i3 = "";
                                var i4 = "";
                                i3 = reader.ReadString();
                                i4 = reader.ReadString();
                                this.attributes.Add(i3, i4);
                            }
                            reader.ReadKeyValueContainerEnd();
                            break;

                        case 3:
                            this.modifier = reader.ReadInt32();
                            break;

                        case 4:
                            this.default_value = new Microsoft.Bond.Variant();
                            this.default_value.ReadImpl(reader, false);
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return Metadata;
        })();
        Bond.Metadata = Metadata;

        var TypeDef = (function () {
            function TypeDef() {
                // 0: optional Microsoft.Bond.BondDataType id
                this.id = 10 /* BT_STRUCT */;
                // 1: optional uint16 struct_def
                this.struct_def = 0;
                // 4: optional bool bonded_type
                this.bonded_type = false;
            }
            TypeDef.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            TypeDef.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (this.id != 10 /* BT_STRUCT */) {
                    writer.WriteFieldBegin(16 /* BT_INT32 */, 0, null);
                    writer.WriteInt32(this.id);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(16 /* BT_INT32 */, 0, null);
                }
                if (this.struct_def != 0) {
                    writer.WriteFieldBegin(4 /* BT_UINT16 */, 1, null);
                    writer.WriteUInt16(this.struct_def);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(4 /* BT_UINT16 */, 1, null);
                }
                if (this.element != undefined) {
                    writer.WriteFieldBegin(11 /* BT_LIST */, 2, null);
                    writer.WriteContainerBegin(this.element != undefined ? 1 : 0, 10 /* BT_STRUCT */);
                    if (this.element != undefined) {
                        this.element.WriteImpl(writer, false);
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(11 /* BT_LIST */, 2, null);
                }
                if (this.key != undefined) {
                    writer.WriteFieldBegin(11 /* BT_LIST */, 3, null);
                    writer.WriteContainerBegin(this.key != undefined ? 1 : 0, 10 /* BT_STRUCT */);
                    if (this.key != undefined) {
                        this.key.WriteImpl(writer, false);
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(11 /* BT_LIST */, 3, null);
                }
                if (this.bonded_type != false) {
                    writer.WriteFieldBegin(2 /* BT_BOOL */, 4, null);
                    writer.WriteBool(this.bonded_type);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(2 /* BT_BOOL */, 4, null);
                }
                writer.WriteStructEnd(isBase);
            };

            TypeDef.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            TypeDef.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            this.id = reader.ReadInt32();
                            break;

                        case 1:
                            this.struct_def = reader.ReadUInt16();
                            break;

                        case 2:
                            var i5 = reader.ReadContainerBegin();
                            if (i5.Size == 1) {
                                this.element = new Microsoft.Bond.TypeDef();
                                this.element = new Microsoft.Bond.TypeDef();
                                this.element.ReadImpl(reader, false);
                            }
                            reader.ReadContainerEnd();
                            break;

                        case 3:
                            var i6 = reader.ReadContainerBegin();
                            if (i6.Size == 1) {
                                this.key = new Microsoft.Bond.TypeDef();
                                this.key = new Microsoft.Bond.TypeDef();
                                this.key.ReadImpl(reader, false);
                            }
                            reader.ReadContainerEnd();
                            break;

                        case 4:
                            this.bonded_type = reader.ReadBool();
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return TypeDef;
        })();
        Bond.TypeDef = TypeDef;

        var FieldDef = (function () {
            function FieldDef() {
                // 0: optional Microsoft.Bond.Metadata metadata
                this.metadata = new Microsoft.Bond.Metadata();
                // 1: optional uint16 id
                this.id = 0;
                // 2: optional Microsoft.Bond.TypeDef type
                this.type = new Microsoft.Bond.TypeDef();
            }
            FieldDef.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            FieldDef.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (true) {
                    writer.WriteFieldBegin(10 /* BT_STRUCT */, 0, null);
                    this.metadata.WriteImpl(writer, false);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(10 /* BT_STRUCT */, 0, null);
                }
                if (this.id != 0) {
                    writer.WriteFieldBegin(4 /* BT_UINT16 */, 1, null);
                    writer.WriteUInt16(this.id);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(4 /* BT_UINT16 */, 1, null);
                }
                if (true) {
                    writer.WriteFieldBegin(10 /* BT_STRUCT */, 2, null);
                    this.type.WriteImpl(writer, false);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(10 /* BT_STRUCT */, 2, null);
                }
                writer.WriteStructEnd(isBase);
            };

            FieldDef.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            FieldDef.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            this.metadata = new Microsoft.Bond.Metadata();
                            this.metadata.ReadImpl(reader, false);
                            break;

                        case 1:
                            this.id = reader.ReadUInt16();
                            break;

                        case 2:
                            this.type = new Microsoft.Bond.TypeDef();
                            this.type.ReadImpl(reader, false);
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return FieldDef;
        })();
        Bond.FieldDef = FieldDef;

        var StructDef = (function () {
            function StructDef() {
                // 0: optional Microsoft.Bond.Metadata metadata
                this.metadata = new Microsoft.Bond.Metadata();
                // 2: optional vector<Microsoft.Bond.FieldDef> fields
                this.fields = [];
            }
            StructDef.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            StructDef.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (true) {
                    writer.WriteFieldBegin(10 /* BT_STRUCT */, 0, null);
                    this.metadata.WriteImpl(writer, false);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(10 /* BT_STRUCT */, 0, null);
                }
                if (this.base_def != undefined) {
                    writer.WriteFieldBegin(11 /* BT_LIST */, 1, null);
                    writer.WriteContainerBegin(this.base_def != undefined ? 1 : 0, 10 /* BT_STRUCT */);
                    if (this.base_def != undefined) {
                        this.base_def.WriteImpl(writer, false);
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(11 /* BT_LIST */, 1, null);
                }
                if (this.fields.length) {
                    writer.WriteFieldBegin(11 /* BT_LIST */, 2, null);
                    writer.WriteContainerBegin(this.fields.length, 10 /* BT_STRUCT */);
                    for (var i7 = 0; i7 < this.fields.length; ++i7) {
                        this.fields[i7].WriteImpl(writer, false);
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(11 /* BT_LIST */, 2, null);
                }
                writer.WriteStructEnd(isBase);
            };

            StructDef.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            StructDef.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            this.metadata = new Microsoft.Bond.Metadata();
                            this.metadata.ReadImpl(reader, false);
                            break;

                        case 1:
                            var i8 = reader.ReadContainerBegin();
                            if (i8.Size == 1) {
                                this.base_def = new Microsoft.Bond.TypeDef();
                                this.base_def = new Microsoft.Bond.TypeDef();
                                this.base_def.ReadImpl(reader, false);
                            }
                            reader.ReadContainerEnd();
                            break;

                        case 2:
                            var i9 = reader.ReadContainerBegin();
                            for (var i11 = 0; i11 < i9.Size; ++i11) {
                                var i10 = new Microsoft.Bond.FieldDef();
                                i10 = new Microsoft.Bond.FieldDef();
                                i10.ReadImpl(reader, false);
                                this.fields.push(i10);
                            }
                            reader.ReadContainerEnd();
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return StructDef;
        })();
        Bond.StructDef = StructDef;

        var SchemaDef = (function () {
            function SchemaDef() {
                // 0: optional vector<Microsoft.Bond.StructDef> structs
                this.structs = [];
                // 1: optional Microsoft.Bond.TypeDef root
                this.root = new Microsoft.Bond.TypeDef();
            }
            SchemaDef.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            SchemaDef.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (this.structs.length) {
                    writer.WriteFieldBegin(11 /* BT_LIST */, 0, null);
                    writer.WriteContainerBegin(this.structs.length, 10 /* BT_STRUCT */);
                    for (var i12 = 0; i12 < this.structs.length; ++i12) {
                        this.structs[i12].WriteImpl(writer, false);
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(11 /* BT_LIST */, 0, null);
                }
                if (true) {
                    writer.WriteFieldBegin(10 /* BT_STRUCT */, 1, null);
                    this.root.WriteImpl(writer, false);
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(10 /* BT_STRUCT */, 1, null);
                }
                writer.WriteStructEnd(isBase);
            };

            SchemaDef.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            SchemaDef.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            var i13 = reader.ReadContainerBegin();
                            for (var i15 = 0; i15 < i13.Size; ++i15) {
                                var i14 = new Microsoft.Bond.StructDef();
                                i14 = new Microsoft.Bond.StructDef();
                                i14.ReadImpl(reader, false);
                                this.structs.push(i14);
                            }
                            reader.ReadContainerEnd();
                            break;

                        case 1:
                            this.root = new Microsoft.Bond.TypeDef();
                            this.root.ReadImpl(reader, false);
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return SchemaDef;
        })();
        Bond.SchemaDef = SchemaDef;

        var Box = (function () {
            function Box() {
            }
            Box.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            Box.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                writer.WriteStructEnd(isBase);
            };

            Box.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            Box.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return Box;
        })();
        Bond.Box = Box;

        var List = (function () {
            function List() {
                // 0: optional list<T> value
                this.value = [];
            }
            List.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            List.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (this.value.length) {
                    writer.WriteFieldBegin(11 /* BT_LIST */, 0, null);
                    writer.WriteContainerBegin(this.value.length, 127 /* BT_UNAVAILABLE */);
                    for (var i16 = 0; i16 < this.value.length; ++i16) {
                        // Not support this type currently
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(11 /* BT_LIST */, 0, null);
                }
                writer.WriteStructEnd(isBase);
            };

            List.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            List.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            var i17 = reader.ReadContainerBegin();
                            for (var i19 = 0; i19 < i17.Size; ++i19) {
                                var i18 = null;
                                this.value.push(i18);
                            }
                            reader.ReadContainerEnd();
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return List;
        })();
        Bond.List = List;

        var Vector = (function () {
            function Vector() {
                // 0: optional vector<T> value
                this.value = [];
            }
            Vector.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            Vector.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                if (this.value.length) {
                    writer.WriteFieldBegin(11 /* BT_LIST */, 0, null);
                    writer.WriteContainerBegin(this.value.length, 127 /* BT_UNAVAILABLE */);
                    for (var i20 = 0; i20 < this.value.length; ++i20) {
                        // Not support this type currently
                    }
                    writer.WriteContainerEnd();
                    writer.WriteFieldEnd();
                } else {
                    writer.WriteFieldOmitted(11 /* BT_LIST */, 0, null);
                }
                writer.WriteStructEnd(isBase);
            };

            Vector.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            Vector.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 0:
                            var i21 = reader.ReadContainerBegin();
                            for (var i23 = 0; i23 < i21.Size; ++i23) {
                                var i22 = null;
                                this.value.push(i22);
                            }
                            reader.ReadContainerEnd();
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return Vector;
        })();
        Bond.Vector = Vector;

        // [polymorphic("")]
        var Polymorphic = (function () {
            function Polymorphic() {
            }
            Polymorphic.prototype.Write = function (writer) {
                this.WriteImpl(writer, false);
            };

            Polymorphic.prototype.WriteImpl = function (writer, isBase) {
                writer.WriteStructBegin(null, isBase);

                writer.WriteStructEnd(isBase);
            };

            Polymorphic.prototype.Read = function (reader) {
                this.ReadImpl(reader, false);
            };

            Polymorphic.prototype.ReadImpl = function (reader, isBase) {
                reader.ReadStructBegin(isBase);

                while (true) {
                    var fieldTag = reader.ReadFieldBegin();
                    if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                        break;
                    }

                    switch (fieldTag.Id) {
                        case 32768:
                            break;

                        default:
                            reader.Skip(fieldTag.Type);
                            break;
                    }
                    reader.ReadFieldEnd();
                }
                reader.ReadStructEnd();
            };
            return Polymorphic;
        })();
        Bond.Polymorphic = Polymorphic;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : bond_const.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (BondDataType) {
            BondDataType[BondDataType["BT_STOP"] = 0] = "BT_STOP";
            BondDataType[BondDataType["BT_STOP_BASE"] = 1] = "BT_STOP_BASE";
            BondDataType[BondDataType["BT_BOOL"] = 2] = "BT_BOOL";
            BondDataType[BondDataType["BT_UINT8"] = 3] = "BT_UINT8";
            BondDataType[BondDataType["BT_UINT16"] = 4] = "BT_UINT16";
            BondDataType[BondDataType["BT_UINT32"] = 5] = "BT_UINT32";
            BondDataType[BondDataType["BT_UINT64"] = 6] = "BT_UINT64";
            BondDataType[BondDataType["BT_FLOAT"] = 7] = "BT_FLOAT";
            BondDataType[BondDataType["BT_DOUBLE"] = 8] = "BT_DOUBLE";
            BondDataType[BondDataType["BT_STRING"] = 9] = "BT_STRING";
            BondDataType[BondDataType["BT_STRUCT"] = 10] = "BT_STRUCT";
            BondDataType[BondDataType["BT_LIST"] = 11] = "BT_LIST";
            BondDataType[BondDataType["BT_SET"] = 12] = "BT_SET";
            BondDataType[BondDataType["BT_MAP"] = 13] = "BT_MAP";
            BondDataType[BondDataType["BT_INT8"] = 14] = "BT_INT8";
            BondDataType[BondDataType["BT_INT16"] = 15] = "BT_INT16";
            BondDataType[BondDataType["BT_INT32"] = 16] = "BT_INT32";
            BondDataType[BondDataType["BT_INT64"] = 17] = "BT_INT64";
            BondDataType[BondDataType["BT_WSTRING"] = 18] = "BT_WSTRING";
            BondDataType[BondDataType["BT_UNAVAILABLE"] = 127] = "BT_UNAVAILABLE";
        })(Bond.BondDataType || (Bond.BondDataType = {}));
        var BondDataType = Bond.BondDataType;

        (function (ProtocolType) {
            ProtocolType[ProtocolType["MARSHALED_PROTOCOL"] = 0] = "MARSHALED_PROTOCOL";
            ProtocolType[ProtocolType["MAFIA_PROTOCOL"] = 17997] = "MAFIA_PROTOCOL";
            ProtocolType[ProtocolType["COMPACT_PROTOCOL"] = 16963] = "COMPACT_PROTOCOL";
            ProtocolType[ProtocolType["JSON_PROTOCOL"] = 21322] = "JSON_PROTOCOL";
            ProtocolType[ProtocolType["PRETTY_JSON_PROTOCOL"] = 20554] = "PRETTY_JSON_PROTOCOL";
            ProtocolType[ProtocolType["SIMPLE_PROTOCOL"] = 20563] = "SIMPLE_PROTOCOL";
        })(Bond.ProtocolType || (Bond.ProtocolType = {}));
        var ProtocolType = Bond.ProtocolType;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (Collections) {
            var Set = (function () {
                function Set() {
                    this._buffer = [];
                }
                Set.prototype.Add = function (t) {
                    var i = 0;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i] == t) {
                            break;
                        }
                    }
                    if (i == this._buffer.length) {
                        this._buffer.push(t);
                    }
                };

                Set.prototype.Count = function () {
                    return this._buffer.length;
                };

                Set.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return Set;
            })();
            Collections.Set = Set;

            var Map = (function () {
                function Map() {
                    this._buffer = [];
                }
                Map.prototype.Add = function (key, value) {
                    var i = 0;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i].Key == key) {
                            break;
                        }
                    }
                    if (i == this._buffer.length) {
                        this._buffer.push({ Key: key, Value: value });
                    }
                };

                Map.prototype.Count = function () {
                    return this._buffer.length;
                };

                Map.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return Map;
            })();
            Collections.Map = Map;
        })(Bond.Collections || (Bond.Collections = {}));
        var Collections = Bond.Collections;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (Encoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetBytes = function (value) {
                    var array = [];
                    for (var i = 0; i < value.length; ++i) {
                        var char = value.charCodeAt(i);
                        if (char < 0x80) {
                            array.push(char);
                        } else if (char < 0x800) {
                            array.push(0xc0 | (char >> 6), 0x80 | (char & 0x3f));
                        } else if (char < 0xd800 || char >= 0xe000) {
                            array.push(0xe0 | (char >> 12), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        } else {
                            char = 0x10000 + (((char & 0x3ff) << 10) | (value.charCodeAt(++i) & 0x3ff));
                            array.push(0xf0 | (char >> 18), 0x80 | ((char >> 12) & 0x3f), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        }
                    }
                    return array;
                };
                return Utf8;
            })();
            Encoding.Utf8 = Utf8;

            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetString = function (inArray) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var output = [];
                    var paddingBytes = inArray.length % 3;
                    var i, temp, length;

                    var toBase64 = function (num) {
                        return [
                            lookup.charAt((num >> 18) & 0x3F),
                            lookup.charAt((num >> 12) & 0x3F),
                            lookup.charAt((num >> 6) & 0x3F),
                            lookup.charAt(num & 0x3F)].join("");
                    };

                    for (i = 0, length = inArray.length - paddingBytes; i < length; i += 3) {
                        temp = (inArray[i] << 16) + (inArray[i + 1] << 8) + (inArray[i + 2]);
                        output.push(toBase64(temp));
                    }

                    switch (paddingBytes) {
                        case 1:
                            temp = inArray[inArray.length - 1];
                            output.push(lookup.charAt(temp >> 2));
                            output.push(lookup.charAt((temp << 4) & 0x3F));
                            output.push('==');
                            break;

                        case 2:
                            temp = (inArray[inArray.length - 2] << 8) + (inArray[inArray.length - 1]);
                            output.push(lookup.charAt(temp >> 10));
                            output.push(lookup.charAt((temp >> 4) & 0x3F));
                            output.push(lookup.charAt((temp << 2) & 0x3F));
                            output.push('=');
                            break;
                    }
                    return output.join("");
                };
                return Base64;
            })();
            Encoding.Base64 = Base64;

            var Varint = (function () {
                function Varint() {
                }
                Varint.GetBytes = function (value) {
                    var array = [];
                    while (value & 0xffffff80) {
                        array.push((value & 0x7f) | 0x80);
                        value >>>= 7;
                    }
                    array.push(value & 0x7f);
                    return array;
                };
                return Varint;
            })();
            Encoding.Varint = Varint;

            var Varint64 = (function () {
                function Varint64() {
                }
                Varint64.GetBytes = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var array = [];
                    while (high || (0xffffff80 & low)) {
                        array.push((low & 0x7f) | 0x80);
                        low = ((high & 0x7f) << 25) | (low >>> 7);
                        high >>>= 7;
                    }
                    array.push(low & 0x7f);
                    return array;
                };
                return Varint64;
            })();
            Encoding.Varint64 = Varint64;

            var Float = (function () {
                function Float() {
                }
                Float.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        view.setFloat32(0, value, true);

                        var array = [];
                        for (var i = 0; i < 4; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    } else {
                        return FloatUtils.ConvertNumberToArray(value, false);
                    }
                };
                return Float;
            })();
            Encoding.Float = Float;

            // Note: see notes of Float.
            var Double = (function () {
                function Double() {
                }
                Double.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        view.setFloat64(0, value, true);

                        var array = [];
                        for (var i = 0; i < 8; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    } else {
                        return FloatUtils.ConvertNumberToArray(value, true);
                    }
                };
                return Double;
            })();
            Encoding.Double = Double;

            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.EncodeZigzag16 = function (value) {
                    value = Bond.Number.ToInt16(value);
                    return ((value << 1) ^ (value >> (2 * 8 - 1)));
                };

                Zigzag.EncodeZigzag32 = function (value) {
                    value = Bond.Number.ToInt32(value);
                    return ((value << 1) ^ (value >> (4 * 8 - 1)));
                };

                Zigzag.EncodeZigzag64 = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var tmpH = (high << 1) | (low >>> 31);
                    var tmpL = low << 1;
                    if (high & 0x80000000) {
                        tmpH = ~tmpH;
                        tmpL = ~tmpL;
                    }

                    var res = new Bond.UInt64("0");
                    res.low = tmpL;
                    res.high = tmpH;
                    return res;
                };
                return Zigzag;
            })();
            Encoding.Zigzag = Zigzag;
        })(Bond.Encoding || (Bond.Encoding = {}));
        var Encoding = Bond.Encoding;

        (function (Decoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetString = function (data) {
                    var res = [];
                    for (var i = 0; i < data.length; ++i) {
                        var c1 = data[i];
                        if (c1 <= 191) {
                            res.push(String.fromCharCode(c1));
                        } else if (c1 <= 223) {
                            var c2 = data[++i];
                            res.push(String.fromCharCode(((c1 & 31) << 6) | (c2 & 63)));
                        } else if (c1 <= 239) {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            res.push(String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                        } else {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            var c4 = data[++i];
                            c1 = ((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63);
                            c1 -= 0x10000;
                            res.push(String.fromCharCode(0xd800 | ((c1 >> 10) & 0x3ff)));
                            res.push(String.fromCharCode(0xdc00 | (c1 & 0x3ff)));
                        }
                    }
                    return res.join("");
                };
                return Utf8;
            })();
            Decoding.Utf8 = Utf8;

            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetBytes = function (base64Str) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var res = [];
                    for (var i = 0; i < base64Str.length; ++i) {
                        var byte1 = lookup.indexOf(base64Str.charAt(i++));
                        var byte2 = lookup.indexOf(base64Str.charAt(i++));
                        var byte3 = lookup.indexOf(base64Str.charAt(i++));
                        var byte4 = lookup.indexOf(base64Str.charAt(i));

                        res.push(byte1 << 2 | byte2 >> 4);
                        if (byte3 >= 0) {
                            res.push((byte2 << 4) & 0xF0 | byte3 >> 2);

                            if (byte4 >= 0) {
                                res.push((byte3 << 6) & 0xC0 | byte4);
                            }
                        }
                    }
                    return res;
                };
                return Base64;
            })();
            Decoding.Base64 = Base64;

            var Varint = (function () {
                function Varint() {
                }
                Varint.GetInt64 = function (buffer) {
                    var int64 = new Microsoft.Bond.Int64("0");
                    var data = this._Read(buffer);
                    int64.low = data[0];
                    if (data.length > 1) {
                        int64.high = data[1];
                    }
                    return int64;
                };

                Varint.GetNumber = function (buffer) {
                    return this._Read(buffer)[0];
                };

                Varint._Read = function (buffer) {
                    var result = [];
                    var tmp = 0;
                    var hasMore = true;
                    var readedBits = 0;

                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        if (readedBits < 28) {
                            tmp |= raw << readedBits;
                            readedBits += 7;
                        } else {
                            // only lower 4 bits can be put
                            tmp |= raw << readedBits;
                            result.push(tmp);
                            tmp = raw >> 4;
                            readedBits = 3;
                            break;
                        }
                    }

                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        tmp |= raw << readedBits;
                        readedBits += 7;
                        if (readedBits >= 32) {
                            break;
                        }
                    }
                    result.push(tmp);
                    return result;
                };
                return Varint;
            })();
            Decoding.Varint = Varint;

            var Float = (function () {
                function Float() {
                }
                Float.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        for (var i = 0; i < 4; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat32(0, true);
                    } else {
                        return FloatUtils.ConvertArrayToNumber(buffer, false);
                    }
                };
                return Float;
            })();
            Decoding.Float = Float;

            var Double = (function () {
                function Double() {
                }
                Double.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        for (var i = 0; i < 8; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat64(0, true);
                    } else {
                        return FloatUtils.ConvertArrayToNumber(buffer, true);
                    }
                };
                return Double;
            })();
            Decoding.Double = Double;

            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.DecodeZigzag16 = function (value) {
                    return (((0xffff & value) >>> 1) ^ (-(value & 1))) << 16 >> 16;
                };

                Zigzag.DecodeZigzag32 = function (value) {
                    return (value >>> 1) ^ (-(value & 1));
                };

                Zigzag.DecodeZigzag64 = function (value) {
                    // implement
                    // (value >>> 1) ^ (-(value & 1))
                    var tmpH = value.high & 1;
                    var high = value.high >>> 1;
                    var tmpL = value.low & 1;
                    var low = value.low >>> 1;
                    low = tmpH << 31 | low;
                    if (tmpL) {
                        low ^= 0xffffffff;
                        high ^= 0xffffffff;
                    }

                    var res = new Microsoft.Bond.UInt64("0");
                    res.low = low;
                    res.high = high;
                    return res;
                };
                return Zigzag;
            })();
            Decoding.Zigzag = Zigzag;
        })(Bond.Decoding || (Bond.Decoding = {}));
        var Decoding = Bond.Decoding;

        /** This class will be used to convert float/double to byte array on browsers which doesn't
        support html5.
        
        Format: IEEE-754, littleEndian, http://en.wikipedia.org/wiki/IEEE_754-1985
        
        \note
        1. Don't have negative zero. All zero will be positive zero.
        2. If the buffer array passed to ConvertArrayToFloat() is actual NaN or Inifinity value,
        exception will be raised.
        */
        var FloatUtils = (function () {
            function FloatUtils() {
            }
            FloatUtils.ConvertNumberToArray = function (num, isDouble) {
                if (!num) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }

                var exponentBits = isDouble ? 11 : 8;
                var precisionBits = isDouble ? 52 : 23;

                // follow IEEE-754, exponent bias is 2^(k-1)-1 where k is the number of bits
                // in the exponent: http://en.wikipedia.org/wiki/Exponent_bias
                var bias = (1 << (exponentBits - 1)) - 1;
                var minExponent = 1 - bias;
                var maxExponent = bias;

                var sign = num < 0 ? 1 : 0;
                num = Math.abs(num);
                var intPart = Math.floor(num);
                var floatPart = num - intPart;

                var len = 2 * (bias + 2) + precisionBits;
                var buffer = new Array(len);
                var i = 0;
                while (i < len) {
                    buffer[i++] = 0;
                }

                // caculate the intPart
                i = bias + 2;
                while (i && intPart) {
                    buffer[--i] = intPart % 2;
                    intPart = Math.floor(intPart / 2);
                }

                // caculate the floatPart
                i = bias + 1;
                while (i < len - 1 && floatPart > 0) {
                    floatPart *= 2;
                    if (floatPart >= 1) {
                        buffer[++i] = 1;
                        --floatPart;
                    } else {
                        buffer[++i] = 0;
                    }
                }

                // find the first 1
                var firstBit = 0;
                for (; firstBit < len && !buffer[firstBit]; ++firstBit)
                    ;

                // caculate exponent
                var exponent = bias + 1 - firstBit;

                // caculate round
                var lastBit = firstBit + precisionBits;
                if (buffer[lastBit + 1]) {
                    for (i = lastBit; i > firstBit; --i) {
                        if (buffer[i] = 1 - buffer[i]) { // jshint ignore:line
                            break;
                        }
                    }
                    if (i == firstBit) {
                        ++exponent;
                    }
                }

                // check overflow
                if (exponent > maxExponent || intPart) {
                    if (sign) {
                        return isDouble ? this._doubleNegInifinity : this._floatNegInifinity;
                    } else {
                        return isDouble ? this._doubleInifinity : this._floatInifinity;
                    }
                } else if (exponent < minExponent) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }

                // caculate the result
                if (isDouble) {
                    var high = 0;
                    for (i = 0; i < 20; ++i) {
                        high = (high << 1) | buffer[++firstBit];
                    }

                    var low = 0;
                    for (; i < 52; ++i) {
                        low = (low << 1) | buffer[++firstBit];
                    }

                    high |= (exponent + bias) << 20;
                    high = (sign << 31) | (high & 0x7FFFFFFF);

                    var resArray = [
                        low & 0xff, (low >> 8) & 0xff, (low >> 16) & 0xff, low >>> 24,
                        high & 0xff, (high >> 8) & 0xff, (high >> 16) & 0xff, high >>> 24];
                    return resArray;
                } else {
                    var result = 0;
                    for (i = 0; i < 23; ++i) {
                        result = (result << 1) | buffer[++firstBit];
                    }

                    result |= (exponent + bias) << 23;
                    result = (sign << 31) | (result & 0x7FFFFFFF);

                    var resArray = [result & 0xff, (result >> 8) & 0xff, (result >> 16) & 0xff, result >>> 24];
                    return resArray;
                }
            };

            FloatUtils.ConvertArrayToNumber = function (buffer, isDouble) {
                var exponentBits = isDouble ? 11 : 8;
                var bias = (1 << (exponentBits - 1)) - 1;
                var sign = (buffer[isDouble ? 7 : 3] & 0x80) != 0;
                var exponent = isDouble ? ((buffer[7] & 0x7f) << 4) | ((buffer[6] & 0xf0) >> 4) : ((buffer[3] & 0x7f) << 1) | ((buffer[2] & 0x80) >> 7);

                // check the buffer is valid or not. If it is invalid (NaN, Infinitive), throw execption.
                if (exponent == 0xff) {
                    throw new Bond.Exception("Not a valid float/double buffer.");
                }

                var res = 1;
                var e = 1;
                if (isDouble) {
                    var high = ((buffer[6] & 0xf) << 28) | ((buffer[5] & 0xff) << 20) | ((buffer[4] & 0xff) << 12);
                    var low = (buffer[3] << 24) | ((buffer[2] & 0xff) << 16) | ((buffer[1] & 0xff) << 8) | (buffer[0] & 0xff);
                    if (!exponent && !high && !low) {
                        return 0.0;
                    }
                    for (var i = 0; i < 20; ++i) {
                        e /= 2;
                        if (high < 0) {
                            res += e;
                        }
                        high <<= 1;
                    }
                    for (var i = 0; i < 32; ++i) {
                        e /= 2;
                        if (low < 0) {
                            res += e;
                        }
                        low <<= 1;
                    }
                } else {
                    var data = ((buffer[2] & 0x7f) << 25) | ((buffer[1] & 0xff) << 17) | ((buffer[0] & 0xff) << 9);
                    if (!exponent && !data) {
                        return 0.0;
                    }
                    for (var i = 0; i < 23; ++i) {
                        e /= 2;
                        if (data < 0) {
                            res += e;
                        }
                        data <<= 1;
                    }
                }
                res *= Math.pow(2, exponent - bias);
                return sign ? 0 - res : res;
            };
            FloatUtils._floatZero = [0x00, 0x00, 0x00, 0x00];
            FloatUtils._doubleZero = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
            FloatUtils._floatInifinity = [0x00, 0x00, 0x80, 0x7F];
            FloatUtils._floatNegInifinity = [0x00, 0x00, 0x80, 0xFF];
            FloatUtils._doubleInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f];
            FloatUtils._doubleNegInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff];
            return FloatUtils;
        })();
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        (function (IO) {
            var MemoryStream = (function () {
                function MemoryStream() {
                    this._buffer = [];
                }
                /*override*/
                MemoryStream.prototype.WriteByte = function (byte) {
                    this._buffer.push(Bond.Number.ToByte(byte));
                };

                /*override*/
                MemoryStream.prototype.Write = function (buffer, offset, count) {
                    while (count--) {
                        this.WriteByte(buffer[offset++]);
                    }
                };

                /**
                * Returns the array of unsigned bytes from which this stream was created.
                */
                MemoryStream.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return MemoryStream;
            })();
            IO.MemoryStream = MemoryStream;
        })(Bond.IO || (Bond.IO = {}));
        var IO = Bond.IO;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        var FieldTag = (function () {
            function FieldTag(type, id) {
                this.Type = type;
                this.Id = id;
            }
            return FieldTag;
        })();
        Bond.FieldTag = FieldTag;

        var ContainerTag = (function () {
            function ContainerTag(elementType, size) {
                this.ElementType = elementType;
                this.Size = size;
            }
            return ContainerTag;
        })();
        Bond.ContainerTag = ContainerTag;

        var KeyValueContainerTag = (function () {
            function KeyValueContainerTag(keyType, valueType, size) {
                this.KeyType = keyType;
                this.ValueType = valueType;
                this.Size = size;
            }
            return KeyValueContainerTag;
        })();
        Bond.KeyValueContainerTag = KeyValueContainerTag;

        var Bonded = (function () {
            function Bonded() {
            }
            return Bonded;
        })();
        Bond.Bonded = Bonded;

        var Int64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function Int64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
                if (this.low < 0) {
                    this.high = -1;
                }
            }
            Int64.prototype.Equals = function (numberStr) {
                var tmp = new Int64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return Int64;
        })();
        Bond.Int64 = Int64;

        var UInt64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function UInt64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
            }
            UInt64.prototype.Equals = function (numberStr) {
                var tmp = new UInt64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return UInt64;
        })();
        Bond.UInt64 = UInt64;

        var Number = (function () {
            function Number() {
            }
            Number.ToByte = function (value) {
                return this.ToUInt8(value);
            };

            Number.ToInt8 = function (value) {
                var signMask = (value & 0x80) << 24 >> 24;
                return (value & 0x7f) | signMask;
            };

            Number.ToInt16 = function (value) {
                var signMask = (value & 0x8000) << 16 >> 16;
                return (value & 0x7fff) | signMask;
            };

            Number.ToInt32 = function (value) {
                var signMask = (value & 0x80000000);
                return (value & 0x7fffffff) | signMask;
            };

            Number.ToUInt8 = function (value) {
                return value & 0xff;
            };

            Number.ToUInt16 = function (value) {
                return value & 0xffff;
            };

            Number.ToUInt32 = function (value) {
                return value & 0xffffffff;
            };
            return Number;
        })();
        Bond.Number = Number;

        var Exception = (function () {
            function Exception(message) {
                this.Message = message;
            }
            return Exception;
        })();
        Bond.Exception = Exception;

        var KeyValuePair = (function () {
            function KeyValuePair() {
            }
            return KeyValuePair;
        })();
        Bond.KeyValuePair = KeyValuePair;

        var BrowserChecker = (function () {
            function BrowserChecker() {
            }
            BrowserChecker.IsDataViewSupport = function () {
                return typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
            };
            return BrowserChecker;
        })();
        Bond.BrowserChecker = BrowserChecker;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));

var Microsoft;
(function (Microsoft) {
    (function (Bond) {
        

        var CompactBinaryProtocolWriter = (function () {
            function CompactBinaryProtocolWriter(stream) {
                this._stream = stream;
            }
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBlob = function (blob) {
                this._stream.Write(blob, 0, blob.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBool = function (value) {
                this._stream.WriteByte(value ? 1 : 0);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerBegin = function (size, elementType) {
                this.WriteUInt8(elementType);
                this.WriteUInt32(size);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteMapContainerBegin = function (size, keyType, valueType) {
                this.WriteUInt8(keyType);
                this.WriteUInt8(valueType);
                this.WriteUInt32(size);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerEnd = function () {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteDouble = function (value) {
                var array = Bond.Encoding.Double.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFloat = function (value) {
                var array = Bond.Encoding.Float.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldBegin = function (type, id, metadata) {
                if (id <= 5) {
                    this._stream.WriteByte(type | (id << 5));
                } else if (id <= 0xff) {
                    this._stream.WriteByte(type | (6 << 5));
                    this._stream.WriteByte(id);
                } else {
                    this._stream.WriteByte(type | (7 << 5));
                    this._stream.WriteByte(id);
                    this._stream.WriteByte(id >> 8);
                }
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldEnd = function () {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldOmitted = function (type, id, metadata) {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt16 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag16(value);
                this.WriteUInt16(value);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt32 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag32(value);
                this.WriteUInt32(value);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt64 = function (value) {
                this.WriteUInt64(Bond.Encoding.Zigzag.EncodeZigzag64(value));
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToInt8(value));
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteString = function (value) {
                if (value == "") {
                    this.WriteUInt32(0);
                } else {
                    var array = Bond.Encoding.Utf8.GetBytes(value);
                    this.WriteUInt32(array.length);
                    this._stream.Write(array, 0, array.length);
                }
            };

            /*override*/ CompactBinaryProtocolWriter.prototype.WriteStructBegin = function (metadata, isBase) {
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteStructEnd = function (isBase) {
                this.WriteUInt8(isBase ? 1 /* BT_STOP_BASE */ : 0 /* BT_STOP */);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt16 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt16(value));
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt32 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt32(value));
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt64 = function (value) {
                var array = Bond.Encoding.Varint64.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToUInt8(value));
            };

            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteWString = function (value) {
                this.WriteUInt32(value.length);
                for (var i = 0; i < value.length; ++i) {
                    var charCode = value.charCodeAt(i);
                    this._stream.WriteByte(charCode);
                    this._stream.WriteByte(charCode >>> 8);
                }
            };
            return CompactBinaryProtocolWriter;
        })();
        Bond.CompactBinaryProtocolWriter = CompactBinaryProtocolWriter;

        var CompactBinaryProtocolReader = (function () {
            function CompactBinaryProtocolReader(bytes) {
                this._buffer = bytes;
            }
            CompactBinaryProtocolReader.prototype.ReadBool = function () {
                return this.ReadUInt8() == 0 ? false : true;
            };

            CompactBinaryProtocolReader.prototype.ReadBlob = function (size) {
                return this._ReadBytes(size);
            };

            CompactBinaryProtocolReader.prototype.ReadContainerBegin = function () {
                var elementType = this.ReadUInt8();
                var size = this.ReadUInt32();
                return new Bond.ContainerTag(elementType, size);
            };

            CompactBinaryProtocolReader.prototype.ReadContainerEnd = function () {
            };

            CompactBinaryProtocolReader.prototype.ReadDouble = function () {
                var data = this._buffer.splice(0, 8);
                return Bond.Decoding.Double.GetNumber(data);
            };

            CompactBinaryProtocolReader.prototype.ReadFieldBegin = function () {
                var raw = this._ReadByte();
                var type = raw & 0x1f;
                var id = raw & (0x07 << 5);
                if (id == 0x07 << 5) {
                    id = 0x000000ff & this._ReadByte();
                    id |= (0x000000ff & this._ReadByte()) << 8;
                } else if (id == 0x06 << 5) {
                    id = this._ReadByte();
                } else {
                    id >>= 5;
                }

                return new Bond.FieldTag(type, id);
            };

            CompactBinaryProtocolReader.prototype.ReadFieldEnd = function () {
            };

            CompactBinaryProtocolReader.prototype.ReadFloat = function () {
                var data = this._buffer.splice(0, 4);
                return Bond.Decoding.Float.GetNumber(data);
            };

            CompactBinaryProtocolReader.prototype.ReadInt16 = function () {
                return Bond.Decoding.Zigzag.DecodeZigzag16(this.ReadUInt16());
            };

            CompactBinaryProtocolReader.prototype.ReadInt32 = function () {
                return Bond.Decoding.Zigzag.DecodeZigzag32(this.ReadUInt32());
            };

            CompactBinaryProtocolReader.prototype.ReadInt64 = function () {
                return Bond.Decoding.Zigzag.DecodeZigzag64(this.ReadUInt64());
            };

            CompactBinaryProtocolReader.prototype.ReadInt8 = function () {
                var byte = this._ReadByte();
                return byte << 24 >> 24;
            };

            CompactBinaryProtocolReader.prototype.ReadKeyValueContainerBegin = function () {
                var keyType = this.ReadUInt8();
                var valueType = this.ReadUInt8();
                var size = this.ReadUInt32();
                return new Bond.KeyValueContainerTag(keyType, valueType, size);
            };

            CompactBinaryProtocolReader.prototype.ReadKeyValueContainerEnd = function () {
            };

            CompactBinaryProtocolReader.prototype.ReadString = function () {
                var size = Microsoft.Bond.Decoding.Varint.GetNumber(this._buffer);
                if (size == 0) {
                    return "";
                }

                return Bond.Decoding.Utf8.GetString(this._ReadBytes(size));
            };

            CompactBinaryProtocolReader.prototype.ReadStructBegin = function (isBase) {
            };

            CompactBinaryProtocolReader.prototype.ReadStructEnd = function () {
            };

            CompactBinaryProtocolReader.prototype.ReadUInt16 = function () {
                return Microsoft.Bond.Decoding.Varint.GetNumber(this._buffer);
            };

            CompactBinaryProtocolReader.prototype.ReadUInt32 = function () {
                return Microsoft.Bond.Decoding.Varint.GetNumber(this._buffer);
            };

            CompactBinaryProtocolReader.prototype.ReadUInt64 = function () {
                return Microsoft.Bond.Decoding.Varint.GetInt64(this._buffer);
            };

            CompactBinaryProtocolReader.prototype.ReadUInt8 = function () {
                return this._ReadByte();
            };

            CompactBinaryProtocolReader.prototype.ReadWString = function () {
                var size = Microsoft.Bond.Decoding.Varint.GetNumber(this._buffer);
                var str = [];
                for (var i = 0; i < size; ++i) {
                    var byte = this._ReadByte();
                    byte |= this._ReadByte() << 8;
                    str.push(String.fromCharCode(byte));
                }
                return str.join("");
            };

            CompactBinaryProtocolReader.prototype.Skip = function (type) {
                switch (type) {
                    case 9 /* BT_STRING */:
                        var size = this.ReadUInt32();
                        this._ReadBytes(size);
                        break;

                    case 18 /* BT_WSTRING */:
                        var size = this.ReadUInt32() << 1;
                        this._ReadBytes(size);
                        break;

                    case 11 /* BT_LIST */:
                    case 12 /* BT_SET */:
                        var listTag = this.ReadContainerBegin();
                        for (var i = 0; i < listTag.Size; ++i) {
                            this.Skip(listTag.ElementType);
                        }
                        this.ReadContainerEnd();
                        break;

                    case 13 /* BT_MAP */:
                        var mapTag = this.ReadKeyValueContainerBegin();
                        for (var i = 0; i < mapTag.Size; ++i) {
                            this.Skip(mapTag.KeyType);
                            this.Skip(mapTag.ValueType);
                        }
                        this.ReadContainerEnd();
                        break;

                    case 10 /* BT_STRUCT */:
                        var fieldTag;
                        do {
                            fieldTag = this.ReadFieldBegin();
                            while (fieldTag.Type != 0 /* BT_STOP */ && fieldTag.Type != 1 /* BT_STOP_BASE */) {
                                this.Skip(fieldTag.Type);
                                this.ReadFieldEnd();
                                fieldTag = this.ReadFieldBegin();
                            }
                        } while(fieldTag.Type != 0 /* BT_STOP */);
                        break;

                    case 2 /* BT_BOOL */:
                        this.ReadBool();
                        break;

                    case 3 /* BT_UINT8 */:
                        this.ReadUInt8();
                        break;

                    case 4 /* BT_UINT16 */:
                        this.ReadUInt16();
                        break;

                    case 5 /* BT_UINT32 */:
                        this.ReadUInt32();
                        break;

                    case 6 /* BT_UINT64 */:
                        this.ReadUInt64();
                        break;

                    case 7 /* BT_FLOAT */:
                        this.ReadFloat();
                        break;

                    case 8 /* BT_DOUBLE */:
                        this.ReadDouble();
                        break;

                    case 14 /* BT_INT8 */:
                        this.ReadInt8();
                        break;

                    case 15 /* BT_INT16 */:
                        this.ReadInt16();
                        break;

                    case 16 /* BT_INT32 */:
                        this.ReadInt32();
                        break;

                    case 17 /* BT_INT64 */:
                        this.ReadInt64();
                        break;

                    default:
                        throw new Bond.Exception("Unknown type to skip: " + type);
                }
            };

            CompactBinaryProtocolReader.prototype._ReadByte = function () {
                return this._buffer.shift();
            };

            CompactBinaryProtocolReader.prototype._ReadBytes = function (count) {
                return this._buffer.splice(0, count);
            };
            return CompactBinaryProtocolReader;
        })();
        Bond.CompactBinaryProtocolReader = CompactBinaryProtocolReader;
    })(Microsoft.Bond || (Microsoft.Bond = {}));
    var Bond = Microsoft.Bond;
})(Microsoft || (Microsoft = {}));
var sct;
(function (sct) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.IsSafari = function () {
            if (Utils._isSafari === null) {
                Utils._DetectBrowser();
            }
            return Utils._isSafari;
        };

        //
        // options: {
        //      type:   "GET" or "POST",
        //      url:
        //      headers: {
        //          key1: value1
        //          key2: value2
        //      },
        //      complete: function(xhr)
        // }
        //
        Utils.ajax = function (options) {
            var conn = Utils._createConnection();

            // for connection can't set the header, encode header to query parameters.
            if (!conn.setRequestHeader && options.headers) {
                var params = "read-from-query-string-instead-of-headers=true";
                for (var key in options.headers) {
                    params += "&";
                    params += encodeURIComponent(key);
                    params += "=";
                    params += encodeURIComponent(options.headers[key]);
                }

                if (options.url.indexOf("?") < 0) {
                    options.url += "?";
                } else {
                    options.url += "&";
                }
                options.url += params;
            }

            conn.open(options.type, options.url);
            if (conn.setRequestHeader && options.headers) {
                for (var key in options.headers) {
                    conn.setRequestHeader(key, options.headers[key]);
                }
            }

            if (options.complete) {
                conn.onload = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 200;
                    }
                    options.complete(conn);
                };

                conn.ontimeout = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 500;
                    }
                    options.complete(conn);
                };

                conn.onerror = function () {
                    options.complete(conn);
                };
            }

            conn.send(options.data);
        };

        // This is a workaround for IE8. That it does not support
        // Object.keys.
        Utils.keys = function (dict) {
            if (Object.keys) {
                return Object.keys(dict);
            } else {
                var keys = [];
                for (var eachKey in dict) {
                    if (dict.hasOwnProperty(eachKey)) {
                        keys.push(eachKey);
                    }
                }
                return keys;
            }
        };
        Utils.IsUsingXDomainRequest = function () {
            if (Utils._usingXDomainRequest == null) {
                var conn = new XMLHttpRequest();
                if (typeof conn.withCredentials == "undefined" && typeof XDomainRequest != "undefined") {
                    Utils._usingXDomainRequest = true;
                } else {
                    Utils._usingXDomainRequest = false;
                }
            }
            return Utils._usingXDomainRequest;
        };

        Utils._createConnection = function () {
            // for all browsers create standard XMLHttpRequest();
            var conn = new XMLHttpRequest();
            if (Utils.IsUsingXDomainRequest()) {
                // this is IE8/IE9, we should use XDomainRequest to support cross domain
                return new XDomainRequest();
            }
            return conn;
        };

        Utils._DetectBrowser = function () {
            var ua = navigator.userAgent.toLowerCase();
            if (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0) {
                Utils._isSafari = true;
            } else {
                Utils._isSafari = false;
            }
        };
        Utils._isSafari = null;
        Utils._usingXDomainRequest = null;
        return Utils;
    })();
    sct.Utils = Utils;
})(sct || (sct = {}));
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : DataPackage.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
var clienttelemetry;
(function (clienttelemetry) {
    (function (data) {
        var utils = (function () {
            function utils() {
            }
            utils.GetGuid = function () {
                var rd = function () {
                    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1, 5);
                };
                return [rd(), rd(), '-', rd(), rd(), '-', rd(), '-', rd(), rd()].join("");
            };

            utils.GetTimeStamp = function () {
                var val = new Date().getTime();
                var timestamp = new Microsoft.Bond.Int64("0");
                timestamp.low = val & 0xffffffff;
                timestamp.high = Math.floor(val / 0x100000000);
                return timestamp;
            };
            return utils;
        })();
        data.utils = utils;

        (function (v1) {
            var Pstn = (function () {
                function Pstn() {
                    // 1: optional string PstnNumber
                    this.PstnNumber = "";
                    // 2: optional string HashedPstn
                    this.HashedPstn = "";
                }
                Pstn.prototype.Write = function (writer) {
                    this.WriteImpl(writer, false);
                };

                Pstn.prototype.WriteImpl = function (writer, isBase) {
                    writer.WriteStructBegin(null, isBase);

                    if (this.PstnNumber != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 1, null);
                        writer.WriteString(this.PstnNumber);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 1, null);
                    }
                    if (this.HashedPstn != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 2, null);
                        writer.WriteString(this.HashedPstn);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 2, null);
                    }
                    writer.WriteStructEnd(isBase);
                };

                Pstn.prototype.Read = function (reader) {
                    this.ReadImpl(reader, false);
                };

                Pstn.prototype.ReadImpl = function (reader, isBase) {
                    reader.ReadStructBegin(isBase);

                    while (true) {
                        var fieldTag = reader.ReadFieldBegin();
                        if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                            break;
                        }

                        switch (fieldTag.Id) {
                            case 1:
                                this.PstnNumber = reader.ReadString();
                                break;

                            case 2:
                                this.HashedPstn = reader.ReadString();
                                break;

                            default:
                                reader.Skip(fieldTag.Type);
                                break;
                        }
                        reader.ReadFieldEnd();
                    }
                    reader.ReadStructEnd();
                };
                return Pstn;
            })();
            v1.Pstn = Pstn;

            var Endpoint = (function () {
                function Endpoint() {
                    // 1: optional string EndpointValue
                    this.EndpointValue = "";
                    // 2: optional string EndpointType
                    this.EndpointType = "";
                    // 3: optional string HashedEndpoint
                    this.HashedEndpoint = "";
                }
                Endpoint.prototype.Write = function (writer) {
                    this.WriteImpl(writer, false);
                };

                Endpoint.prototype.WriteImpl = function (writer, isBase) {
                    writer.WriteStructBegin(null, isBase);

                    if (this.EndpointValue != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 1, null);
                        writer.WriteString(this.EndpointValue);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 1, null);
                    }
                    if (this.EndpointType != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 2, null);
                        writer.WriteString(this.EndpointType);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 2, null);
                    }
                    if (this.HashedEndpoint != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 3, null);
                        writer.WriteString(this.HashedEndpoint);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 3, null);
                    }
                    writer.WriteStructEnd(isBase);
                };

                Endpoint.prototype.Read = function (reader) {
                    this.ReadImpl(reader, false);
                };

                Endpoint.prototype.ReadImpl = function (reader, isBase) {
                    reader.ReadStructBegin(isBase);

                    while (true) {
                        var fieldTag = reader.ReadFieldBegin();
                        if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                            break;
                        }

                        switch (fieldTag.Id) {
                            case 1:
                                this.EndpointValue = reader.ReadString();
                                break;

                            case 2:
                                this.EndpointType = reader.ReadString();
                                break;

                            case 3:
                                this.HashedEndpoint = reader.ReadString();
                                break;

                            default:
                                reader.Skip(fieldTag.Type);
                                break;
                        }
                        reader.ReadFieldEnd();
                    }
                    reader.ReadStructEnd();
                };
                return Endpoint;
            })();
            v1.Endpoint = Endpoint;

            var User = (function () {
                function User() {
                    // 1: optional string Username
                    this.Username = "";
                    // 2: optional string Prefix
                    this.Prefix = "";
                    // 3: optional string UiVersion
                    this.UiVersion = "";
                    // 4: optional string Endpoint
                    this.Endpoint = "";
                    // 5: optional string EndpointType
                    this.EndpointType = "";
                    // 6: optional clienttelemetry.data.v1.Pstn Pstn
                    this.Pstn = new clienttelemetry.data.v1.Pstn();
                    // 7: optional clienttelemetry.data.v1.Endpoint EndpointComposite
                    this.EndpointComposite = new clienttelemetry.data.v1.Endpoint();
                    // 8: optional map<string, string> UserExtension
                    this.UserExtension = new Microsoft.Bond.Collections.Map();
                }
                User.prototype.Write = function (writer) {
                    this.WriteImpl(writer, false);
                };

                User.prototype.WriteImpl = function (writer, isBase) {
                    writer.WriteStructBegin(null, isBase);

                    if (this.Username != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 1, null);
                        writer.WriteString(this.Username);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 1, null);
                    }
                    if (this.Prefix != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 2, null);
                        writer.WriteString(this.Prefix);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 2, null);
                    }
                    if (this.UiVersion != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 3, null);
                        writer.WriteString(this.UiVersion);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 3, null);
                    }
                    if (this.Endpoint != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 4, null);
                        writer.WriteString(this.Endpoint);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 4, null);
                    }
                    if (this.EndpointType != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 5, null);
                        writer.WriteString(this.EndpointType);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 5, null);
                    }
                    if (true) {
                        writer.WriteFieldBegin(10 /* BT_STRUCT */, 6, null);
                        this.Pstn.WriteImpl(writer, false);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(10 /* BT_STRUCT */, 6, null);
                    }
                    if (true) {
                        writer.WriteFieldBegin(10 /* BT_STRUCT */, 7, null);
                        this.EndpointComposite.WriteImpl(writer, false);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(10 /* BT_STRUCT */, 7, null);
                    }
                    if (this.UserExtension.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 8, null);
                        writer.WriteMapContainerBegin(this.UserExtension.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                        for (var i0 = 0; i0 < this.UserExtension.GetBuffer().length; ++i0) {
                            writer.WriteString(this.UserExtension.GetBuffer()[i0].Key);
                            writer.WriteString(this.UserExtension.GetBuffer()[i0].Value);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 8, null);
                    }
                    writer.WriteStructEnd(isBase);
                };

                User.prototype.Read = function (reader) {
                    this.ReadImpl(reader, false);
                };

                User.prototype.ReadImpl = function (reader, isBase) {
                    reader.ReadStructBegin(isBase);

                    while (true) {
                        var fieldTag = reader.ReadFieldBegin();
                        if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                            break;
                        }

                        switch (fieldTag.Id) {
                            case 1:
                                this.Username = reader.ReadString();
                                break;

                            case 2:
                                this.Prefix = reader.ReadString();
                                break;

                            case 3:
                                this.UiVersion = reader.ReadString();
                                break;

                            case 4:
                                this.Endpoint = reader.ReadString();
                                break;

                            case 5:
                                this.EndpointType = reader.ReadString();
                                break;

                            case 6:
                                this.Pstn = new clienttelemetry.data.v1.Pstn();
                                this.Pstn.ReadImpl(reader, false);
                                break;

                            case 7:
                                this.EndpointComposite = new clienttelemetry.data.v1.Endpoint();
                                this.EndpointComposite.ReadImpl(reader, false);
                                break;

                            case 8:
                                var i2 = reader.ReadKeyValueContainerBegin();
                                for (var i1 = 0; i1 < i2.Size; ++i1) {
                                    var i3 = "";
                                    var i4 = "";
                                    i3 = reader.ReadString();
                                    i4 = reader.ReadString();
                                    this.UserExtension.Add(i3, i4);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            default:
                                reader.Skip(fieldTag.Type);
                                break;
                        }
                        reader.ReadFieldEnd();
                    }
                    reader.ReadStructEnd();
                };
                return User;
            })();
            v1.User = User;

            var Record = (function () {
                function Record() {
                    // 1: optional string Id
                    this.Id = utils.GetGuid();
                    // 2: optional vector<string> Context
                    this.Context = [];
                    // 3: optional int64 Timestamp
                    this.Timestamp = utils.GetTimeStamp();
                    // 4: optional map<string, string> ConfigurationIds
                    this.ConfigurationIds = new Microsoft.Bond.Collections.Map();
                    // 5: optional string Type
                    this.Type = "";
                    // 6: optional string EventType
                    this.EventType = "";
                    // 7: optional int32 ResultCode
                    this.ResultCode = 0;
                    // 8: optional string ResultDetail
                    this.ResultDetail = "";
                    // 9: optional string ResultValue
                    this.ResultValue = "";
                    // 10: optional string InitiatingUser
                    this.InitiatingUser = "";
                    // 11: optional string InitiatingUserEndpoint
                    this.InitiatingUserEndpoint = "";
                    // 12: optional vector<string> TargetUsers
                    this.TargetUsers = [];
                    // 13: optional map<string, string> Extension
                    this.Extension = new Microsoft.Bond.Collections.Map();
                    // 14: optional int64 SampleTimestamp
                    this.SampleTimestamp = new Microsoft.Bond.Int64("0");
                    // 15: optional string SampleRate
                    this.SampleRate = "";
                    // 16: optional map<string, vector<int64>> SamplingData
                    this.SamplingData = new Microsoft.Bond.Collections.Map();
                    // 17: optional string InitiatingUiVersion
                    this.InitiatingUiVersion = "";
                    // 18: optional map<string, string> PstnNumbers
                    this.PstnNumbers = new Microsoft.Bond.Collections.Map();
                    // 19: optional map<string, string> ContextIds
                    this.ContextIds = new Microsoft.Bond.Collections.Map();
                    // 20: optional string InitiatingUserEndpointType
                    this.InitiatingUserEndpointType = "";
                    // 21: optional clienttelemetry.data.v1.User InitiatingUserComposite
                    this.InitiatingUserComposite = new clienttelemetry.data.v1.User();
                    // 22: optional vector<clienttelemetry.data.v1.User> TargetUsersComposite
                    this.TargetUsersComposite = [];
                    // 23: optional map<string, clienttelemetry.data.v1.Pstn> PstnNumbersComposite
                    this.PstnNumbersComposite = new Microsoft.Bond.Collections.Map();
                }
                Record.prototype.Write = function (writer) {
                    this.WriteImpl(writer, false);
                };

                Record.prototype.WriteImpl = function (writer, isBase) {
                    writer.WriteStructBegin(null, isBase);

                    if (this.Id != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 1, null);
                        writer.WriteString(this.Id);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 1, null);
                    }
                    if (this.Context.length) {
                        writer.WriteFieldBegin(11 /* BT_LIST */, 2, null);
                        writer.WriteContainerBegin(this.Context.length, 9 /* BT_STRING */);
                        for (var i5 = 0; i5 < this.Context.length; ++i5) {
                            writer.WriteString(this.Context[i5]);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(11 /* BT_LIST */, 2, null);
                    }
                    if (!this.Timestamp.Equals("0")) {
                        writer.WriteFieldBegin(17 /* BT_INT64 */, 3, null);
                        writer.WriteInt64(this.Timestamp);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(17 /* BT_INT64 */, 3, null);
                    }
                    if (this.ConfigurationIds.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 4, null);
                        writer.WriteMapContainerBegin(this.ConfigurationIds.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                        for (var i6 = 0; i6 < this.ConfigurationIds.GetBuffer().length; ++i6) {
                            writer.WriteString(this.ConfigurationIds.GetBuffer()[i6].Key);
                            writer.WriteString(this.ConfigurationIds.GetBuffer()[i6].Value);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 4, null);
                    }
                    if (this.Type != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 5, null);
                        writer.WriteString(this.Type);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 5, null);
                    }
                    if (this.EventType != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 6, null);
                        writer.WriteString(this.EventType);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 6, null);
                    }
                    if (this.ResultCode != 0) {
                        writer.WriteFieldBegin(16 /* BT_INT32 */, 7, null);
                        writer.WriteInt32(this.ResultCode);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(16 /* BT_INT32 */, 7, null);
                    }
                    if (this.ResultDetail != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 8, null);
                        writer.WriteString(this.ResultDetail);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 8, null);
                    }
                    if (this.ResultValue != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 9, null);
                        writer.WriteString(this.ResultValue);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 9, null);
                    }
                    if (this.InitiatingUser != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 10, null);
                        writer.WriteString(this.InitiatingUser);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 10, null);
                    }
                    if (this.InitiatingUserEndpoint != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 11, null);
                        writer.WriteString(this.InitiatingUserEndpoint);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 11, null);
                    }
                    if (this.TargetUsers.length) {
                        writer.WriteFieldBegin(11 /* BT_LIST */, 12, null);
                        writer.WriteContainerBegin(this.TargetUsers.length, 9 /* BT_STRING */);
                        for (var i7 = 0; i7 < this.TargetUsers.length; ++i7) {
                            writer.WriteString(this.TargetUsers[i7]);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(11 /* BT_LIST */, 12, null);
                    }
                    if (this.Extension.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 13, null);
                        writer.WriteMapContainerBegin(this.Extension.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                        for (var i8 = 0; i8 < this.Extension.GetBuffer().length; ++i8) {
                            writer.WriteString(this.Extension.GetBuffer()[i8].Key);
                            writer.WriteString(this.Extension.GetBuffer()[i8].Value);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 13, null);
                    }
                    if (!this.SampleTimestamp.Equals("0")) {
                        writer.WriteFieldBegin(17 /* BT_INT64 */, 14, null);
                        writer.WriteInt64(this.SampleTimestamp);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(17 /* BT_INT64 */, 14, null);
                    }
                    if (this.SampleRate != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 15, null);
                        writer.WriteString(this.SampleRate);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 15, null);
                    }
                    if (this.SamplingData.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 16, null);
                        writer.WriteMapContainerBegin(this.SamplingData.Count(), 9 /* BT_STRING */, 11 /* BT_LIST */);
                        for (var i9 = 0; i9 < this.SamplingData.GetBuffer().length; ++i9) {
                            writer.WriteString(this.SamplingData.GetBuffer()[i9].Key);
                            writer.WriteContainerBegin(this.SamplingData.GetBuffer()[i9].Value.length, 17 /* BT_INT64 */);
                            for (var i10 = 0; i10 < this.SamplingData.GetBuffer()[i9].Value.length; ++i10) {
                                writer.WriteInt64(this.SamplingData.GetBuffer()[i9].Value[i10]);
                            }
                            writer.WriteContainerEnd();
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 16, null);
                    }
                    if (this.InitiatingUiVersion != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 17, null);
                        writer.WriteString(this.InitiatingUiVersion);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 17, null);
                    }
                    if (this.PstnNumbers.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 18, null);
                        writer.WriteMapContainerBegin(this.PstnNumbers.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                        for (var i11 = 0; i11 < this.PstnNumbers.GetBuffer().length; ++i11) {
                            writer.WriteString(this.PstnNumbers.GetBuffer()[i11].Key);
                            writer.WriteString(this.PstnNumbers.GetBuffer()[i11].Value);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 18, null);
                    }
                    if (this.ContextIds.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 19, null);
                        writer.WriteMapContainerBegin(this.ContextIds.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                        for (var i12 = 0; i12 < this.ContextIds.GetBuffer().length; ++i12) {
                            writer.WriteString(this.ContextIds.GetBuffer()[i12].Key);
                            writer.WriteString(this.ContextIds.GetBuffer()[i12].Value);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 19, null);
                    }
                    if (this.InitiatingUserEndpointType != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 20, null);
                        writer.WriteString(this.InitiatingUserEndpointType);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 20, null);
                    }
                    if (true) {
                        writer.WriteFieldBegin(10 /* BT_STRUCT */, 21, null);
                        this.InitiatingUserComposite.WriteImpl(writer, false);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(10 /* BT_STRUCT */, 21, null);
                    }
                    if (this.TargetUsersComposite.length) {
                        writer.WriteFieldBegin(11 /* BT_LIST */, 22, null);
                        writer.WriteContainerBegin(this.TargetUsersComposite.length, 10 /* BT_STRUCT */);
                        for (var i13 = 0; i13 < this.TargetUsersComposite.length; ++i13) {
                            this.TargetUsersComposite[i13].WriteImpl(writer, false);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(11 /* BT_LIST */, 22, null);
                    }
                    if (this.PstnNumbersComposite.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 23, null);
                        writer.WriteMapContainerBegin(this.PstnNumbersComposite.Count(), 9 /* BT_STRING */, 10 /* BT_STRUCT */);
                        for (var i14 = 0; i14 < this.PstnNumbersComposite.GetBuffer().length; ++i14) {
                            writer.WriteString(this.PstnNumbersComposite.GetBuffer()[i14].Key);
                            this.PstnNumbersComposite.GetBuffer()[i14].Value.WriteImpl(writer, false);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 23, null);
                    }
                    writer.WriteStructEnd(isBase);
                };

                Record.prototype.Read = function (reader) {
                    this.ReadImpl(reader, false);
                };

                Record.prototype.ReadImpl = function (reader, isBase) {
                    reader.ReadStructBegin(isBase);

                    while (true) {
                        var fieldTag = reader.ReadFieldBegin();
                        if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                            break;
                        }

                        switch (fieldTag.Id) {
                            case 1:
                                this.Id = reader.ReadString();
                                break;

                            case 2:
                                var i15 = reader.ReadContainerBegin();
                                for (var i17 = 0; i17 < i15.Size; ++i17) {
                                    var i16 = "";
                                    i16 = reader.ReadString();
                                    this.Context.push(i16);
                                }
                                reader.ReadContainerEnd();
                                break;

                            case 3:
                                this.Timestamp = reader.ReadInt64();
                                break;

                            case 4:
                                var i19 = reader.ReadKeyValueContainerBegin();
                                for (var i18 = 0; i18 < i19.Size; ++i18) {
                                    var i20 = "";
                                    var i21 = "";
                                    i20 = reader.ReadString();
                                    i21 = reader.ReadString();
                                    this.ConfigurationIds.Add(i20, i21);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            case 5:
                                this.Type = reader.ReadString();
                                break;

                            case 6:
                                this.EventType = reader.ReadString();
                                break;

                            case 7:
                                this.ResultCode = reader.ReadInt32();
                                break;

                            case 8:
                                this.ResultDetail = reader.ReadString();
                                break;

                            case 9:
                                this.ResultValue = reader.ReadString();
                                break;

                            case 10:
                                this.InitiatingUser = reader.ReadString();
                                break;

                            case 11:
                                this.InitiatingUserEndpoint = reader.ReadString();
                                break;

                            case 12:
                                var i22 = reader.ReadContainerBegin();
                                for (var i24 = 0; i24 < i22.Size; ++i24) {
                                    var i23 = "";
                                    i23 = reader.ReadString();
                                    this.TargetUsers.push(i23);
                                }
                                reader.ReadContainerEnd();
                                break;

                            case 13:
                                var i26 = reader.ReadKeyValueContainerBegin();
                                for (var i25 = 0; i25 < i26.Size; ++i25) {
                                    var i27 = "";
                                    var i28 = "";
                                    i27 = reader.ReadString();
                                    i28 = reader.ReadString();
                                    this.Extension.Add(i27, i28);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            case 14:
                                this.SampleTimestamp = reader.ReadInt64();
                                break;

                            case 15:
                                this.SampleRate = reader.ReadString();
                                break;

                            case 16:
                                var i30 = reader.ReadKeyValueContainerBegin();
                                for (var i29 = 0; i29 < i30.Size; ++i29) {
                                    var i31 = "";
                                    var i32 = [];
                                    i31 = reader.ReadString();
                                    var i33 = reader.ReadContainerBegin();
                                    for (var i35 = 0; i35 < i33.Size; ++i35) {
                                        var i34 = new Microsoft.Bond.Int64("0");
                                        i34 = reader.ReadInt64();
                                        i32.push(i34);
                                    }
                                    reader.ReadContainerEnd();
                                    this.SamplingData.Add(i31, i32);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            case 17:
                                this.InitiatingUiVersion = reader.ReadString();
                                break;

                            case 18:
                                var i37 = reader.ReadKeyValueContainerBegin();
                                for (var i36 = 0; i36 < i37.Size; ++i36) {
                                    var i38 = "";
                                    var i39 = "";
                                    i38 = reader.ReadString();
                                    i39 = reader.ReadString();
                                    this.PstnNumbers.Add(i38, i39);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            case 19:
                                var i41 = reader.ReadKeyValueContainerBegin();
                                for (var i40 = 0; i40 < i41.Size; ++i40) {
                                    var i42 = "";
                                    var i43 = "";
                                    i42 = reader.ReadString();
                                    i43 = reader.ReadString();
                                    this.ContextIds.Add(i42, i43);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            case 20:
                                this.InitiatingUserEndpointType = reader.ReadString();
                                break;

                            case 21:
                                this.InitiatingUserComposite = new clienttelemetry.data.v1.User();
                                this.InitiatingUserComposite.ReadImpl(reader, false);
                                break;

                            case 22:
                                var i44 = reader.ReadContainerBegin();
                                for (var i46 = 0; i46 < i44.Size; ++i46) {
                                    var i45 = new clienttelemetry.data.v1.User();
                                    i45 = new clienttelemetry.data.v1.User();
                                    i45.ReadImpl(reader, false);
                                    this.TargetUsersComposite.push(i45);
                                }
                                reader.ReadContainerEnd();
                                break;

                            case 23:
                                var i48 = reader.ReadKeyValueContainerBegin();
                                for (var i47 = 0; i47 < i48.Size; ++i47) {
                                    var i49 = "";
                                    var i50 = new clienttelemetry.data.v1.Pstn();
                                    i49 = reader.ReadString();
                                    i50 = new clienttelemetry.data.v1.Pstn();
                                    i50.ReadImpl(reader, false);
                                    this.PstnNumbersComposite.Add(i49, i50);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            default:
                                reader.Skip(fieldTag.Type);
                                break;
                        }
                        reader.ReadFieldEnd();
                    }
                    reader.ReadStructEnd();
                };
                return Record;
            })();
            v1.Record = Record;

            var DataPackage = (function () {
                function DataPackage() {
                    // 1: optional string Type
                    this.Type = "";
                    // 2: optional string Source
                    this.Source = "";
                    // 3: optional string Version
                    this.Version = "";
                    // 4: optional map<string, string> Ids
                    this.Ids = new Microsoft.Bond.Collections.Map();
                    // 5: optional string DataPackageId
                    this.DataPackageId = "";
                    // 6: optional int64 Timestamp
                    this.Timestamp = new Microsoft.Bond.Int64("0");
                    // 7: optional int32 SchemaVersion
                    this.SchemaVersion = 0;
                    // 8: optional vector<clienttelemetry.data.v1.Record> Records
                    this.Records = [];
                    // 9: optional vector<clienttelemetry.data.v1.Record> Receipts
                    this.Receipts = [];
                }
                DataPackage.prototype.Write = function (writer) {
                    this.WriteImpl(writer, false);
                };

                DataPackage.prototype.WriteImpl = function (writer, isBase) {
                    writer.WriteStructBegin(null, isBase);

                    if (this.Type != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 1, null);
                        writer.WriteString(this.Type);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 1, null);
                    }
                    if (this.Source != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 2, null);
                        writer.WriteString(this.Source);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 2, null);
                    }
                    if (this.Version != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 3, null);
                        writer.WriteString(this.Version);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 3, null);
                    }
                    if (this.Ids.Count()) {
                        writer.WriteFieldBegin(13 /* BT_MAP */, 4, null);
                        writer.WriteMapContainerBegin(this.Ids.Count(), 9 /* BT_STRING */, 9 /* BT_STRING */);
                        for (var i51 = 0; i51 < this.Ids.GetBuffer().length; ++i51) {
                            writer.WriteString(this.Ids.GetBuffer()[i51].Key);
                            writer.WriteString(this.Ids.GetBuffer()[i51].Value);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(13 /* BT_MAP */, 4, null);
                    }
                    if (this.DataPackageId != "") {
                        writer.WriteFieldBegin(9 /* BT_STRING */, 5, null);
                        writer.WriteString(this.DataPackageId);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(9 /* BT_STRING */, 5, null);
                    }
                    if (!this.Timestamp.Equals("0")) {
                        writer.WriteFieldBegin(17 /* BT_INT64 */, 6, null);
                        writer.WriteInt64(this.Timestamp);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(17 /* BT_INT64 */, 6, null);
                    }
                    if (this.SchemaVersion != 0) {
                        writer.WriteFieldBegin(16 /* BT_INT32 */, 7, null);
                        writer.WriteInt32(this.SchemaVersion);
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(16 /* BT_INT32 */, 7, null);
                    }
                    if (this.Records.length) {
                        writer.WriteFieldBegin(11 /* BT_LIST */, 8, null);
                        writer.WriteContainerBegin(this.Records.length, 10 /* BT_STRUCT */);
                        for (var i52 = 0; i52 < this.Records.length; ++i52) {
                            this.Records[i52].WriteImpl(writer, false);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(11 /* BT_LIST */, 8, null);
                    }
                    if (this.Receipts.length) {
                        writer.WriteFieldBegin(11 /* BT_LIST */, 9, null);
                        writer.WriteContainerBegin(this.Receipts.length, 10 /* BT_STRUCT */);
                        for (var i53 = 0; i53 < this.Receipts.length; ++i53) {
                            this.Receipts[i53].WriteImpl(writer, false);
                        }
                        writer.WriteContainerEnd();
                        writer.WriteFieldEnd();
                    } else {
                        writer.WriteFieldOmitted(11 /* BT_LIST */, 9, null);
                    }
                    writer.WriteStructEnd(isBase);
                };

                DataPackage.prototype.Read = function (reader) {
                    this.ReadImpl(reader, false);
                };

                DataPackage.prototype.ReadImpl = function (reader, isBase) {
                    reader.ReadStructBegin(isBase);

                    while (true) {
                        var fieldTag = reader.ReadFieldBegin();
                        if (fieldTag.Type == 0 /* BT_STOP */ || fieldTag.Type == 1 /* BT_STOP_BASE */) {
                            break;
                        }

                        switch (fieldTag.Id) {
                            case 1:
                                this.Type = reader.ReadString();
                                break;

                            case 2:
                                this.Source = reader.ReadString();
                                break;

                            case 3:
                                this.Version = reader.ReadString();
                                break;

                            case 4:
                                var i55 = reader.ReadKeyValueContainerBegin();
                                for (var i54 = 0; i54 < i55.Size; ++i54) {
                                    var i56 = "";
                                    var i57 = "";
                                    i56 = reader.ReadString();
                                    i57 = reader.ReadString();
                                    this.Ids.Add(i56, i57);
                                }
                                reader.ReadKeyValueContainerEnd();
                                break;

                            case 5:
                                this.DataPackageId = reader.ReadString();
                                break;

                            case 6:
                                this.Timestamp = reader.ReadInt64();
                                break;

                            case 7:
                                this.SchemaVersion = reader.ReadInt32();
                                break;

                            case 8:
                                var i58 = reader.ReadContainerBegin();
                                for (var i60 = 0; i60 < i58.Size; ++i60) {
                                    var i59 = new clienttelemetry.data.v1.Record();
                                    i59 = new clienttelemetry.data.v1.Record();
                                    i59.ReadImpl(reader, false);
                                    this.Records.push(i59);
                                }
                                reader.ReadContainerEnd();
                                break;

                            case 9:
                                var i61 = reader.ReadContainerBegin();
                                for (var i63 = 0; i63 < i61.Size; ++i63) {
                                    var i62 = new clienttelemetry.data.v1.Record();
                                    i62 = new clienttelemetry.data.v1.Record();
                                    i62.ReadImpl(reader, false);
                                    this.Receipts.push(i62);
                                }
                                reader.ReadContainerEnd();
                                break;

                            default:
                                reader.Skip(fieldTag.Type);
                                break;
                        }
                        reader.ReadFieldEnd();
                    }
                    reader.ReadStructEnd();
                };
                return DataPackage;
            })();
            v1.DataPackage = DataPackage;
        })(data.v1 || (data.v1 = {}));
        var v1 = data.v1;
    })(clienttelemetry.data || (clienttelemetry.data = {}));
    var data = clienttelemetry.data;
})(clienttelemetry || (clienttelemetry = {}));
/** \file clienttelemetry.ts
This filed defined the clienttelemetry class.
\author yuboxie
\date 2013-12
*/
var clienttelemetry;
(function (clienttelemetry) {
    

    (function (CallbackEventType) {
        CallbackEventType[CallbackEventType["SENT"] = 0] = "SENT";
        CallbackEventType[CallbackEventType["SEND_FAILED"] = 1] = "SEND_FAILED";
    })(clienttelemetry.CallbackEventType || (clienttelemetry.CallbackEventType = {}));
    var CallbackEventType = clienttelemetry.CallbackEventType;

    (function (DATARV_ERROR) {
        DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_OK"] = 0] = "DATARV_ERROR_OK";
        DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_EVENT"] = 1] = "DATARV_ERROR_INVALID_EVENT";
        DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_CONFIG"] = 2] = "DATARV_ERROR_INVALID_CONFIG";
        DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_DEPENDENCIES"] = 3] = "DATARV_ERROR_INVALID_DEPENDENCIES";
        DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_STATUS"] = 4] = "DATARV_ERROR_INVALID_STATUS";
        DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_ARG"] = 5] = "DATARV_ERROR_INVALID_ARG";
    })(clienttelemetry.DATARV_ERROR || (clienttelemetry.DATARV_ERROR = {}));
    var DATARV_ERROR = clienttelemetry.DATARV_ERROR;

    var Exception = (function () {
        function Exception(errorCode) {
            this._errorCode = 0 /* DATARV_ERROR_OK */;
            this._errorCode = errorCode;
        }
        Exception.prototype.ErrorCode = function () {
            return this._errorCode;
        };

        Exception.prototype.toString = function () {
            switch (this._errorCode) {
                case 0 /* DATARV_ERROR_OK */:
                    return "DATARV_ERROR_OK";
                case 1 /* DATARV_ERROR_INVALID_EVENT */:
                    return "DATARV_ERROR_INVALID_EVENT";
                case 2 /* DATARV_ERROR_INVALID_CONFIG */:
                    return "DATARV_ERROR_INVALID_CONFIG";
                case 3 /* DATARV_ERROR_INVALID_DEPENDENCIES */:
                    return "DATARV_ERROR_INVALID_DEPENDENCIES";
                case 4 /* DATARV_ERROR_INVALID_STATUS */:
                    return "DATARV_ERROR_INVALID_STATUS";
                case 5 /* DATARV_ERROR_INVALID_ARG */:
                    return "DATARV_ERROR_INVALID_ARG";
                default:
                    return "Unknown error";
            }
        };
        return Exception;
    })();
    clienttelemetry.Exception = Exception;

    /** TelemetryConfig of TelemetryManager.
    
    \note
    TelemetryManager will hold the reference of this config. After you invoke
    Initialize(), you should never modify any content of this config object.
    Otherwise, the behavior is undefined.
    */
    var TelemetryConfig = (function () {
        function TelemetryConfig() {
        }
        return TelemetryConfig;
    })();
    clienttelemetry.TelemetryConfig = TelemetryConfig;

    var TelemetryManagerFactory = (function () {
        function TelemetryManagerFactory() {
        }
        TelemetryManagerFactory.CreateTelemetryManager = function () {
            return new TelemetryManagerImpl();
        };
        return TelemetryManagerFactory;
    })();
    clienttelemetry.TelemetryManagerFactory = TelemetryManagerFactory;

    //
    // const
    //
    var Consts = (function () {
        function Consts() {
        }
        Consts.MaxPackageSizeInBytes = function () {
            return 3 * 1000 * 1000;
        };
        Consts.TimeIntervalForNextSendInMS = function () {
            return 2 * 1000;
        };
        return Consts;
    })();

    //
    // Impl
    //
    /** TelemetryManager status.
    
    \note
    The status order is very important, don't modify it unless you know what you are doing.
    */
    var TelemetryManagerStatus;
    (function (TelemetryManagerStatus) {
        TelemetryManagerStatus[TelemetryManagerStatus["Created"] = 0] = "Created";
        TelemetryManagerStatus[TelemetryManagerStatus["Initialized"] = 1] = "Initialized";
        TelemetryManagerStatus[TelemetryManagerStatus["Started"] = 2] = "Started";
    })(TelemetryManagerStatus || (TelemetryManagerStatus = {}));

    var TelemetryManagerImpl = (function () {
        function TelemetryManagerImpl() {
            this._MaxPackageSizeInBytes = Consts.MaxPackageSizeInBytes();
            this._listeners = [];
            this._status = 0 /* Created */;
            this._ecsClient = null;
            this._etag = null;
            this._ecsCallback = null;
        }
        TelemetryManagerImpl.prototype.Initialize = function (config) {
            if (this._status != 0 /* Created */) {
                throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
            }

            if (!config || !config.collectorUrl || !config.uiVersion) {
                throw new Exception(2 /* DATARV_ERROR_INVALID_CONFIG */);
            }

            this._config = config;
            this._Reset();
            this._status = 1 /* Initialized */;

            if (config.ecsClient) {
                this._Verbose("ECS object assigned. Do integration");
                this._ecsClient = config.ecsClient;
            }

            this._Verbose("Initialize() done");
        };

        TelemetryManagerImpl.prototype.AddListener = function (func) {
            if (this._status < 1 /* Initialized */) {
                throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
            }

            this._Verbose([
                "AddListener(), status: ", this._status,
                " old length: ", this._listeners.length,
                " func: ", func].join(""));

            for (var i = 0; i < this._listeners.length; ++i) {
                if (this._listeners[i] == func) {
                    this._Verbose("the listener has been added already, index: " + i);
                    return;
                }
            }

            this._listeners.push(func);

            this._Verbose("AddListener() done, the new length: " + this._listeners.length);
        };

        TelemetryManagerImpl.prototype.RemoveListener = function (func) {
            if (this._status < 1 /* Initialized */) {
                throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
            }

            this._Verbose([
                "RemoveListener(), status: ", this._status,
                " old length: ", this._listeners.length,
                " func: ", func].join(""));

            for (var i = 0; i < this._listeners.length; ++i) {
                if (this._listeners[i] == func) {
                    if (this._listeners.length == 1) {
                        this._listeners = [];
                    } else if (i == this._listeners.length - 1) {
                        this._listeners.pop();
                    } else {
                        this._listeners[i] = this._listeners.pop();
                    }
                    this._Verbose([
                        "this listener has been found, index: ", i,
                        "new length: ", this._listeners.length].join(""));
                    return;
                }
            }

            this._Verbose("listener isn't been found, new length" + this._listeners.length);
        };

        TelemetryManagerImpl.prototype.Start = function () {
            // If it hasn't been initialized, throw exception.
            if (this._status < 1 /* Initialized */) {
                throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
            }

            this._Verbose([
                "Start(), status:", this._status,
                "tag:", TelemetryManagerImpl._tag].join(" "));

            if (this._status >= 2 /* Started */) {
                this._Verbose("Start() already, ignore");
            }

            if (this._ecsClient) {
                this._ecsCallback = this._CreateEcsCallback();
                this._ecsClient.AddListener(this._ecsCallback);
                this._etag = this._ecsClient.GetETag();
            }

            // change the status to started.
            ++TelemetryManagerImpl._tag;
            this._status = 2 /* Started */;

            this._Verbose([
                "Start() done, status: ", this._status,
                "tag: ", TelemetryManagerImpl._tag].join(""));
        };

        TelemetryManagerImpl.prototype.Stop = function () {
            // If it hasn't been initialized, throw exception.
            if (this._status < 1 /* Initialized */) {
                throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
            }

            this._Verbose("Stop(), status: " + this._status);

            if (this._status == 1 /* Initialized */) {
                this._Verbose("Stop() already, ignore");
                return;
            }

            //
            // do stop work
            //
            // 1. cleanup states
            this._Reset();

            // 2. reset status to initailzied
            this._status = 1 /* Initialized */;

            this._Verbose("Stop() done, status: " + this._status);
        };

        TelemetryManagerImpl.prototype.SendAsync = function (source, events) {
            if (this._status < 1 /* Initialized */) {
                throw new Exception(4 /* DATARV_ERROR_INVALID_STATUS */);
            }

            this._Verbose([
                "SendAsync(), status:", this._status,
                "source:", source,
                "count:", events.length].join(" "));

            if (this._status < 2 /* Started */) {
                this._Info("SendAsync(), not started, ignore, return false");
                return false;
            }

            // check the input parameters
            if (!source || !events) {
                this._Error("SendAsync(), source or events is null or empty");
                throw new Exception(5 /* DATARV_ERROR_INVALID_ARG */);
            }

            for (var i = 0; i < events.length; ++i) {
                if (!events[i].Id || !events[i].EventType || events[i].Timestamp.Equals("0")) {
                    this._Error([
                        "eventId:", events[i].Id,
                        "eventType:", events[i].EventType,
                        "timestamp high:", events[i].Timestamp.high,
                        "timestamp low:", events[i].Timestamp.low].join(""));

                    throw new Exception(1 /* DATARV_ERROR_INVALID_EVENT */);
                }

                if (!events[i].InitiatingUserComposite.UiVersion) {
                    events[i].InitiatingUserComposite.UiVersion = this._config.uiVersion;
                }
                if (this._etag && this._etag.length) {
                    this._Verbose("ETag detected.");
                    events[i].ConfigurationIds.Add("ecs_etag", this._etag);
                }
            }

            // put all events in events queue
            this._eventsCache.AddEvents(source, events);

            this._Verbose([
                "SendAsync(), currentTimer: ", this._timer,
                "eventsCacheIsEmpty", this._eventsCache.IsEmpty()].join(" "));

            // if the events queue are not empty, and we haven't schedule the send
            // action, schedule it at once.
            // Don't invoke _WorkThread() directly, otherwise, it may block UI.
            if (!this._eventsCache.IsEmpty() && !this._timer) {
                this._ScheduleTimer(false);
            }

            this._Verbose("SendAsync() done");
            return true;
        };

        TelemetryManagerImpl.prototype._WorkThread = function () {
            var _this = this;
            try  {
                this._Verbose("_WorkThread, status: " + this._status);

                if (this._status < 2 /* Started */) {
                    this._Verbose("_WorkThread, status is not started, return");
                    return;
                }

                // dequeue one source events
                var item = this._eventsCache.DequeuEvents();
                if (item == null) {
                    this._Verbose("_WorkThread, No events found, return");

                    // no more events need process, so clear the timer and return
                    this._CleanTimer();
                    return;
                }

                // pack the events and send
                var result = this._PackEvents(item.source, item.events);

                // add unsend events back to the queue
                this._eventsCache.AddEvents(item.source, result.remainedEvents);

                var postParams = {
                    type: "POST",
                    url: this._config.collectorUrl,
                    processData: false,
                    headers: {
                        "content-type": "application/bond-compact-binary"
                    },
                    complete: function (xhr) {
                        return _this._SendCallback(tag, item.source, result.sendEvents, xhr);
                    }
                };

                if (sct.Utils.IsSafari() || typeof Uint8Array == "undefined") {
                    this._Verbose("Uint8Array is undefined, send with base64 encode.");

                    postParams["data"] = Microsoft.Bond.Encoding.Base64.GetString(result.buffer);
                    postParams["headers"] = {
                        "content-type": "application/bond-compact-binary",
                        "content-encoding": "base64"
                    };
                } else {
                    this._Verbose("Uint8Array is defined, send with binary format directly.");

                    postParams["data"] = new Uint8Array(result.buffer);
                }

                // send it via jquery
                var tag = TelemetryManagerImpl._tag;

                this._lastActiveTime = new Date().getTime();

                sct.Utils.ajax(postParams);

                this._Verbose("_Workthread, send via jquery, tag: " + tag);
            } catch (ex) {
                this._Error("_WorkThread, exception: " + ex);
            }
        };

        /** Package all events to a package.
        
        return value is json object:
        {
        buffer: bond serialize buffer (binary data),
        sendEvents: the events are packaged.
        },
        
        events contains unpackaged events.
        */
        TelemetryManagerImpl.prototype._PackEvents = function (source, events) {
            this._Verbose("_PackageEvents, total Count: " + events.length);

            // create the data package
            var pkg = new clienttelemetry.data.v1.DataPackage();
            pkg.Type = "Client";
            pkg.Source = source;
            pkg.Version = clienttelemetry_build.version;
            pkg.DataPackageId = clienttelemetry.data.utils.GetGuid();
            pkg.Timestamp = clienttelemetry.data.utils.GetTimeStamp();
            pkg.SchemaVersion = 2;
            pkg.Ids.Add("service_id", "1");

            // first, try to send all events
            var buffer;
            var sendEvents = events;
            events = [];
            while (true) {
                pkg.Records = [];
                pkg.Records.push.apply(pkg.Records, sendEvents);
                buffer = this._Serialize(pkg);
                this._Verbose([
                    "_PackageEvents, sendEvents.length:", sendEvents.length,
                    "buffer.length:", buffer.length,
                    "MaxPackageSize:", this._MaxPackageSizeInBytes].join(""));

                if (sendEvents.length == 1 || buffer.length < this._MaxPackageSizeInBytes) {
                    break;
                }

                // too large, we must reduce it.
                var tmp = sendEvents.splice(0, Math.floor(sendEvents.length / 2));
                this._Verbose("_PackageEvents, too large, package again");

                // add the rest events back to events;
                events.push.apply(events, sendEvents);
                sendEvents = tmp;
            }

            this._Verbose([
                "_PakcageEvents done, sendEventsCount:", sendEvents.length,
                "buffer.length:", buffer.length,
                "remained events:", events.length].join(""));

            return { buffer: buffer, sendEvents: sendEvents, remainedEvents: events };
        };

        TelemetryManagerImpl.prototype._Serialize = function (pkg) {
            var stream = new Microsoft.Bond.IO.MemoryStream();
            var writer = new Microsoft.Bond.CompactBinaryProtocolWriter(stream);
            pkg.Write(writer);
            return stream.GetBuffer();
        };

        /** This function will handle the callback from ajax
        */
        TelemetryManagerImpl.prototype._SendCallback = function (tag, source, events, jqXHR) {
            this._Verbose([
                "_SendCallback",
                "tag:", tag,
                "current tag:", TelemetryManagerImpl._tag,
                "source:", source,
                "events count:", events.length,
                "jqXHR:", jqXHR].join(""));

            var isSuccess = jqXHR != null && jqXHR.status >= 200 && jqXHR.status < 300;

            // if the status is not sending (user may invoke Stop()), do nothing
            if (this._status < 2 /* Started */ || tag < TelemetryManagerImpl._tag) {
                this._Verbose("_SendCallback, is not started, or tag is not the same, return");
                return;
            }

            // if need retry, put the events back to the events queue and
            // try it later. 400 means the data format is not correct, so
            // don't retry for this case.
            //
            // for IE 8/IE 9, there is no way to get the status code, don't retry also.
            if (!isSuccess && (!jqXHR || jqXHR.status && jqXHR.status != 400)) {
                this._Verbose("retry statusCode: " + (jqXHR ? jqXHR.status : 0));
                this._eventsCache.AddEvents(source, events);
                this._ScheduleTimer(true);
                return;
            }

            for (var i = 0; i < this._listeners.length; ++i) {
                this._listeners[i](isSuccess ? 0 /* SENT */ : 1 /* SEND_FAILED */, (jqXHR ? jqXHR.status : 0), events);
            }

            // schedule for next check if necessary
            if (!this._eventsCache.IsEmpty()) {
                this._Verbose("eventsCache is not empty, schedule for next run");
                this._ScheduleTimer(false);
            } else {
                this._Verbose("eventsCache is empty, stop schedule");
                this._CleanTimer();
            }
        };

        TelemetryManagerImpl.prototype._CleanTimer = function () {
            this._Verbose("_CleanTimer(), timer: " + this._timer);
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }
        };

        /** Schedule Retry.
        
        This function will schedule re-try after X seconds. X value is determined
        by the following algorithm:
        1. for the 1st, X is a random value between 5~10 (5*2^0~5*2^1).
        2. for the 2nd, X is a random value between 10~20 (5*2^1~5*2^2).
        3. for the 3rd, X is a random value between 20~40 (5*2^2~5*2^3).
        4. for the 4th, X is a random value between 40~80 (5*2^3~5*2^4).
        5. for the 5th, X is a random value between 80~160 (5*2^4~5*2^5).
        6. for the 6th, X is a random value between 160~320 (5*2^5~5*2^6).
        7. Go back to 1.
        */
        TelemetryManagerImpl.prototype._ScheduleTimer = function (isRetry) {
            var _this = this;
            this._Verbose("_ScheduleTimer: isRetry: " + isRetry);

            // clear previous timer always.
            this._CleanTimer();

            if (!isRetry) {
                // next send will be in at least 2 seconds later
                var X = 0;
                var now = new Date().getTime();
                var late = now - this._lastActiveTime;
                if (late > Consts.TimeIntervalForNextSendInMS()) {
                    // we haven't scheduled in last 2 seconds, so schedult it at once.
                    X = 0;
                } else {
                    X = Consts.TimeIntervalForNextSendInMS() - late;
                }

                this._timer = setTimeout(function () {
                    return _this._WorkThread();
                }, X);
                this._Verbose("_ScheduleTimer, next try: " + X);
                this._rescheduleFactor = 1;
            } else {
                // retry
                this._Verbose("_ScheduleTimer, current factor: " + this._rescheduleFactor);

                var X = Math.floor(5 * this._rescheduleFactor * (1 + Math.random()));
                this._timer = setTimeout(function () {
                    return _this._WorkThread();
                }, X * 1000);
                this._Verbose("_ScheduleTimer, next try: " + X);

                this._rescheduleFactor <<= 1;
                if (this._rescheduleFactor > 64) {
                    this._rescheduleFactor = 1;
                }
            }
        };

        //
        // Log functions
        //
        TelemetryManagerImpl.prototype._Verbose = function (msg) {
            if (this._config.log) {
                this._config.log.Verbose("[TelemetryManagerImpl]: " + msg);
            }
        };

        TelemetryManagerImpl.prototype._Info = function (msg) {
            if (this._config.log) {
                this._config.log.Info("[TelemetryManagerImpl]: " + msg);
            }
        };

        TelemetryManagerImpl.prototype._Error = function (msg) {
            if (this._config.log) {
                this._config.log.Error("[TelemetryManagerImpl]: " + msg);
            }
        };

        /** Clean all stats without listener queue */
        TelemetryManagerImpl.prototype._Reset = function () {
            this._Verbose("Reset()");

            this._CleanTimer();

            this._lastActiveTime = 0;
            this._rescheduleFactor = 1;
            this._sendingEvents = [];
            this._eventsCache = new TelemetryEventCache();

            // 3. Shutdown listener
            if (this._ecsClient) {
                this._ecsClient.RemoveListener(this._ecsCallback);
                this._ecsCallback = null;
                // Keep _ecs uncleared, following C++ version.
            }
        };

        TelemetryManagerImpl.prototype._CreateEcsCallback = function () {
            var _this = this;
            return function (status) {
                if (status == 0 /* CONFIG_UPDATED */) {
                    // Use number as status to avoid dependency.
                    _this._etag = _this._ecsClient.GetETag();
                }
            };
        };

        /******* TEST_INJECTION_START *******/
        TelemetryManagerImpl.prototype.__GetListenerArray = function () {
            return this._listeners;
        };

        TelemetryManagerImpl.prototype.__GetTotalEventsCount = function () {
            return this._eventsCache.GetTotalEventsCount();
        };

        TelemetryManagerImpl.prototype.__IsScheduled = function () {
            return this._timer != null;
        };

        TelemetryManagerImpl.prototype.__ChageMaxPackageSizeInKB = function (size) {
            this._MaxPackageSizeInBytes = size * 1024;
        };
        TelemetryManagerImpl._tag = 0;
        return TelemetryManagerImpl;
    })();

    var TelemetryEventCache = (function () {
        function TelemetryEventCache() {
            this._events = {};
            this._sources = [];
        }
        TelemetryEventCache.prototype.AddEvents = function (source, events) {
            if (!events.length) {
                return;
            }

            if (!this._events[source]) {
                this._events[source] = [];
                this._sources.push(source);
            }
            this._events[source].push.apply(this._events[source], events);
        };

        TelemetryEventCache.prototype.IsEmpty = function () {
            return this._sources.length == 0;
        };

        TelemetryEventCache.prototype.DequeuEvents = function () {
            if (this._sources.length == 0) {
                return null;
            }

            var source = this._sources.shift();
            var events = this._events[source];
            delete this._events[source];
            return { source: source, events: events };
        };

        TelemetryEventCache.prototype.GetTotalEventsCount = function () {
            var sum = 0;
            for (var key in this._events) {
                sum += this._events[key].length;
            }
            return sum;
        };
        return TelemetryEventCache;
    })();
})(clienttelemetry || (clienttelemetry = {}));
/// <reference path="./utils.ts" />
/**
 * Telemetry layer for the API.
 *
 * Annoymous telemetry will be collected to understand usage, reliability and
 * performance of the APIs. This information will be used to design APIs that
 * better address customer needs and are more reliable.
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Telemetry;
        (function (Telemetry) {
            
            var Model = Skype.Web.Utils.Model;
            // SWX telemetry logger
            var externalTelemetryLogger = null, externalDefaultTelemetryUrl = 'https://pipe.skype.com/Client/2.0/', externalDefaultVersion = Skype.Web.version;
            // local API logger 
            var internalTelemetryLogger = null, internalTelemetryUrl = "https://pipe.int.trafficmanager.net/Client/2.0/", internalVersion = Skype.Web.version, ucwaAppId = null;
            /**
             * Called to create telemetry logger for both SWX and jLync.
             *
             * @param {String} url - where to send telemetry data.
             * @param {String} ver - version of component using the logger.
             *
             */
            function TelemetryLogger(url, ver) {
                var configuration = new clienttelemetry.TelemetryConfig();
                configuration.collectorUrl = url;
                configuration.uiVersion = ver;
                // Initialize and start SCT object.
                var telemetryLogger = clienttelemetry.TelemetryManagerFactory.CreateTelemetryManager();
                telemetryLogger.Initialize(configuration);
                telemetryLogger.Start();
                return telemetryLogger;
            }
            /**
            * Returns a telemetry logger that any component can use to send its own telemetry.
            *
            * @param {String} telemetryUrl - Either integration or production URL to Skype Data Pipeline.
            *
            * @method {SctEvent} createEvent - Return sct library event. Component can append needed data to it.
            * @method sendEvents
            *
            *
            * @example
            *
            *      tml = app.telemetryManager;
            *
            *      var event = tml.createEvent();
            *      event.EventType = 'signInCalled';
            *
            *      tml.sendEvents('componentName', [event]);
            */
            function initTelemetry(url) {
                try {
                    if (!externalTelemetryLogger) {
                        // default is production URL
                        url = url || externalDefaultTelemetryUrl;
                        externalTelemetryLogger = TelemetryLogger(url, externalDefaultVersion);
                    }
                }
                catch (_) {
                }
                return Model({
                    createEvent: function () {
                        return new clienttelemetry.data.v1.Record();
                    },
                    sendEvents: function (source, events) {
                        externalTelemetryLogger.SendAsync(source, events);
                    }
                });
            }
            Telemetry.initTelemetry = initTelemetry;
            /**
             * This id is used to correlate telemetry from jCafe with UCWA data.
             */
            function setKey(href) {
                try {
                    if (href) {
                        // get app id, 11880695890, from the URI /ucwa/oauth/v1/applications/11880695890"
                        ucwaAppId = /\/(\d+)/.exec(href)[1];
                    }
                }
                catch (ex) {
                }
            }
            Telemetry.setKey = setKey;
            /**
             * Create a new telemetry record with needed meta data and send it.
             *
             * @param {String} eventType - any string to distinguish different events.
             *
             * @example
             *
             *      record("SignIn_Failures");
             */
            function record(eventType) {
                try {
                    internalTelemetryLogger = internalTelemetryLogger || TelemetryLogger(internalTelemetryUrl, internalVersion);
                    // helps identify number of applications using the API.
                    // Avoid collecting search string of URLs to avoid PII data.
                    var app = location.protocol + location.host + location.pathname;
                    var event = new clienttelemetry.data.v1.Record();
                    event.EventType = 'jCafe_SfB_' + eventType;
                    event.Extension.Add('application', app);
                    if (ucwaAppId && eventType != 'SignIn') {
                        event.Extension.Add('ucwaAppId', ucwaAppId);
                    }
                    // send the event
                    internalTelemetryLogger.SendAsync('jCafe_SfB', [event]);
                }
                catch (ex) {
                }
            }
            Telemetry.record = record;
        })(Telemetry = Web.Telemetry || (Web.Telemetry = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=telemetry.js.map

/// <reference path="./ucwa.ts" />
/// <reference path="./media.ts" />
/// <reference path="./model.common.ts" />
/// <reference path="./telemetry.ts" />
/**
 * Implements media-related parts of the SkypeWeb model layer. These models are built
 * on top of the SkypeWeb's media and UCWA stacks.
 *
 * Media models are separated from messaging and presence models to avoid bringing
 * media-related code into a web app that does not utilize the media API of SkypeWeb.
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_1) {
            var Internal;
            (function (Internal) {
                
                var Settings = Skype.Web.Settings;
                //#region Imports (from Skype.Web.Telemetry)
                // APIs will work fine if telemetry is not available.
                var record = Skype.Web.Telemetry ? Skype.Web.Telemetry.record : function () { };
                //#endregion
                //#region Imports (from Skype.Web.Utils)
                var Utils = Skype.Web.Utils;
                var assert = Utils.assert;
                var DataUri = Utils.DataUri;
                var async = Utils.async;
                var Event = Utils.Event;
                var StringEnum = Utils.StringEnum;
                var Enum = Utils.Enum;
                var extend = Utils.extend;
                var indexOf = Utils.indexOf;
                var guid = Utils.guid;
                var isNotEmptyString = Utils.isNotEmptyString;
                var foreach = Utils.foreach;
                var ConstProperty = Utils.ConstProperty;
                var Property = Utils.Property;
                var Collection = Utils.Collection;
                var map = Utils.map;
                var freeze = Utils.freeze;
                var check = Utils.check;
                var Exception = Utils.Exception;
                var Task = Utils.Task;
                var filter = Utils.filter;
                var values = Utils.values;
                var contains = Utils.contains;
                var isEmptyObject = Utils.isEmptyObject;
                var isArray = Utils.isArray;
                var HttpHeaders = Utils.HttpHeaders;
                var EInvalidArgument = Utils.EInvalidArgument;
                var EWrongType = Utils.EWrongType;
                var ENotSupported = Utils.ENotSupported;
                var EInvalidState = Utils.EInvalidState;
                var EDoesNotExist = Utils.EDoesNotExist;
                var random = Utils.random;
                var Command = Utils.Command;
                var EnabledCommand = Utils.EnabledCommand;
                var inherit = Utils.inherit;
                var SourcedModel = Utils.SourcedModel;
                var bind = Utils.bind;
                var setHiddenProperty = Utils.setHiddenProperty;
                var BoolProperty = Utils.BoolProperty;
                var Model = Utils.Model;
                Utils = null;
                //#endregion
                //#region Imports (from Skype.Web.Stack)
                var Stack = Skype.Web.Stack;
                var parseMultipartRelatedResponse = Stack.Internal.Endpoint.parseMultipartRelatedResponse;
                Stack = null;
                //#endregion
                //#region Imports (from Skype.Web.Media)
                var Media = Skype.Web.Media;
                var PluginManager = Media.PluginManager;
                var UserAgent = Media.UserAgent;
                var PluginComponent = Media.PluginComponent;
                var log = Media.log;
                Media = null;
                //#endregion
                var sEscalation = {}; // denotes escalation as a reason for internal property change
                //#region MediaPolicies
                /**
                 * Wraps the rel=mediaPolicies resource into an observable model.
                 *
                 * rel=mediaPolicies represents a resource that allows clients to fetch
                 * all media-related settings that cannot be modeled as capability links
                 * or properties of individual resources. Most of them are directly consumed
                 * by media stack manager on the client side.
                 *
                 * @property bandwidthControl - Whether bandwidth control is enabled.
                 * @property fipsCompliantMedia - Whether to use FIPS approved algorithm for media stack (e.g. "NotRequired").
                 * @property poorDeviceWarnings - Whether the client should disable poor device warnings.
                 * @property poorNetworkWarnings - Whether the client should disable poor network warnings.
                 * @property portRange - Whether the port range is enabled (e.g. "Enabled").
                 * @property qualityOfService - Whether media quality of service should enabled for the media manager on the client (e.g. "Enabled").
                 *
                 * @property audioVideoEncryption - Whether audio/video encryption is enabled between two applications (e.g. "Supported" or "Enforced").
                 *
                 * @property audioBitRate - The audio bit rate (e.g. 200).
                 * @property audioBypass - Whether audio bypass is enabled (e.g. "Enabled").
                 * @property audioBypassId - The audio bypass id (e.g. "80850838-c860-4ea5-a032-653c28857b44").
                 * @property internalAudioBypassMode - Audio bypass mode when the client is communicating with internal side of the server (e.g. "Any").
                 * @property externalAudioBypassMode - Audio bypass mode when the client is communicating with external side of the server (e.g. "Off").
                 * @property minimumAudioPort - The minimum port for audio (e.g. 50000).
                 * @property maximumAudioPort - The maximum port for audio (e.g. 50019).
                 *
                 * @property minimumVideoPort - The minimum port for video (e.g. 50039).
                 * @property maximumVideoPort - The maximum port for video (e.g. 50039).
                 * @property maximumVideoRateAllowed - The maximum video rate allowed (e.g. "Hd720p-1.5M").
                 * @property multiViewJoin - Whether the client is enabled for multi-view join for video (e.g. "Enabled").
                 * @property totalReceivedVideoBitRateKB - The maximum bit rate for video (e.g. 50000).
                 * @property video - Whether video is enabled for the client (e.g. "Enabled").
                 * @property videoBitRate - The video bit rate (e.g. 50000).
                 *
                 * @property applicationSharingBitRate - The application sharing bit rate (e.g. 50000).
                 * @property applicationSharingEncryption - Whether encryption for application sharing is enabled (e.g. "Supported").
                 * @property minimumApplicationSharingPort - The minimum port for application sharing (e.g. 50040).
                 * @property maximumApplicationSharingPort - The maximum port for application sharing (e.g. 50059).
                 * @property highPerformanceApplicationSharingInOnlineMeeting - e.g. "Disabled"
                 *
                 */
                function MediaPolicies(ucwa) {
                    function tryParseInt(src) {
                        var num = +src | 0;
                        return num == src ? num : src;
                    }
                    return Internal.ObservableResource(ucwa, {
                        source: { rel: 'mediaPolicies' },
                        properties: {
                            bandwidthControl: {},
                            fipsCompliantMedia: {},
                            poorDeviceWarnings: {},
                            poorNetworkWarnings: {},
                            portRange: {},
                            qualityOfService: {},
                            audioVideoEncryption: {},
                            audioBitRate: tryParseInt,
                            audioBypass: {},
                            audioBypassId: {},
                            internalAudioBypassMode: {},
                            externalAudioBypassMode: {},
                            minimumAudioPort: tryParseInt,
                            maximumAudioPort: tryParseInt,
                            minimumVideoPort: tryParseInt,
                            maximumVideoPort: tryParseInt,
                            maximumVideoRateAllowed: {},
                            multiViewJoin: {},
                            totalReceivedVideoBitRateKB: tryParseInt,
                            video: {},
                            videoBitRate: tryParseInt,
                            applicationSharingBitRate: tryParseInt,
                            applicationSharingEncryption: {},
                            minimumApplicationSharingPort: tryParseInt,
                            maximumApplicationSharingPort: tryParseInt,
                            highPerformanceApplicationSharingInOnlineMeeting: {}
                        }
                    });
                }
                Internal.MediaPolicies = MediaPolicies;
                //#endregion
                //#region AudioVideoModality (internal)
                /**
                 * AudioVideo part of a multi-modal conversation.
                 *
                 * @param {Me} me
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 * @param {Devices} [devices] - Audio and video devices.
                 * @param {String} [threadId] - Required for outgoing calls.
                 * @param {AudioVideoInvitation} [invitation] - Required for incoming calls.
                 * @param {Collection} participants
                 * @param {Participant} selfParticipant
                 * @param {Resource} [rConversation] - The parent rel=conversation resource.
                 *
                 *      If the AV modality gets added to an existing conversation, the AV call
                 *      is started by sending a POST request to conversation/audioVideo/addAudioVideo.
                 *      If the AV modality is the first modality in the conversation, then the
                 *      AV call is started by sending the same request to the global startAudioVideo link.
                 *
                 * @param {Conversation} [conversation] - the parent conversation object
                 *
                 * @property {Modality.State} state
                 * @property {Boolean} muted - get/set whether the audio is muted
                 * @property {Boolean} onHold - get/set whether the audio/video is on hold
                 *
                 * @member {Participant} from
                 *
                 * @command {Promise} start - Starts an outgoing call.
                 * @command {Promise} accept - Accepts an incoming call.
                 * @command {Promise} decline - Declines an incoming call.
                 * @command {Promise} stop - Stops the call.
                 * @command {Promise} sendDtmf - Sends a DTMF tone.
                 * @command {Promise} showParticipantVideo
                 * @command {Promise} removeParticipantVideo
                 *
                 */
                function AudioVideoModality(options) {
                    var self = Model(), ucwa = options.ucwa, rInvitation = options.rInvitation, participants = options.participants, guestName = options.guestName, selfParticipant = options.selfParticipant, localUri = options.me.id(), remoteUri, mediaPlugin = options.mediaPlugin, devices = options.devices, conversation = options.conversation, rConversation = options.rConversation, avs, avsEsc, 
                    // multi-party conference
                    // a unique id of this modality - handy for debugging this modality's
                    // server event subscription
                    thisModalityId = random(), isAVInvitation = rInvitation && rInvitation.rel == 'audioVideoInvitation', isMeetingInvitation = rInvitation && rInvitation.rel == 'onlineMeetingInvitation', isAudioMeetingInvitation = isMeetingInvitation &&
                        conversation.meeting.availableModalities.audio(), isVideoMeetingInvitation = isMeetingInvitation &&
                        conversation.meeting.availableModalities.video(), 
                    // AudioVideoInvitation (for P2P incoming calls)
                    invitation = isAVInvitation &&
                        AudioVideoInvitation({
                            resource: rInvitation,
                            ucwa: ucwa,
                            from: getFrom(rInvitation)
                        }), rAVInvitation = isAVInvitation && rInvitation, sStartingAV = {}, 
                    // thread id - a unique id of the parent conversation is passed as param for the outgoing
                    // call or is extracted from the audioVideoInvitation for the incoming call
                    threadId = options.threadId || rInvitation && rInvitation.get('threadId'), state = Property({
                        value: invitation || isMeetingInvitation ?
                            Internal.Modality.State.Notified :
                            Internal.Modality.State.Disconnected
                    }), audioState = Property({
                        value: invitation || isAudioMeetingInvitation ?
                            Internal.Modality.State.Notified :
                            Internal.Modality.State.Disconnected
                    }), videoState = Property({
                        value: invitation && invitation.hasVideo() || isVideoMeetingInvitation ?
                            Internal.Modality.State.Notified :
                            Internal.Modality.State.Disconnected
                    });
                    options = null;
                    //#region public properties
                    // mutes/unmutes the audio channel or returns the mute status
                    var muted = Property({
                        value: false,
                        get: function () {
                            return avs.muted.get();
                        },
                        set: function (val) {
                            return avs.muted.set(val);
                        }
                    });
                    // holds/resumes audio/video or returns the onHold status
                    var onHold = Property({
                        value: false,
                        get: function () {
                            return avs.onHold.get();
                        },
                        set: function (val) {
                            return avs.onHold.set(val);
                        }
                    });
                    //#endregion
                    //#region init
                    function init() {
                        state.changed(function (newState, reason, oldState) {
                            log('AudioVideoModality(' + thisModalityId + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        audioState.changed(function (newState, reason, oldState) {
                            log('AudioVideoModality(' + thisModalityId + ')::audioState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        videoState.changed(function (newState, reason, oldState) {
                            log('AudioVideoModality(' + thisModalityId + ')::videoState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        state.when(Internal.Modality.State.Disconnected, reset);
                        // this is a permanent video state subscription to ensure that self-participant's video
                        // state is in fact AVM's video state.
                        // TODO: alternatively selfParticipant's videoState can be a sourced property of AVM.videoState.
                        videoState.changed(selfParticipant[Internal.sInternal].videoState);
                        extend(self, {
                            state: state.asReadOnly(),
                            audioState: audioState.asReadOnly(),
                            videoState: videoState.asReadOnly(),
                            muted: muted,
                            onHold: onHold,
                            showParticipantVideo: showParticipantVideo,
                            removeParticipantVideo: removeParticipantVideo
                        });
                        if (invitation)
                            self.from = invitation.from;
                        ucwa.event(onServerEvent);
                        log('AudioVideoModality(' + thisModalityId + ') created');
                    }
                    //#endregion
                    //#region reset
                    function reset() {
                        if (avs) {
                            avs.state.changed.off(state);
                            avs.audioState.changed.off(audioState);
                            avs.videoState.changed.off(videoState);
                        }
                        state(Internal.Modality.State.Disconnected);
                        audioState(Internal.Modality.State.Disconnected);
                        videoState(Internal.Modality.State.Disconnected);
                        rAVInvitation = null;
                        avs = null;
                    }
                    //#endregion
                    //#region private utils and event handlers
                    function defineAsyncCommand(name, states, method) {
                        var enabled = Property();
                        self[name] = Command(async(method), enabled);
                        state.changed(function (value) {
                            var isEnabled = contains(states, function (s) {
                                return isArray(s) ?
                                    value == s[0] && state.reason === s[1] :
                                    value == s;
                            });
                            enabled(isEnabled);
                        });
                    }
                    function isConferencing() {
                        var convState = rConversation && rConversation.get('state', '');
                        return convState == 'Conferencing' || convState == 'Conferenced';
                    }
                    // AudioVideoSession 'escalated' event handler
                    //   replaces the p2p session with the conference session if escalation succeeded;
                    //   destroys the conference session if escalation failed.
                    function onAVSessionEscalated(status) {
                        var fMuted;
                        if (status == 'success') {
                            fMuted = avs.muted();
                            // replace the old P2P AV session with the new AV conference session and
                            // delete the old session
                            avs.state.changed.off(state);
                            avs.audioState.changed.off(audioState);
                            avs.videoState.changed.off(videoState);
                            avs.stop(sEscalation);
                            avs = avsEsc;
                            avs.state.changed(state);
                            avs.audioState.changed(audioState);
                            avs.videoState.changed(videoState);
                            avsEsc.escalated.off(onAVSessionEscalated);
                            avsEsc = null;
                            if (fMuted)
                                avs.muted(fMuted);
                        }
                        else if (status == 'failure') {
                            avsEsc.escalated.off(onAVSessionEscalated);
                            avsEsc.stop();
                            avsEsc = null;
                        }
                        else {
                            assert(false);
                        }
                    }
                    // UCWA events handler
                    function onServerEvent(event) {
                        var id = event.target.rel + ' ' + event.type;
                        var r = event.resource;
                        switch (id) {
                            // when a new AV conversation is started (using rel=startAudioVideo)
                            // the conversation is added after this object is created.
                            case 'conversation added':
                                if (r.get('threadId') == threadId)
                                    rConversation = r;
                                break;
                            case 'conversation updated':
                                // add participants to a meeting created by this modality's start()
                                if (r.href == rConversation.href && isConferencing() && rConversation.hasLink('addParticipant'))
                                    conversation[Internal.sInternal].updateParticipants();
                                break;
                            case 'escalateAudio added':
                                if (event.sender.href == rConversation.href)
                                    startEscalation({
                                        uri: event.target.href
                                    });
                                break;
                            case 'escalateAudioVideo added':
                                if (event.sender.href == rConversation.href)
                                    startEscalation({
                                        uri: event.target.href,
                                        video: true // video container will be retained by the selfParticipant
                                    });
                                break;
                            case 'audioVideoInvitation completed':
                                // incoming invitation was canceled or timed out while this client ignored
                                // the invitation (neither accepted nor declined)
                                if (!avs && rAVInvitation && rAVInvitation.href == r.href &&
                                    r.get('direction') == 'Incoming' &&
                                    event.status == 'Failure') {
                                    state(Internal.Modality.State.Disconnected, event.reason);
                                }
                                break;
                            case 'audioVideoInvitation started':
                                // audioVideo can be added to an existing 1:1 conversation by the remote participant
                                if (r.has('direction') && r.get('direction') == 'Incoming' &&
                                    r.link('conversation').href == rConversation.href) {
                                    rAVInvitation = r;
                                    invitation = AudioVideoInvitation({
                                        resource: r,
                                        ucwa: ucwa,
                                        from: getFrom(r)
                                    });
                                    state(Internal.Modality.State.Notified);
                                    if (invitation.hasVideo())
                                        videoState(Internal.Modality.State.Notified);
                                    else
                                        audioState(Internal.Modality.State.Notified);
                                }
                                break;
                        }
                    }
                    // Finds a participant object that represents the inviter in the incoming call
                    //   The participant key in the participants collection can be either the participant href or the contact href.
                    //   The "from" participant resource embedded in the invitation has the participant href and the uri, so
                    //   we use either one to match the inviter.
                    function getFrom(rInvitation) {
                        var from = participants(rInvitation.link('from').href), rFrom, fromUri;
                        if (!from) {
                            rFrom = ucwa.get(rInvitation.link('from').href);
                            fromUri = rFrom.get('uri');
                            participants.each(function (p) {
                                if (p.person.id() == fromUri)
                                    from = p;
                            });
                        }
                        return from;
                    }
                    //#endregion
                    //#region public methods
                    /**
                     * Starts an outgoing audio/video call
                     *
                     * @param {String} to - SIP URI of the remote participant.
                     * @param {Dictionary|Boolean} [video] - If present, start both audio and video, otherwise only audio is started,
                     *                                       e.g. av.start({video: true});
                     * @param {HTMLElement} video.container - A DOM element that serves as the video window container for remote video,
                     *                                        e.g. av.start({video: {container: myElement}});
                     * @param {Object} [context] - An invitation context can accompany the generated audiovideo invitation.
                     *
                     * @returns {Promise}
                     */
                    defineAsyncCommand('start', [Internal.Modality.State.Connected, [Internal.Modality.State.Notified, sStartingAV], Internal.Modality.State.Disconnected], function (options) {
                        var isMeeting = conversation.isGroupConversation();
                        options = options || {};
                        remoteUri = options.to;
                        // ensures telemetry for audio is not sent when video is added to existing audio call.
                        if (audioState() == 'Disconnected')
                            record('Audio_Start');
                        if (options.video)
                            record('Video_Start');
                        // in p2p mode take URI of the remote participant
                        if (!isMeeting) {
                            if (!remoteUri)
                                remoteUri = participants(0).uri();
                            else
                                check(participants.size() == 0, 'ambiguous remote party in 1:1 call');
                            check(remoteUri, 'the remote participant URI is not specified');
                        }
                        if (!avs) {
                            avs = AudioVideoSession({
                                ucwa: ucwa,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                localUri: localUri,
                                threadId: threadId,
                                context: options.context,
                                invitation: invitation,
                                rInvitation: rInvitation,
                                conversation: conversation,
                                rConversation: rConversation,
                                participants: participants,
                                selfParticipant: selfParticipant,
                                // these are given by unit tests:
                                operationId: options.operationId,
                                sessionContext: options.sessionContext
                            });
                            avs.state.changed(state);
                            avs.audioState.changed(audioState);
                            avs.videoState.changed(videoState);
                        }
                        return Task.wait(null).then(function () {
                            if (conversation.meeting) {
                                if (conversation.meeting.state() == Internal.Modality.State.Created) {
                                    return conversation.meeting.start({
                                        name: guestName && guestName(),
                                        uri: conversation.uri()
                                    });
                                }
                            }
                            else if (isMeeting) {
                                return conversation.addMeeting().start();
                            }
                        }).then(function () {
                            return avs.start({
                                remoteUri: remoteUri,
                                audioConfig: 3 /* BOTH */,
                                mainVideoConfig: options.video ?
                                    3 /* BOTH */ : 0 /* NOT_PRESENT */,
                                video: options.video
                            });
                        });
                    });
                    /**
                     * Stops audio/video call
                     *
                     * @param {String} [modality] - if equals 'video', stops only video, if omitted both audio and video are stopped.
                     * @returns {Promise}
                     */
                    defineAsyncCommand('stop', [Internal.Modality.State.Connected, Internal.Modality.State.Connecting], function (modality) {
                        if (!avs)
                            return;
                        if (state() == Internal.Modality.State.Connecting)
                            return avs.stop();
                        if (modality == 'video') {
                            avs.stop(modality);
                            if (avsEsc)
                                avsEsc.stop(modality);
                        }
                        else if (arguments.length == 0) {
                            avs.stop();
                            if (avsEsc) {
                                avsEsc.escalated.off(onAVSessionEscalated);
                                avsEsc.stop();
                            }
                            return Task.wait(null).then(function () {
                                return ucwa.send('GET', rConversation.link('audioVideo').href);
                            }).then(function (rAudioVideo) {
                                // while audioVideo is being escalated from P2P to a meeting it does
                                // not have the stopAudioVideo link for a short interval, so this may throw
                                return ucwa.send('POST', rAudioVideo.link('stopAudioVideo').href);
                            }).finally(function () {
                                state(Internal.Modality.State.Disconnected);
                            });
                        }
                        else {
                            throw EInvalidArgument('modality', 'must be omitted or contain `video`');
                        }
                    });
                    /**
                     * Accepts an incoming audio/video invitation.
                     *
                     * @param {Dictionary} [video] - The video window container holder.
                     * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                     *
                     * @returns {Promise}
                     */
                    defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (options) {
                        if (isMeetingInvitation) {
                            return conversation.meeting.accept().then(function () {
                                state(Internal.Modality.State.Notified, sStartingAV);
                                return self.start(options);
                            });
                        }
                        options = options || {};
                        assert(!avs);
                        avs = AudioVideoSession({
                            ucwa: ucwa,
                            mediaPlugin: mediaPlugin,
                            devices: devices,
                            localUri: localUri,
                            threadId: threadId,
                            rAVInvitation: rAVInvitation,
                            conversation: conversation,
                            rConversation: rConversation,
                            participants: participants,
                            selfParticipant: selfParticipant,
                            invitation: invitation
                        });
                        avs.state.changed(state);
                        avs.audioState.changed(audioState);
                        avs.videoState.changed(videoState);
                        return avs.accept(options);
                    });
                    /**
                     * Declines an incoming audio/video invitation.
                     * @returns {Promise}
                     */
                    defineAsyncCommand('decline', [Internal.Modality.State.Notified], function () {
                        assert(invitation, 'This is an outgoing call, so it cannot be "declined"');
                        return invitation.decline().then(function () {
                            state(Internal.Modality.State.Disconnected);
                        });
                    });
                    /**
                     * Sends a DTMF tone
                     *
                     * @param {String} tone - a DTMF tone from MediaEnum.DtmfTone enumeration
                     * @returns {Promise}
                     */
                    defineAsyncCommand('sendDtmf', [Internal.Modality.State.Connected], function (tone) {
                        // if avs is null the thrown exception will lead to promise rejection.
                        return avs.sendDtmf(tone);
                    });
                    /**
                     * Shows participant's video
                     *
                     * @param {Participant} participant
                     * @returns {Promise}
                     */
                    function showParticipantVideo(participant) {
                        return avs.showParticipantVideo(participant);
                    }
                    /**
                     * Removes participant's video
                     *
                     * @param {Participant} participant
                     * @returns {Promise}
                     */
                    function removeParticipantVideo(participant) {
                        return avs.removeParticipantVideo(participant);
                    }
                    //#endregion public methods
                    //#region private methods
                    /**
                     * Starts a new AudioVideoSession that joins an online meeting.
                     *
                     * @param {String} uri - the uri to which the first SDP offer should be sent ('escalateAudio' or 'escalateAudioVideo uri).
                     * @param {Dictionary} [video] - The video window container holder.
                     * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                     *
                     * @returns {Promise}
                     */
                    function startEscalation(options) {
                        assert(!avsEsc);
                        assert(isConferencing());
                        avsEsc = AudioVideoSession({
                            ucwa: ucwa,
                            mediaPlugin: mediaPlugin,
                            devices: devices,
                            localUri: localUri,
                            threadId: threadId,
                            conversation: conversation,
                            rConversation: rConversation,
                            participants: participants,
                            selfParticipant: selfParticipant,
                            escalateAudioVideoUri: options.uri
                        });
                        avsEsc.escalated(onAVSessionEscalated);
                        if (options.video)
                            avs.removeVideo();
                        return avsEsc.start({
                            remoteUri: remoteUri,
                            audioConfig: 4 /* NO_ACTIVE_MEDIA */,
                            mainVideoConfig: options.video ?
                                4 /* NO_ACTIVE_MEDIA */ : 0 /* NOT_PRESENT */,
                            video: options.video
                        });
                    }
                    //#endregion
                    init();
                    return self;
                }
                Internal.AudioVideoModality = AudioVideoModality;
                //#endregion AudioVideoModality
                //#region AudioVideoSession (internal)
                /**
                 * Created by AudioVideoModality to represent an AudioVideo session (call). Can be either
                 * peer-to-peer or multi-party (conference). Only one such session exists when the call is
                 * established. When a P2P conversation is escalated to a conference, a second session
                 * linking this client to the conference is created. Once escalation succeeds, the second
                 * session replaces the original P2P session.
                 *
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 * @param {Devices} [devices] - Audio and video devices.
                 * @param {String} localUri -  SIP URI of the signed-in user.
                 * @param {String} [threadId] - Required for outgoing calls.
                 * @param {Collection} participants - Conversation participants.
                 * @param {Participant} selfParticipant
                 * @param {AudioVideoInvitation} [invitation] - Required for incoming calls.
                 * @param {Resource} [rAVInvitation] - Invitation resource. Required for incoming calls.
                 * @param {Resource} [rConversation] - The parent rel=conversation resource.
                 * @param {String} [escalateAudioVideoUri] - Escalation URI. Required for the AV conference
                 *                                           session created to replace the AV P2P session.
                 * @param {Object} [context] - An invitation context can accompany the generated audiovideo invitation.
                 *
                 * @property {Modality.State} state
                 * @property {Boolean} muted - get/set whether the audio is muted
                 * @property {Boolean} onHold - get/set whether the audio/video is on hold
                 *
                 * @method {Promise} start - Starts an outgoing call.
                 * @method {Promise} accept - Accepts an incoming call.
                 * @method {Promise} stop - Stops an ongoing call.
                 *
                 * @event changed - Occurs after the object adds or removes own methods.
                 * @event escalated - Occurs when this AV conference session replaces the initial p2p AV session
                 *
                 */
                function AudioVideoSession(options) {
                    var changed = Event(), escalated = Event(), self = {}, pcAV, mediaConfig, mediaPlugin = options.mediaPlugin, devices = options.devices, ucwa = options.ucwa, invitationContext = options.context, participants = options.participants, selfParticipant = options.selfParticipant, conversation = options.conversation, rConversation = options.rConversation, rAVInvitation = options.rAVInvitation, rAVRenegotiation, 
                    // During an outgoing call the server may set up more than one audioVideoSession, because
                    // the remote sip uri that we are calling may be signed in on more than one endpoint.
                    // Therefore we may see multiple pairs of audioVideoNegotiation - audioVideoSession events.
                    // Eventually, one of these sessions will be connected, others will be deleted. We keep
                    // track of these sessions in a dictionary of objects indexed by audioVideoSession hrefs,
                    // where these session objects may have properties:
                    //    resource:  audioVideoSession resource;
                    //    negotiated:  boolean (true if this session was successfully negotiated);
                    //    resumeAudioVideoUri:  present if this is an escalated conference session.
                    avSessions = {}, invitation = options.invitation, rInvitation = options.rInvitation, threadId = options.threadId, operationId = options.operationId || guid(), sessionContext = options.sessionContext || guid(), outAvRenegoOpIds = {}, localUri = options.localUri, remoteUri, state = Property({
                        value: invitation || (rInvitation && rInvitation.rel == 'onlineMeetingInvitation') ?
                            Internal.Modality.State.Notified :
                            Internal.Modality.State.Disconnected
                    }), 
                    // TODO: if we receive a video invitation we force the client to accept/decline on the video
                    // service. Figure out how to deal with answering with audio to a video invitation.
                    audioState = Property({
                        value: isAudioInvitation() ?
                            Internal.Modality.State.Notified :
                            Internal.Modality.State.Disconnected
                    }), videoState = Property({
                        value: isVideoInvitation() ?
                            Internal.Modality.State.Notified :
                            Internal.Modality.State.Disconnected
                    }), activeSourceId, recentActiveSpeakers = {}, activeModalities = { audio: false, video: false }, audioChannel, mainVideoStream = MediaStream({
                        mediaPlugin: mediaPlugin,
                        type: MediaEnum.StreamType.MainRender
                    }), selfVideoStream = MediaStream({
                        mediaPlugin: mediaPlugin,
                        type: MediaEnum.StreamType.Preview
                    }), 
                    // remote video streams
                    videoStreams = Collection(), dfdStart, dfdAccept, 
                    // video config of the main media manager channel requested by either start or accept;
                    // is needed for setting the initial value of video channel's isStarted property for the
                    // self participant when start/accept is finished.
                    mainVideoConfig = 0 /* NOT_PRESENT */, 
                    // a unique id of this session - handy for debugging this session's
                    // server event subscription
                    modelId = random(), RemoteHoldState = {
                        Unknown: 0,
                        HoldOffered: 1,
                        HoldAnswered: 2,
                        HoldCompleted: 3,
                        ResumeOffered: 4,
                        ResumeAnswered: 5,
                        ResumeCompleted: 6
                    }, AudioVideoDirection = StringEnum('Inactive', 'ReceiveOnly', 'SendOnly', 'SendReceive', 'Unknown'), 
                    // A flag to track the renegotiation progress when a remote
                    // participant hold/resume the call in P2P mode.
                    //
                    // Steps to identify when remote participant hold/resume in P2P:
                    // 1. wait for audioVideo renegotiation offer.
                    // 2. if the offer has "a=inactive" field (for m=audio or m=video),
                    //    it is a HOLD request, mark it and expect ANSWER READY.
                    //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                    //    so mark it that way.
                    // 3. if answer has "a=inactive" field, it is a HOLD request, mark it
                    //    and expect "audioVideoRenegotiation completed".
                    //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                    //    so mark it that way.
                    // 4. when "audioVideoRenegotiation completed" event is received
                    //    with "Incoming" direction, progress the marker set in previous
                    //    steps; and expect CHANNEL_DIRECTION_CHANGED event.
                    // 5. if CHANNEL_DIRECTION_CHANGED event is received with direction
                    //    equal to NO_ACTIVE_MEDIA, and the HOLD marker was set in last
                    //    step, it completes a HOLD renegotiation, so we can set:
                    //    p.audioOnHold(true) for the remote participant.
                    // 6. if CHANNEL_DIRECTION_CHANGED event is received with direction
                    //    equal to other values (likely BOTH), and the RESUME marker was
                    //    set in last step, it completes a RESUME renegotiation, so set:
                    //    p.audioOnHold(false) for the remote participant.
                    remoteHoldState = RemoteHoldState.Unknown, escalateAudioVideoUri = options.escalateAudioVideoUri, fEscalation = isNotEmptyString(escalateAudioVideoUri);
                    //#region mute
                    // mutes/unmutes the audio channel or returns the mute status
                    var muted = Property({
                        value: false,
                        get: function () {
                            // if this throws, the cached value won't be changed
                            check.state(pcAV.state(), PluginComponent.State.Loaded);
                            if (isConferencing())
                                return muted();
                            var res = pcAV.invoke('GetMuteStatus', MediaEnum.MediaDeviceType.MIC, false); // isDeviceSystemProperty
                            // the output param is a flag telling us if our audio is muted or not
                            return res[1];
                        },
                        set: function (val) {
                            // if this throws, the cached value won't be changed
                            check.state(pcAV.state(), PluginComponent.State.Loaded);
                            // soft mute is applicable in conference mode
                            if (isConferencing()) {
                                var rel = val ? 'muteAudio' : 'unmuteAudio', rAudio = selfParticipant[Internal.sInternal].rAudio;
                                return Task.wait().then(function () {
                                    if (!rAudio.hasLink(rel))
                                        return ucwa.send('GET', rAudio.href);
                                }).then(function () {
                                    return rAudio.link(rel).href;
                                }).then(function (href) {
                                    return ucwa.send('POST', href);
                                }).then(function () {
                                    return val;
                                });
                            }
                            // hard mute is applicable to P2P mode
                            pcAV.invoke('MuteOrUnMute', MediaEnum.MediaDeviceType.MIC, val, false); // isDeviceSystemProperty
                            return val;
                        }
                    });
                    //#endregion mute
                    //#region onHold
                    // holds/resumes audio/video or returns the onHold status
                    var onHold = Property({
                        value: false,
                        get: function (val) {
                            check.state(pcAV.state(), PluginComponent.State.Loaded);
                            return val;
                        },
                        set: function (val) {
                            // if this throws, the cached value won't be changed
                            check.state(pcAV.state(), PluginComponent.State.Loaded);
                            if (!isConferencing() && participants.size() > 0) {
                                // the call is on hold when the remote puts on hold; so when
                                // the local participant requests hold, the plugin will not
                                // renegotiate, and no need to wait for renegotiation result
                                if (participants(0).audio.isOnHold() && !onHold())
                                    return val;
                            }
                            var audioConfig = val ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                            var moreChannels = activeModalities.video && isConferencing();
                            mainVideoConfig = activeModalities.video ?
                                (val ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */) :
                                0 /* NOT_PRESENT */;
                            pcAV.invoke('SetMediaConfig', audioConfig, mainVideoConfig, moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, moreChannels ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, 0 /* NOT_PRESENT */); // panoVideoConfig
                            return ucwa.wait({
                                type: 'completed',
                                target: { rel: 'audioVideoRenegotiation' },
                                resource: function (r) {
                                    return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                }
                            }).then(function (event) {
                                if (event.status == 'Success')
                                    return val;
                                throw Exception('RenegotiationFailed', { reason: event.reason });
                            });
                        }
                    });
                    //#endregion onHold
                    options = null;
                    ucwa.event(onServerEvent);
                    state.changed(function (newState, reason, oldState) {
                        log('AudioVideoSession(' + modelId + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    audioState.changed(function (newState, reason, oldState) {
                        log('AudioVideoSession(' + modelId + ')::audioState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    videoState.changed(function (newState, reason, oldState) {
                        log('AudioVideoSession(' + modelId + ')::videoState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    state.when(Internal.Modality.State.Disconnected, function () {
                        audioState(Internal.Modality.State.Disconnected);
                        videoState(Internal.Modality.State.Disconnected);
                    });
                    // note that both reset* methods will be called with the "reason" parameter if the
                    // reason was set when property values were changed.
                    videoState.when(Internal.Modality.State.Disconnected, resetVideo);
                    audioState.when(Internal.Modality.State.Disconnected, resetAudio);
                    participants.removed(function (p) {
                        var id = p[Internal.sInternal].audioSourceId();
                        delete recentActiveSpeakers[id];
                        if (activeSourceId == id)
                            activeSourceId = -1;
                    });
                    setVideoRendering(selfVideoStream, true);
                    if (!isConferencing())
                        setVideoRendering(mainVideoStream, false);
                    //#region self
                    extend(self, {
                        state: state.asReadOnly(),
                        audioState: audioState.asReadOnly(),
                        videoState: videoState.asReadOnly(),
                        start: async(start),
                        stop: async(stop),
                        sendDtmf: sendDtmf,
                        changed: changed.observer,
                        escalated: escalated.observer,
                        muted: muted,
                        onHold: onHold,
                        selfVideoStream: selfVideoStream,
                        showParticipantVideo: showParticipantVideo,
                        removeParticipantVideo: removeParticipantVideo,
                        removeVideo: async(removeAllVideo)
                    });
                    if (invitation) {
                        // incoming call
                        extend(self, {
                            from: invitation.from,
                            accept: async(accept)
                        });
                    }
                    //#endregion
                    //#region private utilities
                    function initMedia() {
                        return mediaConfig ?
                            Task.wait(mediaConfig) :
                            mediaPlugin.getMediaConfig() // otherwise load it and return when it becomes available
                                .then(function (mc) {
                                mediaConfig = mc;
                                return mediaConfig;
                            });
                    }
                    function isConferencing() {
                        var convState = rConversation && rConversation.get('state', '');
                        //TODO: move Conversation.State to model.common.js and use enum here
                        return convState == 'Conferencing' || convState == 'Conferenced';
                    }
                    function getRenegotiationsHref() {
                        var renegoHref, negoSession, negotiated = filter(values(avSessions), function (session) {
                            return session.negotiated;
                        });
                        if (negotiated.length > 0) {
                            assert(negotiated.length == 1);
                            negoSession = negotiated[0];
                            renegoHref = negoSession.resumeAudioVideoUri ||
                                negoSession.resource.link('renegotiations').href;
                            assert(renegoHref);
                        }
                        return renegoHref;
                    }
                    function setNegotiatedSession(sctx) {
                        foreach(avSessions, function (session) {
                            if (session.resource.get('sessionContext') == sctx)
                                session.negotiated = true;
                        });
                    }
                    // switches video rendering on/off for 1:1 conversations when video starts/stops streaming 
                    // and when video container is set/changed/nulled
                    function setVideoRendering(videoStream, isPreview) {
                        videoStream._isFlowing.changed(function (val) {
                            if (val)
                                showVideo(videoStream, isPreview);
                            else
                                removeVideo(videoStream, isPreview);
                        });
                        videoStream.source.sink.container.changed(function (newVal, reason, oldVal) {
                            if (videoStream._isFlowing()) {
                                if (oldVal)
                                    removeVideo(videoStream, isPreview);
                                if (newVal)
                                    showVideo(videoStream, isPreview);
                            }
                        });
                    }
                    // called when we stop 1:1 video (including escalation to a meeting)
                    function removeAllVideo() {
                        removeVideo(mainVideoStream, false);
                        removeVideo(selfVideoStream, true);
                        mainVideoStream._isFlowing(false);
                        selfVideoStream._isFlowing(false);
                        selfParticipant[Internal.sInternal].setVideoStream(null);
                        if (participants.size() > 0) {
                            participants(0)[Internal.sInternal].setVideoStream(null);
                            participants(0)[Internal.sInternal].setVideoStarted(void 0);
                        }
                    }
                    function resetVideo(reason) {
                        participants.each(function (p) {
                            // reset the participant video stream source to an empty stream
                            p[Internal.sInternal].setVideoStream(null);
                            if (!isConferencing())
                                p[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                        });
                        mainVideoStream._isFlowing(false);
                        selfVideoStream._isFlowing(false);
                        videoStreams.empty();
                        selfParticipant[Internal.sInternal].setVideoStream(null);
                        if (reason !== sEscalation)
                            selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                    }
                    function resetAudio() {
                        if (!isConferencing() && participants(0))
                            participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                        // The audio state of self participant is replaced by AudioVideoModality::audioState 
                        // in the conversation ctor, so resetting it as we do in resetVideo is useless:
                        // if (reason !== sEscalation)
                        //    selfParticipant[sInternal].audioState(Modality.State.Disconnected);
                    }
                    function enumcastStreamState(meState) {
                        var ss = MediaEnum.StreamState, state;
                        switch (meState) {
                            case 1 /* STREAM_STARTED */:
                                state = ss.Started;
                                break;
                            case 2 /* STREAM_ACTIVE */:
                                state = ss.Active;
                                break;
                            case 3 /* STREAM_INACTIVE */:
                                state = ss.Inactive;
                                break;
                            case 4 /* STREAM_STOPPED */:
                                state = ss.Stopped;
                                break;
                        }
                        return state;
                    }
                    // Check if the SDP offer/answer contains a=inactive field,
                    // which indicates it is a renegotiation triggered when a
                    // participant holds a call.
                    function isHoldRequest(sdp) {
                        return /\ba=inactive\b/gmi.test(sdp);
                    }
                    function isAudioInvitation() {
                        return invitation && !invitation.hasVideo() ||
                            rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                conversation.meeting.availableModalities.audio() &&
                                !conversation.meeting.availableModalities.video();
                    }
                    function isVideoInvitation() {
                        return invitation && invitation.hasVideo() ||
                            rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                conversation.meeting.availableModalities.video();
                    }
                    //#endregion
                    //#region public methods
                    //#region start
                    /**
                     * Starts an outgoing Audio/Video call
                     *
                     *  @param {String} remoteUri
                     *  @param {MediaEnum.MediaConfig} audioConfig
                     *  @param {MediaEnum.MediaConfig} mainVideoConfig
                     *  @param {Object} [video]
                     *
                     *  @returns {Promise}
                     *
                     *  Starting a P2P audio call
                     *  - Creates an AVComponent in the media plugin.
                     *  - Invokes AVComponent::SetCallConfig.
                     *  - Invokes AVComponent::SetMediaConfig.
                     *  - Gets an OFFER_READY event from the AVComponent.
                     *  - Sends a POST request to startAudioVideo link with the SDP offer.
                     *  - Gets an "audioVideoInvitation started" event from UCWA.
                     *  - Gets an "audioVideoNegotiation started" event from UCWA with a provisional SDP answer.
                     *  - Invokes AVComponent::SetProvisionalAnswer.
                     *  -  Gets an "audioVideoSession added" event.
                     *  -  Gets an "audioVideoNegotiation completed" event with a final SDP answer.
                     *  -  Invokes AVComponent::SetFinalAnswer.
                     *  -  Gets a "audioVideoInvitation completed" event from UCWA.
                     *  -  Invokes AVComponent::CompleteNegotiation.
                     *  -  Gets a "audioVideoRenegotiation started" event from UCWA.
                     *  -  Gets a OFFER_READY event from AVComponent with a new SDP answer.
                     *  -  Sends a POST request to audioVideoSession/renegotiations link.
                     *  -  Gets a "audioVideoRenegotiation completed" event from UCWA with a new SDP answer.
                     *  -  Invokes AVComponent::SetFinalAnswer.
                     *  -  Invokes AVComponent::CompleteNegotiation.
                     *
                     *  Joining an audio conference call the client follows the same sequence with one exception:
                     *  there is no initial negotiation - all "audioVideoNegotiation" events are absent.
                     *
                     *  If the client calls an invalid sip uri, it receives a single "audioVideoInvitation
                     *  completed" event with failure status and appropriate error code.
                     */
                    function start(options) {
                        // prohibit start of audio or video when that modality is already started
                        if ((options.mainVideoConfig == 3 /* BOTH */ && activeModalities.video) ||
                            (options.mainVideoConfig == 0 /* NOT_PRESENT */ &&
                                options.audioConfig == 3 /* BOTH */ && activeModalities.audio))
                            return 'already started';
                        check.state(onHold(), false);
                        var audioConfig = options.audioConfig, previewContainer = options.video && options.video.previewContainer, videoContainer = options.video && options.video.container, startsVideo = options.mainVideoConfig != 0 /* NOT_PRESENT */;
                        mainVideoConfig = options.mainVideoConfig;
                        // start is allowed to be called twice only when the first call starts audio,
                        // and the second call adds video. So a different options.remoteUri for adding
                        // video does not make sense
                        remoteUri = remoteUri || options.remoteUri;
                        options = null;
                        check.state(state(), [
                            Internal.Modality.State.Disconnected,
                            Internal.Modality.State.Notified,
                            Internal.Modality.State.Connected
                        ]);
                        if (state() == Internal.Modality.State.Disconnected ||
                            state() == Internal.Modality.State.Notified) {
                            state(Internal.Modality.State.Connecting);
                        }
                        // to keep parity with Skype not only we need to set the local participant AV state
                        // in a 1:1 call but also to fake the remote participant AV state; and we always check
                        // for the remote participant existence because the call can be started with the
                        // empty participants collection by specifying the remote sip uri.
                        if (audioState() == Internal.Modality.State.Disconnected ||
                            audioState() == Internal.Modality.State.Notified) {
                            audioState(Internal.Modality.State.Connecting);
                            if (!isConferencing() && participants.size() > 0)
                                participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                        }
                        if (videoState() == Internal.Modality.State.Disconnected && startsVideo ||
                            videoState() == Internal.Modality.State.Notified) {
                            videoState(Internal.Modality.State.Connecting);
                            if (!isConferencing() && participants.size() > 0)
                                participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                        }
                        return initMedia().then(function () {
                            if (!pcAV) {
                                pcAV = mediaPlugin.createComponent({
                                    type: 'AVComponent',
                                    hide: true,
                                    inproc: false
                                });
                                pcAV.event(onPluginComponentEvent, 'async');
                                return pcAV.load(localUri, isConferencing() ? guid() : remoteUri, threadId, isConferencing(), 
                                // max num of video channels - use 1 for P2P, otherwise the media
                                // manager will fail the call constructed by the media plugin.
                                isConferencing() ? mediaConfig.maxVideoChannelCount() : 1, mediaConfig.audioVideoSecurityLevel());
                            }
                        }).then(function () {
                            var moreChannels = mainVideoConfig != 0 /* NOT_PRESENT */ && isConferencing();
                            // select default devices if we have not selected a device explicitly
                            if (devices && !devices.selectedMicrophone())
                                mediaConfig.setDefaultDevices();
                            pcAV.invoke('SetCallConfig', mediaConfig.isInternal() ?
                                MediaEnum.PreferredMediaAddressType.Direct :
                                MediaEnum.PreferredMediaAddressType.Relay);
                            // hook up the preview video stream - this will retain the video container if it was set for
                            // self participant.
                            // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                            // receive another invitiation (it's a renegotiation of an established AV connection), so
                            // we won't have a chance to call accept method again.
                            selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                            if (videoContainer)
                                mainVideoStream.source.sink.container(videoContainer);
                            if (previewContainer)
                                selfVideoStream.source.sink.container(previewContainer);
                            pcAV.invoke('SetMediaConfig', audioConfig, mainVideoConfig, moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, moreChannels ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, 0 /* NOT_PRESENT */); // panoVideoConfig
                            if (audioState() == Internal.Modality.State.Connecting && !isConferencing() && participants.size() > 0)
                                participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Ringing);
                            // expect an OFFER_READY event from the media plugin
                            dfdStart = Task('waiting for an OFFER_READY event from the media plugin');
                            return dfdStart.promise;
                        }).then(null, function (error) {
                            if (!rAVInvitation) {
                                // if the AV invitation was not sent (rAVInvitation is undefined) release the plugin component.
                                cleanup();
                            }
                            else if (rAVInvitation.hasLink('cancel')) {
                                // if the AV invitation was sent and the "audioVideoInvitation started" event was received we have
                                // the cancel link and we can terminate the call here.
                                ucwa.send('POST', rAVInvitation.link('cancel').href, { nobatch: true });
                            }
                            else {
                            }
                            state(Internal.Modality.State.Disconnected);
                            audioState(Internal.Modality.State.Disconnected);
                            videoState(Internal.Modality.State.Disconnected);
                            throw error;
                        });
                    }
                    //#endregion
                    //#region accept
                    /**
                     * Accepts an incoming Audio/Video invitation.
                     *
                     * @param {Dictionary} [video] - The video window container holder.
                     * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                     *
                     * @returns {Promise}
                     *
                     * Accepting an incoming call invitation:
                     *
                     *  - Creates an AVComponent with the media plugin.
                     *  - Invokes AVComponent::Load and waits until it gets loaded.
                     *  - Invokes AVComponent::SetCallConfig.
                     *  - Invokes AVComponent::SetAcceptedMedia and specifies that no video is needed.
                     *  - Invokes AVComponent::SetOffer with the SDPs received from the remote party.
                     *  - Handles the ANSWER_READY event from the media plugin: the event contains an SDP.
                     *  - Sends a POST audioVideoInvitation/acceptWithAnswer with the SDP from the media plugin.
                     *  - Receives an "audioVideoinvitation completed" event from UCWA
                     *  - Receives an "audioVideoRenegotiation started" event with a new SDP from the remote party.
                     *  - Invokes AVComponent::SetAcceptedMedia.
                     *  - Invokes AVComponent::SetOffer with the new SDP given in the renegotiation event.
                     *  - Handles another ANSWER_READY event from the media plugin with an SDP answer.
                     *  - Sends a POST audioVideoRenegotiation/answer with the SDP answer.
                     *  - Receives a "audioVideoRenegotiation completed" event from UCWA.
                     *  - Invokes AVComponent::CompleteNegotiation
                     */
                    function accept(options) {
                        assert(invitation, 'This is an outgoing call, so it cannot be "accepted"');
                        assert(!isConferencing(), 'This is a conference'); // accept is used in P2P only
                        assert(participants.size() == 1, 'The caller is not in participants');
                        var video = options && options.video, videoContainer = video && video.container, previewContainer = video && video.previewContainer;
                        mainVideoConfig = video ? 3 /* BOTH */ :
                            2 /* RECEIVE */;
                        state(Internal.Modality.State.Connecting);
                        audioState(Internal.Modality.State.Connecting);
                        participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                        if (invitation.hasVideo()) {
                            videoState(Internal.Modality.State.Connecting);
                            participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                        }
                        return initMedia().then(function () {
                            // the caller has already hung up
                            if (state() == Internal.Modality.State.Disconnected)
                                throw Internal.EInvitationFailed(state.reason);
                            assert(!pcAV);
                            pcAV = mediaPlugin.createComponent({
                                type: 'AVComponent',
                                hide: true,
                                inproc: false
                            });
                            pcAV.event(onPluginComponentEvent, 'async');
                            return pcAV.load(localUri, invitation.from.uri(), invitation.resource.get('threadId'), false, 1, 
                            // otherwise the media manager will fail the call constructed by the media plugin)
                            mediaConfig.audioVideoSecurityLevel());
                        }).then(function () {
                            // the caller has already hung up
                            if (state() == Internal.Modality.State.Disconnected)
                                throw Internal.EInvitationFailed(state.reason);
                            // select default devices if we have not selected a device explicitly
                            if (devices && !devices.selectedMicrophone())
                                mediaConfig.setDefaultDevices();
                            // hook up the preview video stream - this will retain the video container if it was set for
                            // self participant.
                            // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                            // receive another invitiation (it's a renegotiation of an established AV connection), so
                            // we won't have a chance to call accept method again.
                            selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                            if (videoContainer)
                                mainVideoStream.source.sink.container(videoContainer);
                            if (previewContainer)
                                selfVideoStream.source.sink.container(previewContainer);
                            pcAV.invoke('SetCallConfig', mediaConfig.isInternal() ?
                                MediaEnum.PreferredMediaAddressType.Direct :
                                MediaEnum.PreferredMediaAddressType.Relay);
                            pcAV.invoke('SetAcceptedMedia', 3 /* BOTH */, video ?
                                3 /* BOTH */ :
                                2 /* RECEIVE */);
                            // expect the ANSWER_READY event from the plugin after this call
                            setOffer(invitation.offers);
                            assert(!dfdAccept);
                            dfdAccept = Task();
                            dfdAccept.status('awaiting an ANSWER_READY event from the media plugin');
                            return dfdAccept.promise;
                        }).then(null, function (error) {
                            state(Internal.Modality.State.Disconnected);
                            audioState(Internal.Modality.State.Disconnected);
                            videoState(Internal.Modality.State.Disconnected);
                            cleanup();
                            throw error;
                        });
                    }
                    //#endregion
                    //#region stop
                    /**
                     * Stops Audio/Video session
                     *
                     * @param {String} [reason] - if equals 'video', only video is stopped, if omitted both audio and video are stopped.
                     */
                    function stop(reason) {
                        // cancel start if stop is called during connecting
                        if (state() == Internal.Modality.State.Connecting)
                            return dfdStart.promise.cancel();
                        if (reason == 'video') {
                            if (isConferencing()) {
                                participants.each(function (p) {
                                    p.video.channels(0).isStarted(false);
                                });
                            }
                            var audioConfig = onHold() ?
                                4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                            mainVideoConfig = 0 /* NOT_PRESENT */;
                            pcAV.invoke('SetMediaConfig', audioConfig, mainVideoConfig, isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, 0 /* NOT_PRESENT */, 0 /* NOT_PRESENT */); // panoVideoConfig
                        }
                        else {
                            cleanup(reason);
                        }
                    }
                    //#endregion
                    //#region sendDtmf
                    /**
                     * Sends a DTMF tone
                     *
                     * @param {String} tone - A DTMF tone from MediaEnum.DtmfTone enumeration
                     * @returns {String} - The sent tone
                     */
                    function sendDtmf(tone) {
                        if (isNotEmptyString(tone)) {
                            tone = tone.trim().toLowerCase();
                            tone = tone.substr(0, 1).toUpperCase() + tone.substr(1);
                            if (MediaEnum.DtmfTone[tone] !== undefined) {
                                pcAV.invoke('SendDTMF', MediaEnum.DtmfTone[tone]);
                                return tone;
                            }
                        }
                        throw EInvalidArgument('tone', 'out of range');
                    }
                    //#endregion
                    //#region showParticipantVideo
                    function showParticipantVideo(participant) {
                        var isFound = false, videoStream, dfd;
                        if (videoState() != Internal.Modality.State.Connected)
                            throw EInvalidState(videoState(), Internal.Modality.State.Connected);
                        if (onHold())
                            throw Exception('OnHold');
                        if (participant[Internal.sInternal].isLocal()) {
                            // undefined means that we just started video, no need to renegotiate
                            if (participant.video.channels(0).isStarted() === false) {
                                mainVideoConfig = 3 /* BOTH */;
                                pcAV.invoke('SetMediaConfig', 3 /* BOTH */, mainVideoConfig, isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, isConferencing() ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, 0 /* NOT_PRESENT */); // panoVideoConfig
                            }
                            return Task().resolve().promise;
                        }
                        else if (isConferencing()) {
                            // find available stream
                            if (!mainVideoStream._isAttached()) {
                                videoStream = mainVideoStream;
                            }
                            else {
                                videoStreams.each(function (vs) {
                                    if (!isFound && !vs._isAttached()) {
                                        videoStream = vs;
                                        isFound = true;
                                    }
                                });
                            }
                            if (!videoStream) {
                                log('Cannot find available stream');
                                throw EDoesNotExist('No available stream');
                            }
                            participant[Internal.sInternal].setVideoStream(videoStream);
                            videoStream._isAttached(true);
                            dfd = showVideo(videoStream, false).then(function () {
                                try {
                                    pcAV.invoke('Subscribe', videoStream._id(), participant[Internal.sInternal].videoSourceId());
                                }
                                catch (err) {
                                    log('SUBSCRIBE ERROR: ' + err);
                                    throw err;
                                }
                            }).then(function () {
                                var sink = videoStream.source.sink;
                                sink._c(sink.container.changed(function (newVal, reason, oldVal) {
                                    if (oldVal)
                                        removeParticipantVideo(participant).then(function () {
                                            if (newVal)
                                                showParticipantVideo(participant);
                                            else
                                                participant[Internal.sInternal].setVideoStarted(false);
                                        });
                                }));
                            });
                        }
                        else {
                            dfd = Task().reject(ENotSupported('cannot start remote video in 1:1 conversation')).promise;
                        }
                        return dfd;
                    }
                    //#endregion showParticipantVideo
                    //#region removeParticipantVideo
                    function removeParticipantVideo(participant) {
                        var dfd;
                        if (onHold())
                            throw Exception('OnHold');
                        if (participant[Internal.sInternal].isLocal()) {
                            mainVideoConfig = 2 /* RECEIVE */;
                            pcAV.invoke('SetMediaConfig', 3 /* BOTH */, mainVideoConfig, isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, isConferencing() ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, 0 /* NOT_PRESENT */); // panoVideoConfig
                            return Task().resolve().promise;
                        }
                        else if (isConferencing()) {
                            dfd = Task.wait(null, 'sync').then(function () {
                                //NB: this is a sourced stream
                                var videoStream = participant.video.channels(0).stream;
                                var sink = videoStream.source.sink;
                                if (sink._c())
                                    sink._c().dispose();
                                if (videoStream._isAttached()) {
                                    try {
                                        pcAV.invoke('Unsubscribe', videoStream._id());
                                    }
                                    catch (err) {
                                        log('UNSUBSCRIBE ERROR: ' + err);
                                    }
                                    removeVideo(videoStream, false);
                                    videoStream._isAttached(false);
                                    participant[Internal.sInternal].setVideoStream(null);
                                }
                            });
                        }
                        else {
                            // in 1:1 we can't remove remote video without stopping video altogether
                            dfd = Task().reject(ENotSupported('cannot remove remote video in 1:1 conversation')).promise;
                        }
                        return dfd;
                    }
                    //#endregion removeParticipantVideo
                    //#endregion public methods
                    //#region cleanup
                    // Unsubscribes from server and plugin component events and unloads the plugin component
                    function cleanup(reason) {
                        var cDisconnected = Internal.Modality.State.Disconnected;
                        ucwa.event.off(onServerEvent);
                        if (pcAV) {
                            pcAV.event.off(onPluginComponentEvent);
                            removeAllVideo();
                            pcAV.invoke('Terminate');
                            pcAV.unload();
                            pcAV = null;
                        }
                        participants.each(function (p) {
                            // reset the participant video stream source to an empty stream
                            p[Internal.sInternal].setVideoStream(null);
                            if (!isConferencing()) {
                                p[Internal.sInternal].audioState(cDisconnected);
                                p[Internal.sInternal].videoState(cDisconnected);
                            }
                        });
                        audioState(cDisconnected /*, reason*/);
                        videoState(cDisconnected, reason);
                    }
                    //#endregion
                    //#region videoWindow
                    /**
                     * Creates a video window and anchors it in the parent DOM element
                     *
                     * The whole area of the parent element will be occupied by the video. Video preview window sized to
                     * 1/3rd of the remote window and is placed in the lower-right corner. Currently, its flicker makes
                     * the preview unusable
                     */
                    function showVideo(vs, isPreview) {
                        var sink = vs.source.sink;
                        if (vs._id() && sink.container()) {
                            // TODO: this is a temporary check to avoid repeated window creation
                            // when this method is called more than once ('participantVideo updated')
                            if (sink._state() == PluginComponent.State.Unloaded) {
                                return sink._init().then(function () {
                                    sink._resize();
                                    pcAV.invoke('SetVideoWindow', vs._id(), isPreview ? MediaEnum.MediaDeviceType.PREVIEW : MediaEnum.MediaDeviceType.RENDER, sink._videoWindow(), sink._format(), 1 /* SmartCrop */);
                                    sink._s(sink._size.changed(bind(onVideoResized, vs, isPreview)));
                                });
                            }
                        }
                    }
                    /**
                     * Removes the video window from the parent DOM element
                     */
                    function removeVideo(vs, isPreview) {
                        var sink = vs.source.sink;
                        if (vs._id() && sink._videoWindow()) {
                            pcAV.invoke('RemoveVideoWindow', vs._id(), isPreview ? MediaEnum.MediaDeviceType.PREVIEW : MediaEnum.MediaDeviceType.RENDER, sink._videoWindow());
                            sink._uninit();
                            if (sink._s())
                                sink._s().dispose();
                        }
                    }
                    /**
                     * Video 'resized' event handler
                     */
                    function onVideoResized(vs, isPreview, size) {
                        // notify the AVComponent that the video window size has changed
                        pcAV.invoke('SetVideoWindowSize', vs._id(), vs.source.sink._videoWindow(), isPreview, size.width, size.height);
                    }
                    //#endregion videoWindow
                    //#region server events
                    function onServerEvent(event) {
                        var id = event.target.rel + ' ' + event.type;
                        var handler = ucwaEventHandlers[id];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler(event.status, event.resource, event);
                        }
                    }
                    var ucwaEventHandlers = {
                        // this is the first event received in any AV call setup (except calling an invalid SIP uri,
                        // in which case UCWA sends the 'audioVideoInvitation completed' event only).
                        'audioVideoInvitation started': function (status, resource) {
                            // set the invitation resource for the outgoing AV session (for the incoming call
                            // audioVideoSession is initialized with the received invitation resource)
                            if (resource.get('direction') == 'Outgoing' &&
                                resource.get('sessionContext') == sessionContext) {
                                // if the user canceled the call before we received this event terminate the call
                                // on the server and unload the AV component.
                                if (state() == Internal.Modality.State.Disconnected) {
                                    if (resource.hasLink('cancel'))
                                        ucwa.send('POST', resource.link('cancel').href, { nobatch: true });
                                    cleanup();
                                }
                                else {
                                    rAVInvitation = resource;
                                    dfdStart.status('awaiting "audioVideoNegotiation started or completed" event from UCWA');
                                }
                            }
                        },
                        // this event is received if we started an outgoing AV call as the first conversation modality
                        // using the global startAudioVideo link
                        'conversation added': function (status, resource) {
                            if (resource.get('threadId') == threadId)
                                rConversation = resource;
                        },
                        // this event is received during outgoing P2P AV call setup (early media?)
                        'audioVideoNegotiation started': function (status, resource, event) {
                            if (event.sender.href == rAVInvitation.href) {
                                setProvisionalAnswer(resource.link('mediaProvisionalAnswer').href, resource.get('remoteEndpoint'));
                                dfdStart.status('awaiting "audioVideoNegotiation completed" event from UCWA');
                            }
                        },
                        // this event is received during outgoing P2P or conference call setup.
                        // If the negotiation completed successfully the event resource contains session context,
                        // a link to matching audioVideoSession and the remoteEndpoint of that session.
                        // If the call was declined or not answered we have negotiation href only.
                        'audioVideoNegotiation completed': function (status, resource, event) {
                            var href;
                            if (event.sender.href == rAVInvitation.href) {
                                switch (status) {
                                    case 'Success':
                                        // "audioVideoNegotiation completed" may arrive before the corresponding
                                        // "audioVideoSession added" event when the call is forwarded to voice mail.
                                        // in this case we create an entry in avSessions and expect to fill it out
                                        // after the session added event arrives.
                                        href = resource.link('audioVideoSession').href;
                                        avSessions[href] = avSessions[href] || {};
                                        avSessions[href].negotiated = true;
                                        setFinalAnswer(resource.link('mediaAnswer').href, resource.get('remoteEndpoint'));
                                        dfdStart.status('awaiting "audioVideoInvitation completed" event from UCWA');
                                        break;
                                    case 'Failure':
                                        if (event.reason.subcode != 'Ended' && event.reason.subcode != 'ConnectedElsewhere')
                                            dfdStart.status(event.reason && event.reason.message);
                                        break;
                                }
                            }
                        },
                        // during an outgoing call the server may set up more than one audioVideoSession, because
                        // the remote sip uri that we are calling may be signed in on more than one endpoint.
                        // Also, if the remote party does not accept the call the UCWA server may redirect the
                        // client to a media server so that the client may leave a voice mail; during this process
                        // the UCWA server will create another audioVideoSession and delete the original session.
                        // The next two handlers keep track of audioVideoSessions.
                        'audioVideoSession added': function (status, resource) {
                            var href = resource.href;
                            if (resource.get('sessionContext') == sessionContext) {
                                avSessions[href] = avSessions[href] || {};
                                avSessions[href].resource = resource;
                            }
                        },
                        'audioVideoSession deleted': function (status, resource, event) {
                            delete avSessions[event.target.href];
                            // this event is the only indication of a failed escalation; we need to notify
                            // AudioVideoModality so it can force the cleanup of this session (technically there
                            // a "participantInvitation completed" event with code == ServiceFailure and
                            // subcode == EscalationFailed but it is received by the client that issued the
                            // invitation only).
                            if (fEscalation && isEmptyObject(avSessions)) {
                                escalated.fire('failure');
                                fEscalation = false;
                            }
                        },
                        // this event is received during any AV call setup
                        'audioVideoInvitation completed': function (status, resource, event) {
                            // check for rAVInvitation is needed because this event may arrive before we
                            // even get a response to startAudioVideo post if we call an invalid SIP uri,
                            // so rAVInvitation may be undefined.
                            // Note that completion of an outgoing invitation is handled by sendOffer method
                            if (rAVInvitation && rAVInvitation.href == resource.href &&
                                resource.get('direction') == 'Incoming') {
                                if (status == 'Success') {
                                    try {
                                        // there are no audioVideoNegotiation events in the incoming P2P call setup,
                                        // so we set negotiated flag for the cached audioVideoSession here
                                        setNegotiatedSession(resource.get('sessionContext'));
                                        completeNegotiation(status, event.reason);
                                        // if AV is added by a remote participant in a 1:1 conversation which already
                                        // has another modality (messaging) then "participantAudio/Video added" events
                                        // arrive before "audioVideoInvitation started" event, i.e. before this
                                        // AudioVideoSession object exists. So we need to set the AV properties of the
                                        // remote participant here:
                                        //TODO: check if they were not set before : Accepting the AV invitation that created the call
                                        assert(!isConferencing());
                                        var p = participants(0);
                                        if (p) {
                                            p[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                            if (videoState() == Internal.Modality.State.Connected) {
                                                p[Internal.sInternal].setVideoStream(mainVideoStream);
                                                p[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                            }
                                        }
                                        dfdAccept.resolve();
                                        state(Internal.Modality.State.Connected);
                                    }
                                    catch (error) {
                                        dfdAccept.reject(error);
                                        state(Internal.Modality.State.Disconnected);
                                    }
                                }
                                else {
                                    // the caller (remote party) hung up while the call setup was not completed.
                                    if (dfdAccept)
                                        dfdAccept.reject(event.reason);
                                    state(Internal.Modality.State.Disconnected, event.reason);
                                }
                            }
                        },
                        'audioVideoRenegotiation started': function (status, resource) {
                            if (resource.link('audioVideoSession').href in avSessions) {
                                if (resource.get('direction') == 'Incoming') {
                                    var sdp = DataUri(resource.link('mediaOffer').href).data;
                                    if (!isConferencing() && participants.size() > 0) {
                                        remoteHoldState = isHoldRequest(sdp) ?
                                            RemoteHoldState.HoldOffered : RemoteHoldState.ResumeOffered;
                                    }
                                    setRenegotiationOffer(sdp);
                                    rAVRenegotiation = resource;
                                }
                                else if (dfdStart && dfdStart.promise.state() == 'pending') {
                                    // this is an outgoing renegotiation caused by the second start() call
                                    // to add video to an audio conversation
                                    dfdStart.status('Waiting for audioVideoRenegotiation completed event');
                                }
                            }
                        },
                        'audioVideoRenegotiation completed': function (status, resource, event) {
                            var href = resource.link('audioVideoSession').href;
                            if (href in avSessions) {
                                if (resource.get('direction') == 'Outgoing') {
                                    assert(resource.get('operationId') in outAvRenegoOpIds);
                                    delete outAvRenegoOpIds[resource.get('operationId')];
                                    if (status == 'Success') {
                                        avSessions[href].renegotiated = true;
                                        setFinalAnswer(resource.link('mediaAnswer').href, avSessions[href].resource.get('remoteEndpoint'));
                                    }
                                    completeNegotiation(status, event.reason);
                                    if (dfdStart && dfdStart.promise.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by the second start() call
                                        // to add video to an audio conversation
                                        if (status == 'Success')
                                            dfdStart.resolve();
                                        else
                                            dfdStart.reject();
                                    }
                                }
                                else {
                                    // the renegotiation may be in response to remote participant hold/resume
                                    if (!isConferencing()) {
                                        if (remoteHoldState == RemoteHoldState.HoldAnswered)
                                            remoteHoldState = RemoteHoldState.HoldCompleted;
                                        else if (remoteHoldState == RemoteHoldState.ResumeAnswered)
                                            remoteHoldState = RemoteHoldState.ResumeCompleted;
                                    }
                                    completeNegotiation(status, event.reason);
                                }
                            }
                        },
                        'audioVideo updated': function (status, resource, event) {
                            if (rAVInvitation && resource.href == rAVInvitation.link('audioVideo').href) {
                                if (resource.get('state') == 'Disconnected') {
                                    if (rAVInvitation.get('state') == 'Connected') {
                                        // This is our chance to clean up the established call that is terminated by
                                        // the remote party. The local party terminates the established call via modality.stop()
                                        // and hang-ups by either party during call setup are processed by audioVideoInvitation
                                        // started/completed event handlers.
                                        cleanup();
                                        // setting this modality state to disconnected will cause its removal from
                                        // the conversation
                                        state(Internal.Modality.State.Disconnected);
                                    }
                                }
                                else if (resource.get('state') == 'Connected' &&
                                    event.reason && event.reason.subcode == 'SessionSwitched' &&
                                    resource.link('audioVideoSession').href in avSessions) {
                                    // this is the escalation confirmation, i.e. this AV session replaced the
                                    // original P2P AV session
                                    escalated.fire('success');
                                    fEscalation = false;
                                }
                            }
                        },
                        // participantAudio/Video added/deleted events for a localParticipant are used to
                        // track active modalities of this client
                        'participantAudio added': onParticipantAudio,
                        'participantAudio updated': onParticipantAudio,
                        'participantAudio deleted': onParticipantAudio,
                        'participantVideo added': onParticipantVideo,
                        'participantVideo updated': onParticipantVideo,
                        'participantVideo deleted': onParticipantVideo,
                        'escalateAudio deleted': function (status, resource, event) {
                            if (event.target.href == escalateAudioVideoUri)
                                escalateAudioVideoUri = null;
                        },
                        // these events are fired in the later phase of the escalation when the setup of our inactive AV call
                        // to a conference is finished and we may activate (resume) it.
                        'resumeAudio added': onResumeAudioVideoAdded,
                        'resumeAudioVideo added': onResumeAudioVideoAdded,
                        'resumeAudio deleted': onResumeAudioVideoDeleted,
                        'resumeAudioVideo deleted': onResumeAudioVideoDeleted
                    };
                    // returns a participant object from a participants collection
                    function getParticipant(href) {
                        var participant = participants(href);
                        if (!participant) {
                            participants.each(function (p) {
                                if (p[Internal.sHref] == href)
                                    participant = p;
                            });
                        }
                        if (participant)
                            return participant;
                        // shortcut for a 1:1 conversation with a participant added to the conversation beforehand
                        //
                        // The check for participant size is needed because if the AV conversation is started not with the
                        // participant from a person model but using the sip uri as a parameter, we would have to rely on
                        // "participant added" event for the remote guy to become a member of participants collection.
                        // If miraculously this event arrives after "participantAudio/Video added" we would have an empty
                        // participants collection here.
                        if (!isConferencing() && participants.size() == 1) {
                            return participants(0);
                        }
                        // "participantAudio/Video added" event arrives right after "participant added" event. If the
                        // participant was added to the conversation's participant collection using its contact href,
                        // the "participant added" event handler is doing another server lookup to match that contact href
                        // to the participant href. So we can't find that participant here either and we need to do the
                        // same lookup.
                        return ucwa.send('GET', href).then(function (r) {
                            return participants(r.link('contact').href);
                        });
                    }
                    function isInMediaRoster(participant) {
                        var p = participant[Internal.sInternal];
                        return pcAV && p.isInMediaRoster[pcAV.id()];
                    }
                    function updateMediaRoster(participant, type) {
                        try {
                            var method = type == 'add' ? 'AddParticipantInfo' :
                                type == 'remove' ? 'RemoveParticipantInfo' :
                                    type == 'update' ? 'UpdateParticipantInfo' :
                                        assert(false);
                            var p = participant[Internal.sInternal];
                            // pcAV may not exist yet when when we join the meeting which participants are already on the AV call.
                            // In this case 'participantVideo added' events for such participants may come before we finish
                            // joining the meeting so we have not loaded the plugin AVComponent.
                            pcAV.invoke(method, p.audioSourceId(), p.videoSourceId(), -1);
                            p.isInMediaRoster[pcAV.id()] = type != 'remove';
                            return true;
                        }
                        catch (err) {
                            log('Media Roster ERROR: ' + err);
                            return false;
                        }
                    }
                    // event handler for "participantAudio added/updated/deleted in participant|localParticipant" events
                    //  - tracks session audio state (on/off) and participant audio state.
                    function onParticipantAudio(status, resource, event) {
                        var scope = event['in'];
                        if (event.sender.href == rConversation.href && scope) {
                            if (scope.rel == 'localParticipant') {
                                switch (event.type) {
                                    case 'added': // signal for the initial AV session
                                    case 'updated':
                                        if (isConferencing())
                                            selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                        activeModalities.audio = true;
                                        audioState(Internal.Modality.State.Connected);
                                        break;
                                    case 'deleted':
                                        activeModalities.audio = false;
                                        audioState(Internal.Modality.State.Disconnected);
                                        break;
                                    default:
                                        assert(false, 'unexpected event type');
                                }
                            }
                            else if (scope.rel == 'participant') {
                                Task.wait(getParticipant(scope.href)).then(function (participant) {
                                    switch (event.type) {
                                        case 'added':
                                        case 'updated':
                                            if (isConferencing()) {
                                                participant[Internal.sInternal].setMediaSourceId(event);
                                                // In conference mode, the indication of a remote
                                                // participant hold/resume or mute/unmute is
                                                // "participantAudio updated" event. We need to
                                                // reload "participantAudio" resource and set the
                                                // properties accordingly
                                                if (event.type == 'updated') {
                                                    ucwa.send('GET', event.target.href).then(function (r) {
                                                        if (r.has('audioDirection')) {
                                                            participant[Internal.sInternal].audioOnHold(r.get('audioDirection') ==
                                                                AudioVideoDirection.Inactive);
                                                        }
                                                        if (r.has('audioMuted'))
                                                            participant[Internal.sInternal].audioMuted(r.get('audioMuted'));
                                                    });
                                                }
                                            }
                                            participant[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                            break;
                                        case 'deleted':
                                            participant[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                });
                            }
                        }
                    }
                    // event handler for "participantVideo added/updated/deleted in participant|localParticipant" events
                    //  - tracks session video state (on/off), participant video state and shows/removes video
                    //    when video modality is activated/deactivated.
                    function onParticipantVideo(status, resource, event) {
                        var scope = event['in'];
                        if (event.sender.href == rConversation.href && scope) {
                            if (scope.rel == 'localParticipant') {
                                switch (event.type) {
                                    case 'added':
                                    case 'updated':
                                        activeModalities.video = true;
                                        if (isConferencing()) {
                                            selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                            updateMediaRoster(selfParticipant, isInMediaRoster(selfParticipant) ? 'update' : 'add');
                                            // check participants that are already in the conference - we need their msis
                                            // because we won't receive "participantVideo added" events for them.
                                            participants.each(function (p) {
                                                if (!isInMediaRoster(p) && p[Internal.sInternal].audioSourceId() != -1)
                                                    updateMediaRoster(p, 'add');
                                            });
                                        }
                                        videoState(Internal.Modality.State.Connected);
                                        selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                        break;
                                    case 'deleted':
                                        removeVideo(selfVideoStream, true);
                                        activeModalities.video = false;
                                        if (isConferencing()) {
                                            if (isInMediaRoster(selfParticipant))
                                                updateMediaRoster(selfParticipant, 'remove');
                                            selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                        }
                                        videoState(Internal.Modality.State.Disconnected);
                                        selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                        break;
                                    default:
                                        assert(false, 'unexpected event type');
                                }
                            }
                            else if (scope.rel == 'participant') {
                                Task.wait(getParticipant(scope.href)).then(function (participant) {
                                    switch (event.type) {
                                        case 'added':
                                        case 'updated':
                                            if (isConferencing()) {
                                                participant[Internal.sInternal].setMediaSourceId(event);
                                                updateMediaRoster(participant, isInMediaRoster(participant) ? 'update' : 'add');
                                                participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                            }
                                            else {
                                                participant[Internal.sInternal].setVideoStream(mainVideoStream);
                                                participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                            }
                                            break;
                                        case 'deleted':
                                            if (isConferencing()) {
                                                if (isInMediaRoster(participant))
                                                    updateMediaRoster(participant, 'remove');
                                                participant[Internal.sInternal].setMediaSourceId(event);
                                                removeParticipantVideo(participant);
                                                participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                                // if participant video is deleted not because we stopped video
                                                // subscription explicitly (via isStarted(false)) but because 
                                                // participant left the AV call then we need to reset isStarted.
                                                participant[Internal.sInternal].setVideoStarted(false);
                                            }
                                            else {
                                                participant[Internal.sInternal].setVideoStream(null);
                                                participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                            }
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                });
                            }
                        }
                    }
                    // event handler for 'resumeAudio/resumeAudioVideo added' event
                    //   - activates the inactive conference session created during escalation
                    function onResumeAudioVideoAdded(status, resource, event) {
                        var scope = event['in'], href;
                        if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions) {
                            href = scope.href;
                            // Currently UCWA returns the 'renegotiations' link of the audioVideoSession as resumeAudio uri,
                            // i.e. avSessions[event.in.href].resource.link('renegotiations').href == event.target.href,
                            // but we cache it separately just in case
                            avSessions[href].resumeAudioVideoUri = event.target.href;
                            Task.wait(null).then(function () {
                                if (!avSessions[href].renegotiated) {
                                    return ucwa.wait({
                                        type: 'completed',
                                        target: { rel: 'audioVideoRenegotiation' },
                                        resource: function (r) {
                                            // r.get('operationId') in outAvRenegoOpIds;
                                            return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                        }
                                    });
                                }
                            }).then(function () {
                                resumeAudioVideo();
                            });
                        }
                    }
                    function onResumeAudioVideoDeleted(status, resource, event) {
                        var scope = event['in'];
                        if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions &&
                            event.target.href == avSessions[scope.href].resumeAudioVideoUri) {
                            delete avSessions[scope.href].resumeAudioVideoUri;
                        }
                    }
                    //#endregion server events
                    //#region plugin events
                    function onPluginComponentEvent(event) {
                        var handler = pluginEventHandlers[event.type];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler.apply(null, event.args);
                        }
                    }
                    var pluginEventHandlers = {
                        'CHANNEL_CREATED': function (channelType, channelId, isMain) {
                            switch (channelType) {
                                case 1 /* AUDIO */:
                                    audioChannel = { channelType: channelType, channelId: channelId };
                                    break;
                                case 2 /* VIDEO */:
                                    if (isMain) {
                                        mainVideoStream._id(channelId);
                                        selfVideoStream._id(channelId);
                                    }
                                    else {
                                        assert(isConferencing());
                                        videoStreams.add(MediaStream({
                                            mediaPlugin: mediaPlugin,
                                            type: MediaEnum.StreamType.Render,
                                            id: channelId
                                        }));
                                        // max number of remote participant video streams in a meeting
                                        // = max num of plugin channels excluding the main channel
                                        assert(videoStreams.size() < mediaConfig.maxVideoChannelCount());
                                        log('Num streams created: ' + videoStreams.size());
                                    }
                                    break;
                                default:
                                    log('Created a channel of unknown type ' + channelType);
                                    // debugger;
                                    break;
                            }
                        },
                        'CHANNEL_DIRECTION_CHANGED': function (channelType, channelId, direction) {
                            // wire participant.audio.isOnHold to direction:
                            //   - MediaEnum.MediaConfig.NO_ACTIVE_MEDIA: hold
                            //   - otherwise (likely MediaEnum.MediaConfig.BOTH): resume
                            if (remoteHoldState == RemoteHoldState.HoldCompleted) {
                                if (direction == 4 /* NO_ACTIVE_MEDIA */ && !isConferencing())
                                    participants(0)[Internal.sInternal].audioOnHold(true);
                                remoteHoldState = RemoteHoldState.Unknown;
                            }
                            else if (remoteHoldState == RemoteHoldState.ResumeCompleted) {
                                if (!isConferencing()) {
                                    // note: direction can be MediaConfig.NO_ACTIVE_MEDIA
                                    // if local participant is on hold
                                    participants(0)[Internal.sInternal].audioOnHold(false);
                                }
                                remoteHoldState = RemoteHoldState.Unknown;
                            }
                            // CHANNEL_DIRECTION_CHANGED is a good hint for detecting...
                            if (channelType == 2 /* VIDEO */ &&
                                selfVideoStream._id() == channelId) {
                                //... if self participant is streaming video
                                switch (direction) {
                                    case 1 /* SEND */:
                                    case 3 /* BOTH */:
                                        selfParticipant[Internal.sInternal].setVideoStarted(true);
                                        selfVideoStream._isFlowing(true);
                                        break;
                                    case 2 /* RECEIVE */:
                                        selfParticipant[Internal.sInternal].setVideoStarted(false);
                                        selfVideoStream._isFlowing(false);
                                        break;
                                }
                                //... and if remote participant in a 1:1 conversation is streaming video
                                if (!isConferencing()) {
                                    assert(mainVideoStream._id() == channelId);
                                    switch (direction) {
                                        case 1 /* SEND */:
                                            participants(0)[Internal.sInternal].setVideoStarted(false);
                                            mainVideoStream._isFlowing(false);
                                            break;
                                        case 2 /* RECEIVE */:
                                        case 3 /* BOTH */:
                                            participants(0)[Internal.sInternal].setVideoStarted(true);
                                            mainVideoStream._isFlowing(true);
                                            break;
                                    }
                                }
                            }
                        },
                        'MEDIA_CHANGED': function (channelType, channelId, direction, mediaEvent) {
                            var streamState;
                            if (channelType == 2 /* VIDEO */) {
                                streamState = enumcastStreamState(mediaEvent);
                                if (mainVideoStream._id() == channelId && direction == 2 /* RENDER */)
                                    mainVideoStream._state(streamState);
                                else if (selfVideoStream._id() == channelId && direction == 1 /* CAPTURE */)
                                    selfVideoStream._state(streamState);
                                else {
                                    videoStreams.each(function (vs) {
                                        if (vs._id() == channelId)
                                            vs._state(streamState);
                                    });
                                }
                            }
                        },
                        // yes, it's not a typo but a plugin bug
                        'DOMINANT_SPEKAER_CHANGED': function () {
                            // arguments - num of speakers, msi0, msi1, ... 
                            //   the most recent speaker is the first in the list; 
                            //   if msi0 == -1, nobody is speaking
                            var msi = arguments[1], cur, prev = recentActiveSpeakers[activeSourceId];
                            if (prev)
                                prev[Internal.sInternal].isSpeaking(false);
                            if (msi == -1) {
                                activeSourceId = msi;
                                return;
                            }
                            cur = recentActiveSpeakers[msi];
                            if (!cur) {
                                // we have a new speaker who has not talked before
                                if (selfParticipant[Internal.sInternal].audioSourceId() == msi) {
                                    cur = selfParticipant;
                                }
                                else {
                                    participants.each(function (p) {
                                        if (p[Internal.sInternal].audioSourceId() == msi)
                                            cur = p;
                                    });
                                }
                                if (cur)
                                    recentActiveSpeakers[msi] = cur;
                            }
                            if (cur) {
                                cur[Internal.sInternal].isSpeaking(true);
                                activeSourceId = msi;
                            }
                        },
                        'OFFER_READY': function (hasOffer, diagCode, sdpCount) {
                            var i, offers = [], renegoHref;
                            try {
                                for (i = 0; i < sdpCount; i++) {
                                    offers.push({
                                        sdp: arguments[3 + i * 2],
                                        id: arguments[3 + i * 2 + 1]
                                    });
                                }
                                if (offers.length == 0)
                                    throw Exception('NoSdpOffers', { diagCode: diagCode });
                                renegoHref = getRenegotiationsHref();
                                if (renegoHref) {
                                    // A negotiated AudioVideoSession already exists, the client starts renegotiation -
                                    // expect an "audioVideoRenegotiation completed" event from UCWA after
                                    // sending renegotiation offer
                                    sendRenegotiationOffer(offers[0].sdp, renegoHref);
                                }
                                else {
                                    // The client starts AV session - expect an "audioVideoInvitation completed"
                                    // event from UCWA after sending the invitation
                                    sendOffer(offers).then(function () {
                                        dfdStart.resolve();
                                        state(Internal.Modality.State.Connected);
                                    }, function (error) {
                                        // if the caller hangs up by canceling this promise explicitly we wind up
                                        // here with the rejected promise
                                        if (dfdStart.promise.state() == 'pending')
                                            dfdStart.reject(error);
                                        state(Internal.Modality.State.Disconnected, error);
                                        audioState(Internal.Modality.State.Disconnected);
                                        videoState(Internal.Modality.State.Disconnected);
                                        cleanup();
                                    }, dfdStart.status);
                                }
                            }
                            catch (error) {
                                if (dfdStart)
                                    dfdStart.reject(error);
                            }
                        },
                        'ANSWER_READY': function (_arg0, sdp) {
                            log('SDP Answer:\n' + sdp);
                            if (rAVRenegotiation) {
                                if (!isConferencing()) {
                                    if (remoteHoldState == RemoteHoldState.HoldOffered)
                                        remoteHoldState = RemoteHoldState.HoldAnswered;
                                    else if (remoteHoldState == RemoteHoldState.ResumeOffered)
                                        remoteHoldState = RemoteHoldState.ResumeAnswered;
                                }
                                // the client answers the incoming renegotiation request
                                // expect an "audioVideoRenegotiation completed" after this call
                                ucwa.send('POST', rAVRenegotiation.link('answer').href, {
                                    headers: { 'Content-Type': 'application/sdp' },
                                    data: sdp,
                                    nobatch: true
                                });
                            }
                            else {
                                // the client answers the incoming invitation
                                dfdAccept.status('sending answer to UCWA');
                                invitation.acceptWithAnswer(sdp, sessionContext).then(function () {
                                    dfdAccept.status('awaiting an "audioVideoInvitation completed" event from UCWA');
                                }, function (error) {
                                    dfdAccept.reject(error);
                                    state(Internal.Modality.State.Disconnected, error);
                                    audioState(Internal.Modality.State.Disconnected);
                                    videoState(Internal.Modality.State.Disconnected);
                                }, dfdAccept.status);
                            }
                        }
                    };
                    //#endregion plugin events
                    //#region sendOffer
                    /**
                    * Composes an SDP offer from the OFFER_READY media plugin event data and
                    * sends it to the server to start an AV session.
                    *
                    * The returned promise is resolved only when we get a reply to the post and
                    * and audioVideoInvitation completed event
                    */
                    function sendOffer(offers) {
                        assert(offers.length > 0);
                        // construct content that contains all offers given by the media plugin
                        function createOfferOptions(context) {
                            var boundary = '9BCE36B8-2C70-44CA-AAA6-D3D332ADBD3F', mediaOffer, options = { nobatch: true };
                            if (isConferencing()) {
                                if (escalateAudioVideoUri) {
                                    mediaOffer = multipartSDP(offers, boundary);
                                    options = {
                                        headers: {
                                            'Content-Type': 'multipart/alternative;boundary=' + boundary +
                                                ';type="application/sdp"',
                                            'Content-Length': '' + mediaOffer.length
                                        },
                                        query: {
                                            operationId: operationId,
                                            sessionContext: sessionContext
                                        },
                                        data: mediaOffer,
                                        nobatch: true
                                    };
                                }
                                else {
                                    options.data = multipartJsonAndSDP({
                                        offers: offers,
                                        boundary: boundary,
                                        operationId: operationId,
                                        sessionContext: sessionContext,
                                        threadId: threadId,
                                        context: context
                                    });
                                    options.headers = {
                                        'Content-Type': 'multipart/related;boundary=' + boundary +
                                            ';type="application/vnd.microsoft.com.ucwa+json"'
                                    };
                                }
                            }
                            else {
                                // P2P mode
                                options.data = multipartJsonAndSDP({
                                    to: remoteUri,
                                    offers: offers,
                                    boundary: boundary,
                                    operationId: operationId,
                                    sessionContext: sessionContext,
                                    threadId: threadId,
                                    context: context
                                });
                                options.headers = {
                                    'Content-Type': 'multipart/related;boundary=' + boundary +
                                        ';type="application/vnd.microsoft.com.ucwa+json"'
                                };
                            }
                            if (context)
                                extend(options.headers, { 'X-MS-RequiresMinResourceVersion': 2 });
                            return options;
                        }
                        return async(getStartAudioVideoLink).call().then(function (link) {
                            var options = createOfferOptions(link.revision >= 2 && invitationContext), dfdPost, dfdCompleted;
                            dfdPost = ucwa.send('POST', link.href, options).then(function (r) {
                                // POST to startAudioVideo/addAudioVideo returns an empty response with an AV invitation
                                // URI in the Location header. The UCWA stack constructs and returns an empty resource
                                // with href set to that URI.
                                if (!rAVInvitation)
                                    rAVInvitation = r;
                            });
                            // wait for the "audioVideoInvitation completed" event that corresponds to the given conversation
                            dfdCompleted = ucwa.wait({
                                type: 'completed',
                                target: { rel: 'audioVideoInvitation' },
                                resource: { direction: 'Outgoing', threadId: threadId, operationId: operationId, sessionContext: sessionContext }
                            }).then(function (event) {
                                if (event.status == 'Failure') {
                                    // if remote SIP uri is invalid we won't receive "audioVideoInvitation started" event,
                                    // thus we won't have a full rAVInvitation resource cached. It will be either undefined or
                                    // just an empty resource with an href returned by a response to startAudioVideo POST (if
                                    // that response arrived before this event). So we cache the invitation resource here,
                                    // since it may be used by other event handlers.
                                    rAVInvitation = event.resource;
                                    // Technically we may need to complete the negotiation if it was started (i.e. if the call
                                    // reached the remote party and was declined).
                                    completeNegotiation(event.status, event.reason);
                                    throw Internal.EInvitationFailed(event.reason);
                                }
                                completeNegotiation(event.status, event.reason);
                            });
                            return Task.waitAll([dfdPost, dfdCompleted]);
                        });
                    }
                    //#endregion
                    //#region sendRenegotiationOffer
                    /**
                     * Composes an SDP offer from the OFFER_READY media plugin event data and
                     * sends it to the server to renegotiate the AV session.
                     */
                    function sendRenegotiationOffer(sdp, url) {
                        log('Renegotiation SDP offer:\n', sdp);
                        // cache operation id
                        var operationId = guid();
                        outAvRenegoOpIds[operationId] = "";
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { operationId: operationId },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    //#endregion
                    //#region setOffer
                    /**
                     * Invokes pcAV.invoke("SetOffer", ...) with the given set of SDPs,
                     * e.g. pcAV.invoke("SetOffer", false, 2, sdp1, id1, sdp2, id2).
                     *
                     * @param {Object[]} offers
                     * @returns Whatever pcAV returns.
                     */
                    function setOffer(offers) {
                        assert(offers.length >= 0);
                        var i, offer, args = ['SetOffer', false, offers.length];
                        for (i = 0; i < offers.length; i++) {
                            offer = offers[i];
                            assert('sdp' in offer);
                            assert('id' in offer);
                            args.push(offer.sdp);
                            args.push(offer.id);
                        }
                        return pcAV.invoke.apply(pcAV, args);
                    }
                    //#endregion
                    //#region resumeAudioVideo
                    /**
                     * Activates (resumes) the AV conference call created in inactive state
                     * when a p2p call is escalated to a conference.
                     */
                    function resumeAudioVideo() {
                        var audioConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                        mainVideoConfig = activeModalities.video ?
                            (onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */) :
                            0 /* NOT_PRESENT */;
                        pcAV.invoke('SetMediaConfig', audioConfig, mainVideoConfig, mediaConfig.maxVideoChannelCount() - 1, 2 /* RECEIVE */, 0 /* NOT_PRESENT */); // panoVideoConfig
                    }
                    //#endregion
                    //#region setRenegotiationOffer
                    function setRenegotiationOffer(sdp) {
                        // LWA uses the empty string as the Content-ID for the SDP in the case of renegotiation
                        var id = '';
                        var mediaConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                        log('Incoming SDP offer:\n' + sdp);
                        pcAV.invoke('SetAcceptedMedia', mediaConfig, mediaConfig); // video
                        pcAV.invoke('SetOffer', false, 1, sdp, id);
                    }
                    //#endregion
                    //#region setProvisionalAnswer
                    /**
                     * Sets the provisional SDP answer from the remote party
                     */
                    function setProvisionalAnswer(mediaAnswer, remoteEndpoint) {
                        var sdp = DataUri(mediaAnswer).data;
                        log('Provisional answer from the remote party:\n' + sdp);
                        pcAV.invoke('SetProvisionalAnswer', true, true, remoteEndpoint, sdp);
                    }
                    //#endregion
                    //#region setFinalAnswer
                    /**
                     * Sets the final SDP answer from the remote party
                     */
                    function setFinalAnswer(mediaAnswer, remoteEndpoint) {
                        var sdp = DataUri(mediaAnswer).data;
                        log('Final answer from the remote party:\n' + sdp);
                        pcAV.invoke('SetFinalAnswer', remoteEndpoint, sdp);
                    }
                    //#endregion
                    //#region completeNegotiation
                    /**
                     * Completes SDP negotiation
                     */
                    function completeNegotiation(eventStatus, reason) {
                        var errCode;
                        // the component may have already been cleaned up (the caller canceled the call
                        // while it was connecting)
                        if (pcAV) {
                            errCode = eventStatus == 'Success' ?
                                MediaEnum.NegotiationStatus.NS_SUCCESS :
                                (reason && reason.code == 'RemoteFailure') ?
                                    MediaEnum.NegotiationStatus.NS_REMOTE_INTERNAL_ERROR :
                                    MediaEnum.NegotiationStatus.NS_LOCAL_INTERNAL_ERROR;
                            pcAV.invoke('CompleteNegotiation', errCode);
                        }
                    }
                    //#endregion
                    //#region getStartAudioVideoUri
                    /**
                     * The first SDP offer is sent to the link given by this function.
                     */
                    function getStartAudioVideoLink() {
                        // if the AV modality is the 1-st modality in the conversation,
                        // send a request to the global startAudioVideo link
                        if (!rConversation)
                            return ucwa.get({ rel: 'communication' }).link('startAudioVideo');
                        // if this is an escalation from P2P to a conference, send the
                        // request to the escalation link
                        if (escalateAudioVideoUri)
                            return ucwa.get(escalateAudioVideoUri);
                        // if the AV modality gets added to an existing conversation,
                        // send the request to its addAudioVideo link
                        return ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAV) {
                            return rAV.link('addAudioVideo');
                        });
                    }
                    //#endregion
                    return self;
                }
                //#endregion
                //#region multipartJsonAndSDP
                /**
                 * This function constructs the message body of the audioVideoInvitation
                 * HTTP POST used in the multiparty conference situation. The multiparty
                 * SDP offer message body will contain all the SDP offers separated by
                 * some boundary mark.
                 *
                 * This is an example of the multiparty SDP offer message body:
                 *
                 * --09B8DAEF
                 * Content-Type: application/vnd.microsoft.com.ucwa+json
                 * Content-Length: 274
                 *
                 * {"operationId":"0D1DBA19","sessionContext":"6A6A17C9","mediaOffer":"cid:BC4833B8",
                 * "telemetryId":"c380da57","joinAudioMuted":true,"joinVideoMuted":false}
                 * --09B8DAEF
                 * Content-ID: BC4833B8
                 * Content-Type: multipart/alternative;boundary=CA93AA8F;type="application/sdp"
                 * Content-Length: 12464
                 *
                 *
                 * --CA93AA8F
                 * Content-Type: application/sdp
                 * Content-ID: <b4511a64f3e11159b46a38d4c54771c2@6485c71fa8ec29075dcec063a43a27ea>
                 * Content-Length: 3897
                 *
                 * ...(sdp offer 1 content start)...
                 * v=0
                 * o=- 0 0 IN IP4 131.107.255.94
                 * ...(sdp content end)...
                 *
                 * --CA93AA8F
                 * Content-Type: application/sdp
                 * Content-ID: <f8bea11cdb9fc648b471381edb8c1587@5215feaa2950a58d4a3749e7a071b402>
                 * Content-Length: 8167
                 *
                 * ...(sdp offer 2 content start)...
                 * v=0
                 * o=- 0 1 IN IP4 131.107.255.94
                 * ...(sdp content end)...
                 *
                 * --CA93AA8F
                 *
                 * --09B8DAEF
                 *
                 * Note: wherever Content-Length is needed in the header section, the
                 * content needs to be established beforehand in order to calculate the
                 * Content-Length.
                 *
                 * The caller of this function needs to generate the boundary mark, which
                 * needs to be inserted into the "Content-Type" header field of the HTTP
                 * POST message like this:
                 *      multipart/related;boundary=09B8DAEF;type="application/vnd.microsoft.com.ucwa+json"
                 *
                 * @param {Object[]} offers - An array of media offers.
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @param {String} boundary - a guid that separates multiple SDP offers
                 * @param {String} operationId - a guid that represents the current operation
                 * @param {String} threadId - a guid that represents the current thread
                 * @param {String} sessionContext - a session-specific guid
                 * @param {String} [to] - remote uri if this method is called for a 1:1 conversation
                 * @param {Object} [context] - A context that can be serialized as one of multiparts in the
                 *                             http request for sending audiovideo invitation.
                 *
                 */
                function multipartJsonAndSDP(options) {
                    var offers = options.offers, boundary = options.boundary, operationId = options.operationId, threadId = options.threadId, sessionContext = options.sessionContext || guid(), context = options.context, sdpBoundary = 'D63E5F1E-56D8-4EC4-B51B-02762CEA97D9', mediaCid = '4EFFF0D8-65D2-4E52-9A1B-0FA835D4B478', contextCid = '2CAE7DF5 -0185-4FB8-84E7-AA6C57F10432', multipartBLine = '--' + boundary + '\r\n', msg = multipartBLine, params, strParams, sdps;
                    // construct the JSON part containing parameters
                    params = {
                        operationId: operationId,
                        threadId: threadId,
                        sessionContext: sessionContext,
                        mediaOffer: 'cid:' + mediaCid
                    };
                    if (context)
                        extend(params, { customContent: 'cid:' + contextCid });
                    if (options.to) {
                        params.to = options.to;
                    }
                    else {
                        params.telemetryId = guid();
                        params.joinAudioMuted = false;
                        params.joinVideoMuted = false;
                    }
                    strParams = JSON.stringify(params);
                    msg += 'Content-Type: application/vnd.microsoft.com.ucwa+json\r\n' +
                        'Content-Length: ' + strParams.length + '\r\n' +
                        '\r\n' +
                        strParams +
                        '\r\n';
                    // a boundary line
                    msg += multipartBLine;
                    //construct the multipart SDP part
                    sdps = multipartSDP(offers, sdpBoundary);
                    msg += 'Content-ID: ' + mediaCid + '\r\n' +
                        'Content-Type: multipart/alternative;boundary=' + sdpBoundary + ';type="application/sdp"\r\n' +
                        'Content-Length: ' + sdps.length + '\r\n' +
                        sdps;
                    if (context) {
                        msg += '\r\n';
                        // a boundary line
                        msg += multipartBLine;
                        // the specified Content-Disposition header allows this multipart content always
                        // processed to the end point, which may not regiser 'text/json' as its supported format.
                        msg += 'Content-ID: ' + contextCid + '\r\n' +
                            'Content-Type:text/json' + '\r\n' +
                            'Content-Disposition: render; handling=optional' + '\r\n' +
                            '\r\n' +
                            JSON.stringify(context);
                    }
                    // message is ended with a boundary ending line
                    return msg + '\r\n--' + boundary + '--\r\n';
                }
                Internal.multipartJsonAndSDP = multipartJsonAndSDP;
                //#endregion
                //#region multipartSDP
                /**
                 * Constructs the body of a multipart SDP message
                 *
                 * @param {Object} offers - SDP media offers.
                 *     - offer.sdp - SDP content of the offer.
                 *     - offer.id - Content ID of offer.
                 * @param {String} boundary - a boundary separating the parts.
                 *
                 */
                function multipartSDP(offers, boundary) {
                    var s = '\r\n', i;
                    for (i = 0; i < offers.length; ++i)
                        s += constructSDP(offers[i], boundary);
                    s += ('\r\n--' + boundary + '--\r\n');
                    return s;
                }
                Internal.multipartSDP = multipartSDP;
                //#endregion
                //#region constructSDP
                /**
                 * This function constructs one SDP offer message to be embedded into
                 * the multipart SDP offer message body.
                 *
                 * The SDP offer message needs to follow the following format:
                 *
                 *      empty line
                 *      SDP section boundary line
                 *      header
                 *          Content-Type
                 *          Content-ID
                 *          Content-Length
                 *      SDP content
                 *
                 * @param {Object} offer - An SDP media offer.
                 *     - offer.sdp - SDP content of the offer.
                 *     - offer.id - Content ID of offer.
                 *
                 * @param {String} boundary - a guid that separates multiple SDP offers
                 *
                 */
                function constructSDP(offer, boundary) {
                    assert(offer && offer.sdp && offer.id && boundary);
                    return '\r\n' +
                        '--' + boundary + '\r\n' +
                        'Content-Type: application/sdp\r\n' +
                        'Content-ID: ' + offer.id + '\r\n' +
                        'Content-Length: ' + offer.sdp.length + '\r\n' +
                        '\r\n' +
                        offer.sdp;
                }
                //#endregion
                //#region AudioVideoInvitation
                /**
                 * This model represents an audioVideoInvitation resource.
                 *
                 * An audioVideoInvitation resource may have the following form:
                 *
                 *      {
                 *          "rel": "audioVideoInvitation",
                 *          "bandwidthControlId": "...",
                 *          "direction": "Incoming",
                 *          "importance": "Normal",
                 *          "threadId": "...",
                 *          "state": "Connecting",
                 *          "privateLine": false,
                 *          "subject": "...",
                 *          "_links": {
                 *              "self": ...,
                 *              "to":
                 *              "conversation": ...,
                 *              "acceptWithAnswer": ...,
                 *              "sendProvisionalAnswer": ...,
                 *              "decline": ...,
                 *              "audioVideo": ...,
                 *              "mediaOffer": ...
                 *          },
                 *          "_embedded": {
                 *              "from": {
                 *                  "rel": "participant",
                 *                  ...
                 *              }
                 *          }
                 *      }
                 *
                 * @param {Resource} resource - A resource with rel=audioVideoInvitation.
                 * @param {UCWA} ucwa
                 *
                 * @member {Participant} from
                 * @member {Object[]} offers - An array of media offers.
                 *
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @method {Promise} decline
                 * @method {Promise} acceptWithAnswer(sdp, sessionContext)
                 *
                 */
                function AudioVideoInvitation(options) {
                    var resource = options.resource, ucwa = options.ucwa, from = options.from;
                    check.equals(resource.rel, 'audioVideoInvitation');
                    var offers = getMediaOffers();
                    var self = {
                        resource: resource,
                        acceptWithAnswer: async(acceptWithAnswer),
                        decline: async(decline),
                        offers: offers,
                        from: from,
                        hasVideo: function () {
                            return contains(offers, function (offer) {
                                return /\bm=video\b/gmi.test(offer.sdp);
                            });
                        }
                    };
                    /**
                     * Reads the "mediaOffer" link and converts it to a collection SDPs.
                     *
                     * The "mediaOffer" link may have the following form:
                     *
                     *  data:multipart/alternative;charset=utf-8;boundary=e47d80f2,
                     *  --e47d80f2
                     *  Content-Type:+application/sdp
                     *  Content-ID:+<9544aa8a8ac9dfe08fad74893bd1095e@contoso.com>
                     *  Content-Disposition:+session;+handling=optional;+proxy-fallback
                     *
                     *  v=0
                     *  o=-+0+0+IN+IP4+127.0.0.1
                     *  s=session
                     *  ...
                     *
                     *  --e47d80f2
                     *  Content-Type:+application/sdp
                     *  Content-ID:+<cdfd6188fd977372c577873b03dd580d@contoso.com>
                     *  Content-Disposition:+session;+handling=optional
                     *
                     *  v=0
                     *  o=-+0+1+IN+IP4+127.0.0.1
                     *  s=session
                     *  c=IN+IP4+127.0.0.1
                     *  ...
                     *
                     *  --e47d80f2
                     */
                    function getMediaOffers() {
                        var href, dataUri, responses;
                        href = resource.relatedHref('mediaOffer');
                        if (!href)
                            return [];
                        dataUri = DataUri(href);
                        try {
                            responses = parseMultipartRelatedResponse({
                                responseText: dataUri.data,
                                headers: 'Content-Type:multipart/related;boundary=' + dataUri.attributes.boundary
                            });
                            return map(responses, function (response) {
                                var headers = HttpHeaders(response.headers);
                                return {
                                    sdp: response.responseText,
                                    id: headers.get('Content-ID')
                                };
                            });
                        }
                        catch (error) {
                            // if the media offer is not a multipart/alternate-encoded
                            // set of SDPs, consider it as a single SDP
                            return [{
                                    sdp: dataUri.data,
                                    id: ''
                                }];
                        }
                    }
                    function acceptWithAnswer(sdp, sessionContext) {
                        var url = resource.link('acceptWithAnswer').href;
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { sessionContext: sessionContext },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    function decline() {
                        return ucwa.send('POST', resource.link('decline').href, {
                            data: { reason: 'Local' },
                            nobatch: true
                        });
                    }
                    return self;
                }
                Internal.AudioVideoInvitation = AudioVideoInvitation;
                //#endregion
                //#region AppSharingModality
                /**
                 * Starts outgoing app sharing and receives incoming app sharing.
                 * Uses the native media plugin for that.
                 *
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 * @param {SharedResources} sharedResources
                 * @param {String} [threadId] - Required for outgoing app sharing.
                 * @param {AppSharingInvitation} [invitation] - Required for incoming app sharing.
                 * @param {Resource} [resource] - Required for incoming app sharing.
                 * @param {Collection} participants
                 * @param {Resource} [rConversation] - The parent rel=conversation resource.
                 *
                 *      If the AS modality gets added to an existing conversation, the AS call
                 *      is started with sending a POST request to rel=conversation/rel=applicationSharing/rel=addScreenSharing.
                 *
                 *      If the AS modality is the first modality in the conversation, then the
                 *      AS call is started with sending the same request to the global rel=startScreenSharing link.
                 *
                 * @property {Modality.State} state
                 * @property {ShareableWindow|ShareableMonitor} shared - the currently shared content
                 *
                 * @member {Participant} from
                 *
                 * @command {Promise} start - Starts an outgoing call.
                 * @command {Promise} accept - Accepts an incoming call.
                 * @command {Promise} decline - Declines an incoming call.
                 * @command {Promise} stop - Stops an ongoing call.
                 *
                 */
                function AppSharingModality(options) {
                    //#region Locals
                    var self = Model(), ucwa = options.ucwa, invitation = options.invitation, rConversation = options.rConversation, participants = options.participants, state = Property({
                        value: invitation ? Internal.Modality.State.Notified :
                            Internal.Modality.State.Created
                    }), threadId = options.threadId, mediaPlugin = options.mediaPlugin, sharedResources = options.sharedResources, mediaConfig, appSharing, pcASUI, shareable, dfdAccept, dfdStart, to, asSession, asRenegotiation, asInvitation = options.resource, outAsRenegoOpIds = {}, container, wHandle; // handle to App sharing viewer
                    options = null;
                    //#endregion
                    var shared = Property({
                        type: 'ShareableWindow|ShareableMonitor',
                        value: null,
                        get: function () {
                            return shareable;
                        },
                        set: function (val) {
                            return changeShared(val).then(function () {
                                return val;
                            });
                        }
                    });
                    //#region Initialization
                    extend(self, {
                        state: state.asReadOnly(),
                        shared: shared
                    });
                    if (invitation)
                        self.from = invitation.from;
                    state.changed(function (newState, reason, oldState) {
                        log('AppSharingModality::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    ucwa.event(onServerEvent);
                    //#endregion
                    //#region defineAsyncCommand
                    function defineAsyncCommand(name, states, method) {
                        var enabled = Property();
                        state.changed(function (value) {
                            enabled(indexOf(states, value) >= 0);
                        });
                        self[name] = Command(async(method), enabled);
                    }
                    //#endregion
                    //#region onServerEvent
                    function onServerEvent(event) {
                        var id = event.target.rel + ' ' + event.type;
                        var handler = ucwaEventHandlers[id];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler(event.status, event.resource, event);
                        }
                    }
                    var ucwaEventHandlers = {
                        'applicationSharingInvitation started': function (status, resource) {
                            // @todo: "POST startApplicationSharing" returns a URL of the applicationSharingInvitation resource
                            if (resource.properties.direction == 'Outgoing' &&
                                resource.properties.threadId == threadId) {
                                //assert(!asInvitation);
                                asInvitation = resource;
                                dfdStart.status('awaiting "applicationSharingNegotiation started" event from UCWA');
                            }
                        },
                        'applicationSharingNegotiation started': function (status, resource) {
                            var sdp, remoteEndpoint;
                            if (resource.relatedHref('applicationSharingInvitation') == asInvitation.href) {
                                sdp = DataUri(resource.relatedHref('mediaProvisionalAnswer')).data;
                                remoteEndpoint = resource.get('remoteEndpoint');
                                appSharing.setProvisionalAnswer(true, true, remoteEndpoint, sdp);
                                dfdStart.status('awaiting "applicationSharingNegotiation completed" event from UCWA');
                            }
                        },
                        'applicationSharingNegotiation completed': function (status, resource, event) {
                            if (event.sender.href == asInvitation.href) {
                                switch (status) {
                                    case 'Success':
                                        setFinalAnswer(resource, resource.get('remoteEndpoint'));
                                        dfdStart.status('awaiting "applicationSharingInvitation completed" event from UCWA');
                                        break;
                                    case 'Failure':
                                        dfdStart.status(event.reason && event.reason.message);
                                        break;
                                }
                            }
                        },
                        'applicationSharingSession added': function (status, resource) {
                            if (asInvitation.relatedHref('conversation') == resource.relatedHref('conversation'))
                                asSession = resource;
                        },
                        // handle { type:"completed", status:"Failure", reason:{...}, target:{rel:"applicationSharingInvitation"} }
                        // it may arrive before the "applicationSharingInvitation started" event, which this code does not expect
                        'applicationSharingInvitation completed': function (status, resource) {
                            if (asInvitation && asInvitation.href == resource.href) {
                                if (asInvitation.get('direction', '') == 'Outgoing') {
                                }
                                else if (asInvitation.get('direction', '') == 'Incoming') {
                                    if (status == 'Success') {
                                        try {
                                            // an "applicationSharingRenegotiation started" event may arrive later
                                            completeNegotiation(status);
                                            dfdAccept.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }
                                        catch (error) {
                                            dfdAccept.reject(error);
                                            state(Internal.Modality.State.Disconnected, error);
                                        }
                                    }
                                }
                            }
                        },
                        'applicationSharingRenegotiation started': function (status, resource) {
                            // LWA uses the empty string as the Content-ID for the SDP in the case of renegotiation
                            var sdp, id = '';
                            if (resource.properties.direction == 'Incoming' &&
                                resource.relatedHref('conversation') == asInvitation.relatedHref('conversation')) {
                                sdp = DataUri(resource.relatedHref('mediaOffer')).data;
                                log('Incoming SDP offer:\n' + sdp);
                                Task.wait(null).then(function () {
                                    if (state() === 'Connected' && shareable)
                                        return changeShared(null);
                                }).then(function () {
                                    appSharing.setOffer(false, 1, sdp, id);
                                });
                                // now expect one more ANSWER_READY event from the plugin
                                asRenegotiation = resource;
                            }
                        },
                        'applicationSharingRenegotiation completed': function (status, resource) {
                            if (resource.relatedHref('conversation') == asInvitation.relatedHref('conversation')) {
                                if (resource.get('direction') == 'Outgoing')
                                    setFinalAnswer(resource, asSession.get('remoteEndpoint'));
                                completeNegotiation(status);
                            }
                        },
                        'applicationSharing updated': function (status, resource) {
                            if (asInvitation && resource.href == asInvitation.relatedHref('applicationSharing') &&
                                resource.get('state') == 'Disconnected') {
                                if (resource.hasLink('applicationSharer')) {
                                    asSession = null;
                                    changeShared(null);
                                }
                                else {
                                    cleanup();
                                    state(Internal.Modality.State.Disconnected);
                                }
                            }
                        },
                        'conversation updated': function (status, resource) {
                            if (asInvitation && resource.href == asInvitation.relatedHref('conversation') &&
                                (resource.get('state') == 'Connected' || resource.get('state') == 'Conferenced')) {
                                var appSharing = indexOf(resource.get('activeModalities'), 'ApplicationSharing') >= 0;
                                if (appSharing) {
                                }
                            }
                        }
                    };
                    //#endregion
                    //#region onPluginComponentEvent
                    function onPluginComponentEvent(event) {
                        log('pcAS.event %c ' + event.type, 'color:blue', event.args);
                        var handler = pluginEventHandlers[event.type];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler.apply(null, event.args !== "" ? event.args : null);
                        }
                    }
                    var pluginEventHandlers = {
                        'OFFER_READY': function (hasOffer, diagCode, sdpCount) {
                            var i, offers = [];
                            try {
                                for (i = 0; i < sdpCount; i++) {
                                    offers.push({
                                        sdp: arguments[3 + i * 2],
                                        id: arguments[3 + i * 2 + 1]
                                    });
                                }
                                if (offers.length == 0)
                                    throw Exception('NoSdpOffers', { diagCode: diagCode });
                                if (asSession) {
                                    // expect an "applicationSharingRenegotiation completed" event from UCWA
                                    sendRenegotiationOffer(offers[0].sdp);
                                }
                                else {
                                    // expect an "applicationSharingInvitation started" event from UCWA
                                    sendOffer(offers).then(function () {
                                        dfdStart.resolve();
                                        state(Internal.Modality.State.Connected);
                                    }, function (error) {
                                        dfdStart.reject(error);
                                        state(Internal.Modality.State.Disconnected, error);
                                        cleanup();
                                    }, dfdStart.status);
                                }
                            }
                            catch (error) {
                                if (dfdStart)
                                    dfdStart.reject(error);
                            }
                        },
                        'ANSWER_READY': function (_arg0, sdp) {
                            if (asRenegotiation) {
                                // expect an "applicationSharingRenegotiation completed" after this call
                                ucwa.send('POST', asRenegotiation.link('answer').href, {
                                    headers: { 'Content-Type': 'application/sdp' },
                                    data: sdp,
                                    nobatch: true
                                });
                            }
                            else {
                                dfdAccept.status('sending answer to UCWA');
                                // expect an "applicationSharingRenegotiation started" after this call
                                invitation.acceptWithAnswer(sdp).then(function () {
                                    dfdAccept.status('awaiting a "applicationSharingInvitation completed" event from UCWA');
                                }, function (error) {
                                    state(Internal.Modality.State.Disconnected, error);
                                    dfdAccept.reject(error);
                                }, dfdAccept.status);
                            }
                        },
                        'StopSharing': function () {
                            self.stop();
                        }
                    };
                    //#endregion
                    //#region initMedia
                    function initMedia() {
                        return mediaConfig ?
                            Task.wait(mediaConfig) :
                            mediaPlugin.getMediaConfig() // otherwise load it and return when it becomes available
                                .then(function (mc) {
                                mediaConfig = mc;
                                return mediaConfig;
                            });
                    }
                    //#endregion
                    //#region setupAppShareViewerUI
                    function setupAppShareViewerUI() {
                        assert(!pcASUI);
                        pcASUI = mediaPlugin.createComponent({
                            type: 'AppShareViewerUI',
                            hide: false,
                            inproc: false
                        });
                        pcASUI.setContainer(container);
                        pcASUI.event(onViewerEvent, 'async');
                        return pcASUI.load();
                    }
                    //#endregion
                    //#region prepareAppSharing
                    // Based on supplied role (MediaEnum.AppSharingRole) this function will configure the
                    // needed plugins (AppShareCore/AppShareViewerUI) to allow sharing or viewing content.
                    function prepareAppSharing(role) {
                        function reinitSharing() {
                            return sharedResources.init().then(mediaPlugin.getAppSharing).then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                            });
                        }
                        function setupSharer() {
                            return Task.wait(null).then(function () {
                                sharedResources.windows.each(function (item) {
                                    sharedResources.setShared(item.id(), false);
                                });
                                sharedResources.monitors.each(function (item) {
                                    sharedResources.setShared(item.id(), false);
                                    item.selected(false);
                                });
                                sharedResources.setShared(shareable.id(), true);
                                appSharing.setCallConfig();
                                appSharing.setMediaConfig(3 /* BOTH */, 2 /* Sharer */);
                            });
                        }
                        function setupViewer() {
                            return Task.wait(null).then(function () {
                                if (!pcASUI)
                                    return setupAppShareViewerUI();
                            }).then(function () {
                                pcASUI.invoke('CreateAppShareViewerUI');
                                var result = pcASUI.invoke('GetViewerWindow');
                                if (result.length === 2 && result[1])
                                    wHandle = result[1];
                                appSharing.setCallConfig();
                                appSharing.initializeViewer(wHandle);
                                appSharing.connectViewer('connectString');
                                appSharing.setSmartSizingViewer(true);
                                appSharing.setViewerWindowSize(container.offsetWidth, container.offsetHeight);
                                if (isConferencing()) {
                                    appSharing.setMediaConfig(3 /* BOTH */, 1 /* Viewer */);
                                }
                                else {
                                    appSharing.createViewerStream();
                                }
                            });
                        }
                        if (role === 2 /* Sharer */) {
                            if (appSharing) {
                                return setupSharer();
                            }
                            else {
                                return reinitSharing().then(setupSharer);
                            }
                        }
                        else {
                            return Task.wait(null).then(function () {
                                if (appSharing) {
                                    return setupViewer();
                                }
                                else {
                                    return reinitSharing().then(setupViewer);
                                }
                            });
                        }
                    }
                    //#endregion
                    //#region onViewerEvent
                    function onViewerEvent(event) {
                        log('pcASUI.event %c ' + event.type, 'color:blue', event.args);
                        if (event.type == 'SIZE_CHANGED' && appSharing)
                            appSharing.setViewerWindowSize(event.args[0], event.args[1]);
                    }
                    //#endregion
                    //#region isConferencing
                    function isConferencing() {
                        return rConversation && (rConversation.get('state', '') == 'Conferenced' || rConversation.get('state', '') == 'Conferencing');
                    }
                    //#endregion
                    //#region start
                    /**
                     * Starts an outgoing app-sharing call. Under the hood it does the following:
                     *
                     *      - Get an AppSharingComponent from the media plugin.
                     *      - Attaches an event handle for plugin events.
                     *      - Marks all currently shared resources as not shared and shares the new resource.
                     *      - Invokes AppSharingComponent::SetCallConfig.
                     *      - Invokes AppSharingComponent::SetMediaConfig.
                     *      - Gets an OFFER_READY event from the AppSharingComponent.
                     *      - Sends a POST request to startApplicationSharing link with the SDP offer.
                     *      - Gets an "applicationSharingInvitation started" event from UCWA.
                     *      - Gets an "applicationSharingNegotiation started" event from UCWA with a provisional SDP answer.
                     *      - Invokes AppSharingComponent::SetProvisionalAnswer.
                     *      - Gets an "applicationSharingSession added" event.
                     *      - Gets an "applicationSharingNegotiation completed" event with a final SDP answer.
                     *      - Invokes AppSharingComponent::SetFinalAnswer.
                     *      - Gets a "applicationSharingInvitation completed" event from UCWA.
                     *      - Invokes AppSharingComponent::CompleteNegotiation.
                     *      - Gets a "applicationSharingRenegotiation started" event from UCWA.
                     *      - Gets a OFFER_READY event from AppSharingComponent with a new SDP answer.
                     *      - Sends a POST request to applicationSharingSession/renegotiations link.
                     *      - Gets a "applicationSharingRenegotiation completed" event from UCWA with a new SDP answer.
                     *      - Invokes AppSharingComponent::SetFinalAnswer.
                     *      - Invokes AppSharingComponent::CompleteNegotiation.
                     *
                     * @param {String} to - SIP URI of the remote participant.
                     * @param {ShareableWindow} window - Window resource to be shared
                     * @param {ShareableMonitor} monitor - Monitor resource to be shared
                     *
                     * @returns {Promise}
                     *
                     *      This promise gets resolved after the client receives an "applicationSharingInvitation completed" event.
                     *      The "status" property of the promise lets track the progress of the operation.
                     *      Since the promise gets resolved before the renegotiation starts, the progress
                     *      of the renegotiation cannot be monitored with it.
                     */
                    defineAsyncCommand('start', [Internal.Modality.State.Created], function (options) {
                        state(Internal.Modality.State.Connecting);
                        options = options || {};
                        container = options.container;
                        if (!isConferencing()) {
                            to = to || options.to;
                            if (!to) {
                                // find some remote participant
                                participants.each(function (p) {
                                    if (!p.local())
                                        to = p.uri();
                                });
                            }
                            check(to, 'the remote participant URI is not specified');
                        }
                        shareable = options.window || options.monitor;
                        return initMedia().then(function () {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                                prepareAppSharing(shareable ? 2 /* Sharer */ : 1 /* Viewer */);
                                // expect an OFFER_READY event from the media plugin
                                assert(!dfdStart);
                                dfdStart = Task('awaiting an OFFER_READY event from the media plugin');
                                return dfdStart.promise;
                            }).then(null, function (error) {
                                if (asInvitation && asInvitation.hasLink('cancel') &&
                                    (asInvitation.get('state', '') == 'Connecting' || asInvitation.get('state', '') == 'Alerting'))
                                    ucwa.send('POST', asInvitation.link('cancel').href, { nobatch: true });
                                state(Internal.Modality.State.Disconnected, error);
                                throw error;
                            });
                        });
                    });
                    //#endregion
                    //#region cleanup
                    function cleanup() {
                        ucwa.event.off(onServerEvent);
                        if (appSharing) {
                            appSharing.event.off(onPluginComponentEvent);
                            if (shareable)
                                sharedResources.setShared(shareable.id(), false);
                            appSharing.disposeSharer();
                            // TODO: See if this makes the most sense for cleanup of old plugin / loading of new...
                            sharedResources.uninit();
                        }
                        if (pcASUI) {
                            appSharing.disposeViewer();
                            pcASUI.event.off(onViewerEvent);
                            pcASUI.unload();
                        }
                        pcASUI = null;
                        mediaPlugin.uninitAppSharing().then(function () {
                            appSharing = null;
                            return sharedResources.init();
                        });
                    }
                    //#endregion
                    //#region stop
                    defineAsyncCommand('stop', [Internal.Modality.State.Connected], function () {
                        cleanup();
                        return ucwa.send('GET', asInvitation.link('applicationSharing').href).then(function (rAS) {
                            return ucwa.send('POST', rAS.link('stopScreenSharing').href);
                        }).then(function () {
                            state(Internal.Modality.State.Disconnected);
                            asInvitation = null;
                            asSession = null;
                        });
                    });
                    //#endregion
                    //#region accept
                    /**
                     * Accepts an incoming app-sharing invitation.
                     *
                     * If the AS modality was created to handle a applicationSharingInvitation event,
                     * the accept method will configure the media plugin and connect it with
                     * the remote party via UCWA.
                     *
                     * Under the hood the accept method does the following:
                     *
                     *      - Get an AppSharingComponent from the media plugin.
                     *      - Attaches an event handle for plugin events.
                     *      - Create an AppSharingViewerComponent with the media plugin.
                     *      - Invokes AppSharingViewerComponent::CreateAppShareViewerUI.
                     *      - Invokes AppSharingViewerComponent::GetViewerWindow.
                     *      - Invokes AppSharingComponent::SetCallConfig.
                     *      - Invokes AppSharingComponent::InitializeViewer.
                     *      - Invokes AppSharingComponent::ConnectViewer.
                     *      - Invokes AppSharingComponent::SetOffer with the SDPs received from the remote party.
                     *      - Invokes AppSharingComponent::PublishFullScreenState.
                     *      - Handles the ANSWER_READY event from the media plugin: the event contains an SDP.
                     *      - Sends a POST applicationSharingInvitation/acceptWithAnswer with the SDP from the media plugin.
                     *      - Receives an "applicationSharinginvitation completed" event from UCWA
                     *      - Receives an "applicationSharingRenegotiation started" event with a new SDP from the remote party.
                     *      - Invokes AppSharingComponent::SetOffer with the new SDP given in the renegotiation event.
                     *      - Handles another ANSWER_READY event from the media plugin with an SDP answer.
                     *      - Sends a POST applicationSharingRenegotiation/answer with the SDP answer.
                     *      - Receives a "applicationSharingRenegotiation completed" event from UCWA.
                     *      - Invokes AppSharingComponent::CompleteNegotiation
                     *
                     * @returns {Promise}
                     *
                     *      This promise gets resolved after the POST request to applicationSharingInvitation/acceptWithAnswer
                     *      succeeds. The renegotiation is considered to be optional and its progress is not tracked
                     *      by the promise returned from the accept method.
                     */
                    defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (options) {
                        assert(options && options.container);
                        state(Internal.Modality.State.Connecting);
                        container = options.container;
                        return initMedia().then(function () {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                                return prepareAppSharing(1 /* Viewer */).then(function () {
                                    // expect the ANSWER_READY event from the plugin after this call
                                    setOffer(invitation.offers);
                                });
                            });
                        }).then(function () {
                            assert(!dfdAccept);
                            dfdAccept = Task();
                            dfdAccept.status('awaiting an ANSWER_READY event from the media plugin');
                            return dfdAccept.promise;
                        }).then(null, function (error) {
                            state(Internal.Modality.State.Disconnected, error);
                            cleanup();
                            throw error;
                        });
                    });
                    //#endregion
                    //#region changeShared
                    /**
                     * Changes the shared content and/or presentation role in the conversation.  Presentation roles can switch
                     * depending on what is currently active in the conversation and if the optional shareable resource was
                     * provided.
                     *
                     * @param {ShareableWindow|ShareableMonitor} resource - resource to be shared (not required)
                     *
                     * @returns {Promise}
                     */
                    function changeShared(resource) {
                        check.state(state(), Internal.Modality.State.Connected);
                        function sharing() {
                            if (!isConferencing()) {
                                appSharing.setCallConfig();
                                appSharing.setMediaConfig(3 /* BOTH */, 2 /* Sharer */);
                            }
                            appSharing.disposeViewer();
                            pcASUI.event.off(onViewerEvent);
                            pcASUI.unload();
                            pcASUI = null;
                            if (isConferencing()) {
                                return mediaPlugin.uninitAppSharing().then(function () {
                                    appSharing = null;
                                    sharedResources.uninit();
                                }).then(function () {
                                    shareable = resource;
                                    return prepareAppSharing(2 /* Sharer */);
                                });
                            }
                            else {
                                sharedResources.setShared(resource.id(), true);
                                shareable = resource;
                            }
                        }
                        function viewing() {
                            appSharing.disposeSharer();
                            return mediaPlugin.uninitAppSharing().then(function () {
                                appSharing = null;
                                sharedResources.uninit();
                            }).then(function () {
                                return prepareAppSharing(1 /* Viewer */);
                            });
                        }
                        if (shareable) {
                            sharedResources.setShared(shareable.id(), false);
                        }
                        if (pcASUI) {
                            return sharing();
                        }
                        else if (resource) {
                            sharedResources.setShared(resource.id(), true);
                            shareable = resource;
                        }
                        else {
                            return viewing();
                        }
                    }
                    //#endregion
                    //#region decline
                    defineAsyncCommand('decline', [Internal.Modality.State.Notified], function () {
                        return invitation.decline().then(function () {
                            state(Internal.Modality.State.Disconnected);
                        });
                    });
                    //#endregion
                    //#region setOffer
                    /**
                     * Invokes appSharing.setOffer(...) with the given set of SDPs,
                     * e.g. pcAS.invoke("SetOffer", false, 2, sdp1, id1, sdp2, id2).
                     *
                     * @param {Object[]} offers
                     * @returns Whatever pcAS returns.
                     */
                    function setOffer(offers) {
                        assert(offers.length >= 0);
                        var i, offer, args = [false, offers.length];
                        for (i = 0; i < offers.length; i++) {
                            offer = offers[i];
                            assert('sdp' in offer);
                            assert('id' in offer);
                            args.push(offer.sdp);
                            args.push(offer.id);
                        }
                        appSharing.setOffer.apply(appSharing, args);
                    }
                    //#endregion
                    //#region setFinalAnswer
                    /**
                     * Sets the final SDP answer from the remote party
                     */
                    function setFinalAnswer(resource, remoteEndpoint) {
                        var mediaAnswer = resource.relatedHref('mediaAnswer'), sdp = DataUri(mediaAnswer).data;
                        log('Final answer from the remote party:\n' + sdp);
                        appSharing.setFinalAnswer(remoteEndpoint, sdp);
                    }
                    //#endregion
                    //#region completeNegotiation
                    function completeNegotiation(eventStatus) {
                        // TODO: this is entirely my fantasy - figure out what are other values
                        // that ucwa can return here
                        var statusCode = (eventStatus == 'Success') ?
                            MediaEnum.NegotiationStatus.NS_SUCCESS :
                            MediaEnum.NegotiationStatus.NS_LOCAL_INTERNAL_ERROR;
                        appSharing.completeNegotiation(statusCode);
                    }
                    //#endregion
                    //#region getStartScreenSharingUri
                    /**
                     * The first SDP offer is sent to a URI given by this function.
                     */
                    function getStartScreenSharingUri() {
                        // if the AS modality is the 1-st modality in the conversation,
                        // send a request to the global startScreenSharing link
                        if (!rConversation)
                            return { rel: 'startScreenSharing' };
                        // if the AS modality gets added to an existing conversation,
                        // send the request to its addScreenSharing link
                        var link = rConversation.link('applicationSharing');
                        return ucwa.send('GET', link.href).then(function (rAS) {
                            return rAS.link('addScreenSharing').href;
                        });
                    }
                    //#endregion
                    //#region sendOffer
                    /**
                     * Composes an SDP offer from the OFFER_READY media plugin event data and
                     * sends it to the server to start an AS session.
                     */
                    function sendOffer(offers) {
                        assert(offers.length > 0);
                        // for now it takes only one SDP offer from all offers given by the media plugin
                        var mediaOffer = 'data:application/sdp;charset=utf-8,' +
                            DataUri.encodeData(offers[0].sdp);
                        return async(getStartScreenSharingUri).call().then(function (uri) {
                            var dfdPost, dfdCompleted, operationId = guid(), data;
                            if (isConferencing()) {
                                data = {
                                    operationId: operationId,
                                    threadId: threadId,
                                    mediaOffer: mediaOffer
                                };
                            }
                            else {
                                data = {
                                    to: to,
                                    operationId: operationId,
                                    sessionContext: guid(),
                                    threadId: threadId,
                                    mediaOffer: mediaOffer
                                };
                            }
                            dfdPost = ucwa.send('POST', uri, {
                                data: data
                            }).then(function (r) {
                                asInvitation = r;
                            });
                            // wait for the "applicationSharingInvitation completed" event that corresponds to the given conversation
                            dfdCompleted = ucwa.wait({
                                type: 'completed',
                                target: { rel: 'applicationSharingInvitation' },
                                resource: function (r) {
                                    return r.get('direction') == 'Outgoing' && (r.get('threadId') == threadId || r.get('operationId') == operationId);
                                }
                            }).then(function (event) {
                                if (event.status == 'Failure')
                                    throw Internal.EInvitationFailed(event.reason);
                                completeNegotiation(event.status);
                            });
                            return Task.waitAll([dfdPost, dfdCompleted]);
                        });
                    }
                    //#endregion
                    //#region sendRenegotiationOffer
                    /**
                     * Composes an SDP offer from the OFFER_READY media plugin event data and
                     * sends it to the server to renegotiate the AV session.
                     */
                    function sendRenegotiationOffer(sdp) {
                        var url = asSession.relatedHref('renegotiations');
                        assert(url, '"renegotiations" link is missing');
                        // cache operation id
                        var operationId = guid();
                        outAsRenegoOpIds[operationId] = "";
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { operationId: operationId },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    //#endregion
                    return self;
                }
                Internal.AppSharingModality = AppSharingModality;
                //#endregion
                //#region AppSharingInvitation
                /**
                 * This model represents a applicationSharingInvitation resource.
                 *
                 * @param {Resource} resource - A resource with rel=applicationSharingInvitation.
                 * @param {Function} createParticipant - Takes a rel=participant resource and creates a Participant model.
                 * @param {UCWA} ucwa
                 *
                 * @member {Participant} from
                 * @member {Object[]} offers - An array of media offers.
                 *
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @method {Promise} decline
                 * @method {Promise} acceptWithAnswer(sdp)
                 *
                 */
                function AppSharingInvitation(options) {
                    var resource = options.resource;
                    var createParticipant = options.createParticipant;
                    var ucwa = options.ucwa;
                    check.equals(resource.rel, 'applicationSharingInvitation');
                    /*  An applicationSharingInvitation resource may have the following form:
            
                        {
                            "rel": "applicationSharingInvitation",
                            "direction": "Incoming",
                            "importance": "Normal",
                            "threadId": "...",
                            "state": "Connecting",
                            "operationId": "...",
                            "telemetryId": "...",
                            "sessionContext": "...",
                            "_links": {
                                "self": ...,
                                "from": ...,
                                "cancel": ...,
                                "conversation": ...,
                                "applicationSharing": ...
                            }
                        }
                    */
                    var self = {
                        acceptWithAnswer: async(acceptWithAnswer),
                        decline: async(decline),
                        offers: getMediaOffers(),
                        from: getSender()
                    };
                    extend(self, resource.properties);
                    // if the server has not provided the sessionContext of
                    // the app sharing invitation, generate some unique value
                    self.sessionContext = self.sessionContext || guid();
                    /**
                     * Reads the "mediaOffer" link and converts it to a collection SDPs.
                     */
                    function getMediaOffers() {
                        /* The "mediaOffer" link may have the following form:
                         *
                         *  data:multipart/alternative;charset=utf-8;boundary=e47d80f2,
                         *  --e47d80f2
                         *  Content-Type:+application/sdp
                         *  Content-ID:+<9544aa8a8ac9dfe08fad74893bd1095e@contoso.com>
                         *  Content-Disposition:+session;+handling=optional;+proxy-fallback
                         *
                         *  v=0
                         *  o=-+0+0+IN+IP4+127.0.0.1
                         *  s=session
                         *  ...
                         *
                         *  --e47d80f2
                         *  Content-Type:+application/sdp
                         *  Content-ID:+<cdfd6188fd977372c577873b03dd580d@contoso.com>
                         *  Content-Disposition:+session;+handling=optional
                         *
                         *  v=0
                         *  o=-+0+1+IN+IP4+127.0.0.1
                         *  s=session
                         *  c=IN+IP4+127.0.0.1
                         *  ...
                         *
                         *  --e47d80f2
                         */
                        var href, dataUri, responses;
                        href = resource.relatedHref('mediaOffer');
                        if (!href)
                            return [];
                        dataUri = DataUri(href);
                        try {
                            responses = parseMultipartRelatedResponse({
                                responseText: dataUri.data,
                                headers: 'Content-Type:multipart/related;boundary=' + dataUri.attributes.boundary
                            });
                            return map(responses, function (response) {
                                var headers = HttpHeaders(response.headers);
                                return {
                                    sdp: response.responseText,
                                    id: headers.get('Content-ID')
                                };
                            });
                        }
                        catch (error) {
                            // if the media offer is not a multipart/alternate-encoded
                            // set of SDPs, consider it as a single SDP
                            return [{
                                    sdp: dataUri.data,
                                    id: ''
                                }];
                        }
                    }
                    function getSender() {
                        var href = resource.relatedHref('from');
                        return href && createParticipant(resource.embedded[href]);
                    }
                    function acceptWithAnswer(sdp) {
                        var url = resource.link('acceptWithAnswer').href;
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { sessionContext: self.sessionContext },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    function decline() {
                        return ucwa.send('POST', resource.link('decline').href, {
                            data: { reason: 'Local' }
                        });
                    }
                    return self;
                }
                Internal.AppSharingInvitation = AppSharingInvitation;
                //#endregion
                //#region MediaPlugin
                /**
                 * Encapsulates media plugin functionality.
                 * The AV modality takes a reference to this object and
                 * uses it to communicate with the media plugin.
                 * Unit tests create a mock of this object.
                 *
                 * @param {UCWA} ucwa
                 *
                 * @method {async MediaConfig} getMediaConfig
                 * @method {Promise} initMedia
                 * @method {Promise} uninitMedia
                 * @method {PluginComponent} createComponent
                 */
                function MediaPlugin(ucwa) {
                    var mediaConfig, appSharing, self;
                    function getMediaConfig() {
                        return mediaConfig ||
                            initMedia().then(function () {
                                return ucwa.init();
                            }).then(function () {
                                mediaConfig = MediaConfig({
                                    ucwa: ucwa,
                                    mediaPlugin: self
                                });
                                return mediaConfig.init();
                            }).then(function () {
                                return mediaConfig;
                            });
                    }
                    function getAppSharing(language) {
                        return appSharing ||
                            initMedia(language).then(getMediaConfig).then(function () {
                                appSharing = AppSharing({
                                    mediaConfig: mediaConfig,
                                    component: createComponent({
                                        type: 'AppShareCore',
                                        hide: true,
                                        inproc: false
                                    })
                                });
                                return appSharing.init();
                            }).then(function () {
                                return appSharing;
                            });
                    }
                    function initMedia(language) {
                        if (language === void 0) { language = 'en-us'; }
                        check(PluginManager, 'NoMedia');
                        //TODO: deduce rtl from language
                        var rtl = false;
                        return PluginManager().init({
                            language: language,
                            rtl: rtl
                        });
                    }
                    function uninitMedia() {
                        if (mediaConfig) {
                            mediaConfig.uninit();
                            mediaConfig = null;
                        }
                        return PluginManager().uninit();
                    }
                    function uninitAppSharing() {
                        if (appSharing) {
                            appSharing.uninit();
                            appSharing = null;
                        }
                    }
                    function createComponent(options) {
                        return PluginManager().createComponent(options);
                    }
                    self = {
                        getMediaConfig: async(getMediaConfig),
                        getAppSharing: async(getAppSharing),
                        initMedia: async(initMedia),
                        uninitMedia: async(uninitMedia),
                        uninitAppSharing: async(uninitAppSharing),
                        createComponent: createComponent
                    };
                    return self;
                }
                Internal.MediaPlugin = MediaPlugin;
                //#endregion
                //#region MediaConfig
                /**
                 * Media configuration model.
                 *
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 *
                 * @method {Promise} init - initialized media configuration
                 * @method uninit - uninitializes media configuration
                 * @method {Boolean} isInternal - indicates whether this client is signed in on the internal or external network
                 * @method {MediaEnum.SecurityLevel} audioVideoSecurityLevel - returns audio/video security level
                 * @method {MediaEnum.SecurityLevel}applicationSharingSecurityLevel - returns app sharing security level
                 * @method {Number} maxVideoChannelCount - returns the max number of video channels
                 * @method  setDefaultDevices - sets default media devices
                 * @property {MediaConfig.ProxyDetection} proxyDetection - proxy detection state
                 *
                 */
                function MediaConfig(options) {
                    var ucwa = options.ucwa, mediaPlugin = options.mediaPlugin, isInternal = !!ucwa.get({ rel: 'root' }).get('internal'), pcMediaConfig, proxyDetection = Property({ value: MediaConfig.ProxyDetection.None }), proxies = {}, EnforcementPolicy = StringEnum('Enforced', 'Supported', 'NotSupported');
                    options = null;
                    /**
                     * Initializes media configuration by loading MediaPlatformConfig plugin component,
                     * fetching media config from UCWA server and passing it to the plugin component
                     */
                    function init() {
                        pcMediaConfig = mediaPlugin.createComponent({
                            type: 'MediaPlatformConfig',
                            hide: true,
                            inproc: false
                        });
                        pcMediaConfig.event(onPluginComponentEvent);
                        pcMediaConfig.state.changed(function (state) {
                            log('pcMediaConfig.state = ' + state);
                        });
                        var p = pcMediaConfig.load().then(getMediaConfig).then(setMediaConfig).then(null, function (error) {
                            log('MediaConfig::init rejected');
                            uninit();
                            throw error;
                        });
                        return p;
                    }
                    /**
                     * Uninitializes media configuration
                     */
                    function uninit() {
                        if (pcMediaConfig) {
                            pcMediaConfig.event.off(onPluginComponentEvent);
                            pcMediaConfig = null;
                        }
                    }
                    /**
                     * MediaPlatformConfig component event listener
                     */
                    function onPluginComponentEvent(ev) {
                        if (ev.type == 'ProxyDetectionCompleted') {
                            // args0 (string) - the host name, args1 (boolean) - was the proxy detected or not
                            proxies[ev.args[0]] = (ev.args[1] == 'true') ?
                                MediaConfig.ProxyDetection.Succeeded :
                                MediaConfig.ProxyDetection.Failed;
                            // we signal that proxy detection is completed once we received the plugin event
                            // for all tested proxies.
                            var done = true, res = MediaConfig.ProxyDetection.Failed;
                            for (var p in proxies) {
                                switch (p) {
                                    case MediaConfig.ProxyDetection.None:
                                    case MediaConfig.ProxyDetection.Started:
                                        done = false;
                                        break;
                                    case MediaConfig.ProxyDetection.Succeeded:
                                        res = MediaConfig.ProxyDetection.Succeeded;
                                        break;
                                }
                            }
                            if (done)
                                proxyDetection(res);
                        }
                    }
                    /**
                     * Fetches media configuration from UCWA server
                     */
                    function getMediaConfig() {
                        return Task.waitAll([
                            ucwa.send('GET', { rel: 'mediaPolicies' }),
                            ucwa.send('GET', { rel: 'mediaRelayAccessToken' })
                        ]);
                    }
                    /**
                     * Set media configuration in the plugin
                     */
                    function setMediaConfig() {
                        var comm = ucwa.get({ rel: 'communication' }), mras = ucwa.get(comm.link('mediaRelayAccessToken').href), mp = ucwa.get(comm.link('mediaPolicies').href), res;
                        if (mp.properties.portRange == 'Enabled') {
                            res = pcMediaConfig.invoke('SetPortRanges', mp.properties['minimumAudioPort'], mp.properties['maximumAudioPort'], mp.properties['minimumVideoPort'], mp.properties['maximumVideoPort'], mp.properties['minimumApplicationSharingPort'], mp.properties['maximumApplicationSharingPort']);
                        }
                        res = pcMediaConfig.invoke('SetMediaPlatformConfig', mp.properties['qualityOfService'] == 'Enabled', isInternal);
                        res = pcMediaConfig.invoke('SetMediaSettings', true, true, parseInt(mp.properties['audioBitRate']) || -1, parseInt(mp.properties['videoBitRate']) || -1, parseInt(mp.properties['applicationSharingBitRate']) || -1, -1, parseInt(mp.properties['totalReceivedVideoBitRateKB']) || -1, mp.properties['fipsCompliantMedia'] == 'Required');
                        //TODO: param from some user options ??
                        res = pcMediaConfig.invoke('SetStereoAudioRendering', false);
                        var username = mras.properties['userName'];
                        var password = mras.properties['password'];
                        var mr, tcpPort, udpPort, hostName, realm = '*';
                        for (var i = 0, len = mras.related.mediaRelay.length; i < len; i++) {
                            mr = ucwa.get(mras.related.mediaRelay[i].href);
                            if ((isInternal && mr.properties['location'] == 'Internet') ||
                                (!isInternal && mr.properties['location'] == 'Intranet'))
                                continue;
                            hostName = mr.properties['host'];
                            tcpPort = mr.properties['tcpPort'] || -1;
                            udpPort = mr.properties['udpPort'] || -1;
                            res = pcMediaConfig.invoke('AddProxyServer', hostName);
                            proxies[hostName] = MediaConfig.ProxyDetection.Started;
                            if (proxyDetection() == MediaConfig.ProxyDetection.None)
                                proxyDetection(MediaConfig.ProxyDetection.Started);
                            if (udpPort != -1) {
                                try {
                                    res = pcMediaConfig.invoke('AddIceServer', 1 /* TurnUDP */, hostName, udpPort, username, realm, password);
                                }
                                catch (err) {
                                    log(err.message + ' : UDP ' + hostName + ':' + udpPort);
                                }
                            }
                            if (tcpPort != -1) {
                                try {
                                    res = pcMediaConfig.invoke('AddIceServer', 2 /* TurnTCP */, hostName, tcpPort, username, realm, password);
                                }
                                catch (err) {
                                    log(err.message + ' : TCP ' + hostName + ':' + tcpPort);
                                }
                            }
                        }
                    }
                    /**
                     * Sets default audio and video devices
                     */
                    function setDefaultDevices() {
                        assert(pcMediaConfig);
                        pcMediaConfig.invoke('SetDefaultDevices');
                    }
                    /**
                     * Returns AV security level
                     */
                    function getAudioVideoSecurityLevel() {
                        var comm = ucwa.get({ rel: 'communication' }), mp = ucwa.get(comm.link('mediaPolicies').href), encr, level;
                        if (mp) {
                            encr = mp.properties['audioVideoEncryption'];
                            switch (encr) {
                                case EnforcementPolicy.Enforced:
                                    level = 3 /* Required */;
                                    break;
                                case void 0:
                                // anonymous user will not get this media policy from the
                                // server - when undefined we default to 'Supported'.
                                case EnforcementPolicy.Supported:
                                    level = 2 /* Supported */;
                                    break;
                                case EnforcementPolicy.NotSupported:
                                    level = 1 /* Unsupported */;
                                    break;
                                default:
                                    throw EWrongType(encr, 'EnforcementPolicy');
                            }
                        }
                        return level;
                    }
                    /**
                     * Returns AS security level
                     */
                    function getApplicationSharingSecurityLevel() {
                        var comm = ucwa.get({ rel: 'communication' }), mp = ucwa.get(comm.link('mediaPolicies').href), encr, level;
                        if (mp) {
                            encr = mp.properties['applicationSharingEncryption'];
                            switch (encr) {
                                case EnforcementPolicy.Enforced:
                                    level = 3 /* Required */;
                                    break;
                                case void 0:
                                // anonymous user will not get this media policy from the
                                // server - when undefined we default to 'Supported'.
                                case EnforcementPolicy.Supported:
                                    level = 2 /* Supported */;
                                    break;
                                case EnforcementPolicy.NotSupported:
                                    level = 1 /* Unsupported */;
                                    break;
                                default:
                                    throw EWrongType(encr, 'EnforcementPolicy');
                            }
                        }
                        return level;
                    }
                    /**
                     * Returns the number of video channels
                     */
                    function getMaxVideoChannelCount() {
                        var res = pcMediaConfig.invoke('GetMaxVideoChannelCount');
                        return res[1];
                    }
                    return {
                        init: async(init),
                        uninit: uninit,
                        isInternal: function () { return isInternal; },
                        audioVideoSecurityLevel: getAudioVideoSecurityLevel,
                        applicationSharingSecurityLevel: getApplicationSharingSecurityLevel,
                        maxVideoChannelCount: getMaxVideoChannelCount,
                        proxyDetection: proxyDetection.asReadOnly(),
                        setDefaultDevices: setDefaultDevices
                    };
                }
                Internal.MediaConfig = MediaConfig;
                var MediaConfig;
                (function (MediaConfig) {
                    ;
                    MediaConfig.ProxyDetection = StringEnum('None', 'Started', 'Succeeded', 'Failed');
                })(MediaConfig = Internal.MediaConfig || (Internal.MediaConfig = {}));
                //#endregion MediaConfig
                //#region VideoChannel
                /**
                 * VideoChannel model.
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {Number|Function} channelId (either a value or a function that returns the channel id)
                 * @param {Property<MediaEnum.ChannelState>} state - RW property that holds the channel state
                 * @param {Property<HTMLElement>} [container] - RW property that holds the parent DOM element of
                 *    a video window for this channel
                 *
                 * @property {HTMLElement} container -  the parent DOM element of a video window for this channel
                 * @property {Number} channelId - channel id.
                 * @property {MediaEnum.ChannelState} state - channel state (Inactive, Active)
                 * @property {BigInt} videoWindow - RO property, the handle of the video window rendering the remote party video
                 * @property {PluginComponent.State} videoWindowState - video window state
                 * @method {Promise} createVideoWindow - creates a video window rendering the remote party video
                 * @method {Promise} destroyVideoWindow - destroys the video window rendering the remote party video
                 * @method resizeVideoWindow - resizes the video window so that it fits the parent DOM element
                 *
                 * @event resized - occurs when the video window is resized.
                 *
                 * @remark
                 * UI can listen to channel state changes. When channel becomes active UI can call container(parent)
                 * to set the parent DOM element for the video window of this channel, for example:
                 *
                 *   videoChannel.state.changed(function (state) {
                 *       if (state == 'Active') {
                 *           videoChannel.container(document.getElementById("myVideoWindow"));
                 *       }
                 *   });
                 *
                 * Alternatively, UI can set the video channel container ad-hoc to display the video window, and
                 * set it to null to remove the video window.
                 *
                 */
                function LocalVideoChannel(options) {
                    var id = options.channelId, container = options.container || Property(), 
                    // dom element that will host the video window
                    windowState = Property({ value: PluginComponent.State.Unloaded }), 
                    // video window state
                    resized = Event(), pcVideoUI = null, hRenderWindow = null; // render window handle (as BigInt)
                    /**
                     * Get/Set channel id
                     */
                    function channelId(cid) {
                        if (arguments.length == 0) {
                            return id;
                        }
                        else {
                            id = cid;
                            return this;
                        }
                    }
                    /**
                     *  Creates a video window to render incoming video and places it in the parent DOM element
                     *  @param {HTMLElement} [parent] - the parent DOM element
                     */
                    function createVideoWindow(parent) {
                        assert(!pcVideoUI);
                        parent = parent || container();
                        assert(parent);
                        pcVideoUI = options.mediaPlugin.createComponent({
                            type: 'VideoUI',
                            hide: false,
                            inproc: true
                        });
                        pcVideoUI.state.changed(onPluginComponentState);
                        pcVideoUI.event(onPluginComponentEvent, 'async');
                        pcVideoUI.setContainer(parent);
                        return pcVideoUI.load().then(function () {
                            pcVideoUI.invoke('CreateVideoUI', false); // false == no preview window
                            hRenderWindow = getWindow('GetRenderWindow');
                        });
                    }
                    /**
                     *  Destroys the video window
                     */
                    function destroyVideoWindow() {
                        if (pcVideoUI) {
                            pcVideoUI.invoke('DestroyVideoWindows');
                            pcVideoUI.unload();
                            pcVideoUI.event.off(onPluginComponentEvent);
                            pcVideoUI.state.changed.off(onPluginComponentState);
                            windowState(PluginComponent.State.Unloaded);
                            pcVideoUI = null;
                            hRenderWindow = null;
                        }
                    }
                    /**
                     * VideoUI component event listener - re-fires 'video size changed' event upon receiving
                     * it from the plugin component
                     */
                    function onPluginComponentEvent(ev) {
                        if (ev.type == 'VIDEO_SIZE_CHANGED') {
                            resized.fire({
                                width: ev.args[0],
                                height: ev.args[1]
                            });
                        }
                    }
                    /**
                     * Returns the window for rendering incoming video
                     */
                    function videoWindow() {
                        return hRenderWindow = hRenderWindow || getWindow('GetRenderWindow'); // jshint ignore:line
                    }
                    function getWindow(method) {
                        assert(method == 'GetRenderWindow');
                        if (pcVideoUI) {
                            var res = pcVideoUI.invoke(method);
                            if (res.succeeded)
                                return res[1];
                        }
                        return null;
                    }
                    /**
                     * Resizes the video window so that it fits the parent DOM element
                     *  @param {HTMLElement} [parent] - the parent DOM element
                     */
                    function resizeVideoWindow(parent) {
                        parent = parent || container();
                        assert(parent);
                        pcVideoUI.invoke('ResizeWindow', parent.clientWidth, parent.clientHeight);
                    }
                    function onPluginComponentState(state) {
                        log('Video channel ' + id + ' ' + pcVideoUI.id() + ' pcVideoUI.state = ' + state);
                        // in destroyVideoWindow() we unsubscribe from the plugin component events right after
                        // we called unload(), so the last component state we see is Unloading. We make it
                        // the Unloaded state to enable the single check for the uninitialized (Unloaded) state
                        if (state == PluginComponent.State.Unloading)
                            state = PluginComponent.State.Unloaded;
                        windowState(state);
                    }
                    return {
                        container: container,
                        state: options.state.asReadOnly(),
                        channelId: channelId,
                        createVideoWindow: async(createVideoWindow),
                        destroyVideoWindow: destroyVideoWindow,
                        videoWindow: videoWindow,
                        resizeVideoWindow: resizeVideoWindow,
                        videoWindowState: windowState.asReadOnly(),
                        resized: resized.observer,
                        public: Model({
                            container: container,
                            state: options.state.asReadOnly()
                        })
                    };
                }
                //#endregion VideoChannel
                //TODO: rewrite local video preview using VideoChannel3 and remove VideoChannel()
                //#region VideoChannel3
                /**
                 * Video channel - represents a unidirectional video channel.
                 *
                 * @param {String} [name] - channel name (for logging)
                 *
                 * @property {Property<Boolean>} isStarted
                 * @property {Property<Boolean>} isOnHold
                 * @member   {MediaStream} stream
                 *
                 */
                function VideoChannel(options) {
                    options = options || {};
                    var name = options.name, isStarted = Property(), isOnHold = Property(), streamEmpty = MediaStream(), stream = SourcedModel(streamEmpty), self;
                    stream.setSource(streamEmpty);
                    stream.state.changed(function (newState, reason, oldState) {
                        log('VideoChannel ' + name + ' (' +
                            '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    self = Model({
                        camera: Property({ value: 'unknown' }).asReadOnly(),
                        stream: stream,
                        isStarted: isStarted,
                        isOnHold: isOnHold
                    });
                    return self;
                }
                Internal.VideoChannel = VideoChannel;
                //#endregion VideoChannel3
                //#region MediaStream
                /**
                 * MediaStream - represents the video stream
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {Number} [channelId] media plugin channel id
                 * //TODO: add this param to get rid of isPreview in show/removeVideo
                 * @param {MediaEnum.StreamType} - stream type (Preview, MainRender, Render)
                 *
                 * @property {Property<Media.State>} state
                 * @property {Property<uint>} width
                 * @property {Property<uint>} height
                 * @member {MediaSource} source
                 *
                 */
                function MediaStream(options) {
                    if (options === void 0) { options = {}; }
                    var state = Property({ value: MediaEnum.StreamState.Stopped }), source = Model({
                        sink: VideoSink(options)
                    }), width = Property({ value: 0 }), height = Property({ value: 0 }), 
                    // is media flowing
                    isFlowing = BoolProperty(false), 
                    // media manager channel id
                    id = Property({ value: options.id }), 
                    // is this stream attached to a participant video source
                    isAttached = Property({ value: false });
                    var self = Model({
                        state: state.asReadOnly(),
                        source: source,
                        width: width.asReadOnly(),
                        height: height.asReadOnly(),
                        _id: id,
                        _isAttached: isAttached
                    });
                    setHiddenProperty(self, '_state', state);
                    setHiddenProperty(self, '_isFlowing', isFlowing);
                    state.changed(function (newState, reason, oldState) {
                        log('MediaStream (' + id() + '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    return self;
                }
                Internal.MediaStream = MediaStream;
                //#endregion MediaStream
                //#region VideoSink
                /**
                 * Represents a video window used to render a video stream in a parent DOM element
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {HTMLElement} [container] - a parent DOM element
                 *
                 * @command _init - Creates a video window and places it in the parent DOM element
                 * @command _unint - Destroys the rendering video window
                 * @command _resize - Resizes the video window so that it fits the parent DOM element
                 *
                 * @property _videoWindow - Returns the video window handle
                 * @property container - Gets/sets the parent DOM element hosting the native wideo window
                 * @property _state - The state of the plugin component that creates the native video window.
                 * @property _size - video container size.
                 *
                 */
                function VideoSink(options) {
                    options = options || {};
                    var mediaPlugin = options.mediaPlugin, 
                    // video window plugin component state
                    pcState = Property({ value: PluginComponent.State.Unloaded }), 
                    // the DOM element that will host the video window
                    container = Property({
                        value: options.container,
                        set: Command(function (val) {
                            return val;
                        }, pcState.equalsAny(PluginComponent.State.Unloaded, PluginComponent.State.Loaded))
                    }), videoFormat = Property({
                        value: MediaEnum.VideoFormat.Crop,
                        check: function (v) {
                            if (!(v in MediaEnum.VideoFormat))
                                throw EInvalidArgument('format', '`format` value is Fit, Crop or Stretch.');
                        }
                    }), windowSize = Property({ value: {} }), hRenderWindow = Property(), pcVideoUI = null, self;
                    options = null;
                    //#region semi-public methods
                    // converts API video format enum to the plugin enum
                    function enumcastVideoFormat(vf) {
                        // match keys are MediaEnum.VideoFormat values
                        return {
                            Fit: 0 /* LetterBoxing */,
                            Crop: 1 /* Cropping */,
                            Stretch: 2 /* Stretch */
                        }[vf];
                    }
                    // Creates a video window to render incoming video and places it in the parent DOM element
                    function createVideoWindow() {
                        assert(!pcVideoUI);
                        assert(container());
                        pcVideoUI = mediaPlugin.createComponent({
                            type: 'VideoUI',
                            hide: false,
                            inproc: true
                        });
                        pcVideoUI.state.changed(onPluginComponentState);
                        pcVideoUI.event(onPluginComponentEvent, 'async');
                        pcVideoUI.setContainer(container());
                        return pcVideoUI.load().then(function () {
                            var res;
                            pcVideoUI.invoke('CreateVideoUI', false); // false == no preview window
                            res = pcVideoUI.invoke('GetRenderWindow');
                            hRenderWindow(res[1]);
                        });
                    }
                    // Destroys the rendering video window thus returning the sink to the uninitialied state
                    function destroyVideoWindow() {
                        if (pcVideoUI) {
                            pcVideoUI.invoke('DestroyVideoWindows');
                            pcVideoUI.unload();
                            pcVideoUI.event.off(onPluginComponentEvent);
                            pcVideoUI.state.changed.off(onPluginComponentState);
                            pcState(PluginComponent.State.Unloaded);
                            pcVideoUI = null;
                            hRenderWindow(null);
                        }
                    }
                    // Resizes the video window so that it fits the parent DOM element
                    function resizeVideoWindow() {
                        assert(container());
                        pcVideoUI.invoke('ResizeWindow', container().clientWidth, container().clientHeight);
                    }
                    //#endregion
                    //#region plugin event handlers
                    function onPluginComponentEvent(ev) {
                        if (ev.type == 'VIDEO_SIZE_CHANGED') {
                            windowSize({
                                width: ev.args[0],
                                height: ev.args[1]
                            });
                        }
                    }
                    function onPluginComponentState(state) {
                        log('Video sink ' + pcVideoUI.id() + ' pcVideoUI.state = ' + state);
                        // in destroyVideoWindow() we unsubscribe from the plugin component events right after
                        // we called unload(), so the last component state we see is Unloading. We make it
                        // the Unloaded state to enable the single check for the uninitialized (Unloaded) state
                        if (state == PluginComponent.State.Unloading)
                            state = PluginComponent.State.Unloaded;
                        pcState(state);
                    }
                    //#endregion
                    self = Model({
                        container: container,
                        format: videoFormat,
                        _format: videoFormat.map(enumcastVideoFormat),
                        _init: EnabledCommand(async(createVideoWindow)),
                        _uninit: EnabledCommand(destroyVideoWindow),
                        _resize: EnabledCommand(resizeVideoWindow),
                        _videoWindow: hRenderWindow.asReadOnly(),
                        _state: pcState.asReadOnly(),
                        _size: windowSize.asReadOnly(),
                        _s: Property({ value: null }),
                        _c: Property({ value: null }) // a placeholder for container subscription
                    });
                    return self;
                }
                //#endregion VideoSink
                //#region Devices
                /**
                 * Holds collections of audio and video devices.
                 *
                 * @param  {MediaPlugin} mediaPlugin - the media plugin object
                 *
                 * @collection {Microphone} microphones
                 * @collection {Speaker} speakers
                 * @collection {Camera} cameras
                 * @property {Microphone} selectedMicrophone
                 * @property {Speaker} selectedSpeaker
                 * @property {Camera} selectedCamera - currently selected video device
                 * @member {VideoChannel} localVideoChannel - local video channel
                 *
                 *   To show local video preview set the channel container to a hosting DOM element;
                 *   to stop the preview set the channel container to null, i.e.
                 *
                 *      client.devices.localVideoChannel.container.set(
                 *          document.getElementById("previewWindow"));
                 *
                 */
                function Devices(mediaPlugin) {
                    // TODO: This class needs to be renamed to DevicesManager.
                    var pcTW = null, microphones = Collection({ subscribed: init, get: init }), speakers = Collection({ subscribed: init, get: init }), cameras = Collection({ subscribed: init, get: init }), selectedMicrophone = Property({
                        set: function (mic) {
                            selectAudioDevices(selectedSpeaker(), mic);
                            return mic;
                        }
                    }), selectedSpeaker = Property({
                        set: function (spk) {
                            selectAudioDevices(spk, selectedMicrophone());
                            return spk;
                        }
                    }), selectedCamera = Property({
                        set: function (cam) {
                            if (cam)
                                pcTW.invoke('SetSelectedVideoDevice', cam.id());
                            return cam;
                        }
                    }), localVideoContainer = Property({
                        value: null,
                        set: function (parentElem) {
                            // setting this to null while devices are not initialized should not
                            // trigger plugin component initialization
                            if (!isInitialized && !parentElem) {
                                assert(localVideoContainer() === null);
                                return localVideoContainer();
                            }
                            return init().then(function () {
                                if (!localVideoChannel.videoWindow() && parentElem) {
                                    return localVideoChannel.createVideoWindow(parentElem).then(function () {
                                        localVideoChannel.resizeVideoWindow(parentElem);
                                    });
                                }
                            }).then(function () {
                                if (parentElem) {
                                    check(selectedCamera(), 'No video camera');
                                    pcTW.invoke('StartVideoPreview', localVideoChannel.videoWindow(), selectedCamera().name());
                                    localVideoChannel.resized(onLocalVideoResized);
                                }
                                else {
                                    pcTW.invoke('StopVideoPreview');
                                    localVideoChannel.destroyVideoWindow();
                                    localVideoChannel.resized.off(onLocalVideoResized);
                                }
                                return parentElem;
                            });
                        }
                    }), localVideoChannel = LocalVideoChannel({
                        mediaPlugin: mediaPlugin,
                        state: Property(),
                        container: localVideoContainer
                    }), isInitialized = false, 
                    // this array matches the LWA plugin LWA_AUDIO_DEVICE_CATEGORIES enum:
                    categories = [
                        'Default',
                        'Mic and Speakers',
                        'Custom',
                        'Handset',
                        'Headset',
                        'Speaker',
                        'RoundTable'
                    ];
                    /**
                     * Initializes the object by loading TuningWizard plugin component
                     * and enumerating available audio and video devices.
                     */
                    function init() {
                        return mediaPlugin.initMedia().then(function () {
                            if (!pcTW) {
                                pcTW = mediaPlugin.createComponent({
                                    type: 'TuningWizard',
                                    hide: true,
                                    inproc: false
                                });
                                pcTW.event(onPluginComponentEvent, 'async');
                                return pcTW.load().then(function () {
                                    updateAudioDevices(pcTW.invoke('GetTelephonyDevicesDetails'));
                                    updateVideoDevices(pcTW.invoke('GetVideoDevicesDescription'));
                                    // the plugin is extremely chatty - it fires a lot of TEL_DEVICES_CHANGED
                                    // events, so we postpone event handling until after we load the plugin
                                    // and get the initial device collection snapshot
                                    isInitialized = true;
                                });
                            }
                        });
                    }
                    function uninit() {
                        if (pcTW) {
                            pcTW.event.off(onPluginComponentEvent);
                            pcTW = null;
                        }
                        localVideoChannel.destroyVideoWindow();
                        localVideoChannel.resized.off(onLocalVideoResized);
                        isInitialized = false;
                    }
                    function onPluginComponentEvent(ev) {
                        if (!isInitialized)
                            return;
                        if (ev.type == 'TEL_DEVICES_CHANGED')
                            updateAudioDevices(pcTW.invoke('GetTelephonyDevicesDetails'));
                        else if (ev.type == 'VIDEO_DEVICES_CHANGED')
                            updateVideoDevices(pcTW.invoke('GetVideoDevicesDescription'));
                    }
                    function onLocalVideoResized(size) {
                        // notify the TuningWizard component that the video window size has changed
                        pcTW.invoke('ResizeWindow', localVideoChannel.videoWindow(), size.width, size.height);
                    }
                    function selectAudioDevices(spk, mic) {
                        if (spk && mic)
                            pcTW.invoke('SetSelectedAudioDevices', spk.id(), mic.id());
                    }
                    /**
                     * Updates the microphones and speakers collection after calling GetTelephonyDevicesDetails.
                     * This method returns the results array that enumerates audio devices;
                     * each device description is formatted as 5 sequential array elements:
                     *
                     *    - device category
                     *    - audio render device
                     *    - audio capture device
                     *    - display name
                     *    - is UC certified
                     *
                     * The last array element is the index of the currently selected device.
                     */
                    function updateAudioDevices(res) {
                        assert(res.succeeded);
                        var i, smic, sspk, mics = [], spks = [], ad, mic, spk;
                        // build the current device list
                        for (i = 1; i < res.length - 1; i += 5) {
                            // the mic and the speaker share these props
                            ad = Model({
                                name: ConstProperty(res[i + 3]),
                                // e.g. "Headset", "Handset", "Mic and Speakers", "Custom", etc.
                                category: ConstProperty(categories[res[i]]),
                                // whether it's UC certified
                                certified: ConstProperty(res[i + 4])
                            });
                            spk = inherit(ad, {
                                // e.g. "Headset Earphone (Plantronics C220 M)"
                                id: ConstProperty(res[i + 1]),
                                type: ConstProperty('Speaker')
                            });
                            mic = inherit(ad, {
                                // e.g. "Headset Microphone (Plantronics C220 M)"
                                id: ConstProperty(res[i + 2]),
                                type: ConstProperty('Microphone')
                            });
                            spks.push(spk);
                            mics.push(mic);
                        }
                        // newly selected device (if there are no devices res = [0, -1])
                        sspk = spks[res[res.length - 1]];
                        smic = mics[res[res.length - 1]];
                        // replace device collection with a new device list
                        updateDeviceCollection(speakers, spks);
                        updateDeviceCollection(microphones, mics);
                        // TODO: note, that in some cases selectedSpeaker() != speakers(i) for any i
                        selectedSpeaker(sspk || null, Property.sUpdated);
                        // TODO: note, that in some cases selectedMicrophone() != microphones(i) for any i
                        selectedMicrophone(smic || null, Property.sUpdated);
                    }
                    /**
                     * Updates the cameras collection after calling GetVideoDevicesDescription
                     * This method returns the results array that enumerates all video devices;
                     * each array element is a string that describes a single device. The last array element
                     * is the index of the currently selected device.
                     */
                    function updateVideoDevices(res) {
                        assert(res.succeeded);
                        var i, scmr, cams = [], cam;
                        // build the current device list
                        for (i = 1; i < res.length - 1; i++) {
                            cam = Model({
                                // the media plugin doesn't give a unique id for every
                                // camera, so name is used as a reasonably unique id
                                id: ConstProperty(res[i]),
                                name: ConstProperty(res[i]),
                                type: ConstProperty('Camera'),
                                // TODO: this associates every camera with the same video channel,
                                // while there should be multiple video channels
                                localVideoChannel: localVideoChannel
                            });
                            cams.push(cam);
                        }
                        // newly selected device (if there are no devices res = [0, -1])
                        scmr = cams[res[res.length - 1]];
                        // replace the device collection with the new device list
                        updateDeviceCollection(cameras, cams);
                        // TODO: note, that in some cases selectedCamera() != cameras(i) for any i
                        selectedCamera(scmr || null, Property.sUpdated);
                    }
                    /**
                     * Replaces the contents of devices collection with the new device list minimizing the number
                     * of collection events fired during the update. This is achieved by adding new devices and
                     * deleting removed devices (vs. emptying the collection and filling it up from scratch).
                     */
                    function updateDeviceCollection(collDevices, devices) {
                        var keysToDelete = [];
                        // compare current device collection with the newly built set;
                        // after this array devices should contain only new devices to be
                        // added to the devices collection and keysToDelete
                        // should contain keys of the devices to be deleted from the
                        // device collection
                        collDevices.each(function (device, key) {
                            var isPresent = false, i;
                            for (i = 0; i < devices.length; i++) {
                                if (device.id() == devices[i].id()) {
                                    isPresent = true;
                                    devices.splice(i, 1);
                                    break;
                                }
                            }
                            if (!isPresent)
                                keysToDelete.push(key);
                        });
                        // remove deleted devices
                        foreach(keysToDelete, function (key) {
                            collDevices.remove(key);
                        });
                        // add new devices
                        foreach(devices, function (device) {
                            collDevices.add(device);
                        });
                    }
                    return Model({
                        init: async(init),
                        uninit: async(uninit),
                        speakers: speakers.asReadOnly(),
                        microphones: microphones.asReadOnly(),
                        cameras: cameras.asReadOnly(),
                        selectedSpeaker: selectedSpeaker,
                        selectedMicrophone: selectedMicrophone,
                        selectedCamera: selectedCamera,
                        localVideoChannel: localVideoChannel.public
                    });
                }
                Internal.Devices = Devices;
                //#endregion Devices
                //#region AppSharing (internal)
                /**
                 * Encapsulates AppSharing component to be shared across Models
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {PluginComponent} component
                 *
                 * @method {Promise} init - initializes/loads AppSharing component
                 * @method uninit - unloads AppSharing component
                 * @method setCallConfig - wraps call to component's SetCallConfig
                 * @method setMediaConfig - wraps call to component's SetMediaConfig
                 * @method initializeViewer - wraps call to component's InitializeViewer
                 * @method connectViewer - wraps call to component's ConnectViewer
                 * @method createViewerStream - wraps call to component's ConnectViewerStream
                 * @method setViewerWindowSize - wraps call to component's SIZE_CHANGED
                 * @method setSmartSizingViewer - wraps call to component's SetSmartSizingViewer
                 * @method publishFullScreenState - wraps call to component's PublishFullScreenState
                 * @method setOffer - wraps call to component's SetOffer
                 * @method setFinalAnswer - wraps call to component's SetFinalAnswer
                 * @method setProvisionalAnswer - wraps call to component's SetProvisionalAnswer
                 * @method completeNegotiation - wraps call to component's CompleteNegotiation
                 * @method {Array} getShareableResources - queries component for shareable resources (windows/monitors)
                 * @method drawTrackingChrome - draws a tracking chrome around a specified monitor
                 * @method removeTrackingChrome - removes a tracking chrome around a specified monitor
                 * @method {String} getResourcePreview - returns the data URL of the image
                 * @method shareResource - Shares a resource (window/monitor) with AppSharing component
                 * @method unshareResource - Unshares a resource (window/monitor) with AppSharing component
                 * @method disposeSharer - wraps call to component's DisposeSharer
                 * @method disposeViewer - wraps call to component's DisposeViewer
                 * @method on - attaches handler to component's events
                 * @method off - detaches handler from component's events
                 *
                 */
                function AppSharing(options) {
                    var mediaConfig = options.mediaConfig, pcAS = options.component, isInitialized = false;
                    function init() {
                        return pcAS.load('', '', guid(), false, mediaConfig.maxVideoChannelCount(), mediaConfig.applicationSharingSecurityLevel()).then(function () {
                            pcAS.invoke('InitializeSharer');
                            pcAS.setLogLevel(3);
                            isInitialized = true;
                        });
                    }
                    function uninit() {
                        if (pcAS) {
                            pcAS.unload();
                            pcAS = null;
                            isInitialized = false;
                        }
                    }
                    function checkState() {
                        if (!isInitialized)
                            throw Exception.call('Not Initialized', 'NotInitialized');
                    }
                    function setCallConfig() {
                        checkState();
                        pcAS.invoke('SetCallConfig', mediaConfig.isInternal() ?
                            MediaEnum.PreferredMediaAddressType.Direct :
                            MediaEnum.PreferredMediaAddressType.Relay);
                    }
                    function setMediaConfig(direction, type) {
                        checkState();
                        pcAS.invoke('SetMediaConfig', direction, type);
                    }
                    function initializeViewer(wHandle) {
                        checkState();
                        pcAS.invoke('InitializeViewer', wHandle);
                    }
                    function connectViewer(connectionString) {
                        checkState();
                        pcAS.invoke('ConnectViewer', connectionString);
                    }
                    function createViewerStream() {
                        checkState();
                        pcAS.invoke('CreateViewerStream', 3 /* BOTH */);
                    }
                    function setViewerWindowSize(width, height) {
                        checkState();
                        pcAS.invoke('SIZE_CHANGED', width, height);
                    }
                    function setSmartSizingViewer(val) {
                        checkState();
                        pcAS.invoke('SetSmartSizingViewer', val);
                    }
                    function publishFullScreenState(state) {
                        checkState();
                        pcAS.invoke('PublishFullScreenState', state);
                    }
                    function setOffer(isProvisionalAnsReq, count) {
                        checkState();
                        if (count < 1)
                            throw EInvalidArgument('count', 'No Offers Provided');
                        var args = ['SetOffer', isProvisionalAnsReq, count].concat([].slice.call(arguments, 2));
                        pcAS.invoke.apply(pcAS, args);
                    }
                    function setFinalAnswer(remoteEndpoint, sdp) {
                        checkState();
                        pcAS.invoke('SetFinalAnswer', remoteEndpoint, sdp);
                    }
                    function setProvisionalAnswer(isOfferForked, acceptEarlyMedia, remoteEndpoint, sdp) {
                        checkState();
                        pcAS.invoke('SetProvisionalAnswer', isOfferForked, acceptEarlyMedia, remoteEndpoint, sdp);
                    }
                    function completeNegotiation(statusCode) {
                        checkState();
                        pcAS.invoke('CompleteNegotiation', statusCode);
                    }
                    function getShareableResources() {
                        checkState();
                        var items = [], resources, count, index = 0;
                        pcAS.invoke('LockFetchResources');
                        resources = pcAS.invoke('GetResources');
                        pcAS.invoke('UnlockFetchResources');
                        if (resources) {
                            count = resources[resources.length - 1];
                            resources = resources.slice(1, -1);
                            for (var i = 0; i < count; i++) {
                                // Check if resource is shareable before adding to list and not already shared
                                if (resources[index + 4] !== 1 && (resources[index] === 1 || (resources[index] === 3 && resources[index + 6] !== 0))) {
                                    items.push({
                                        type: resources[index],
                                        id: resources[index + 1],
                                        appId: resources[index + 2],
                                        name: resources[index + 3],
                                        isShared: resources[index + 4],
                                        flags: resources[index + 5],
                                        isResourceAsIsShareable: resources[index + 6],
                                        fIsImmersiveModeApp: resources[index + 7]
                                    });
                                }
                                index += 8;
                            }
                        }
                        return items;
                    }
                    function drawTrackingChrome(id) {
                        checkState();
                        pcAS.invoke('DrawMonitorTrackingChrome', id);
                    }
                    function removeTrackingChrome(id) {
                        checkState();
                        pcAS.invoke('RemoveMonitorTrackingChrome', id);
                    }
                    function getResourcePreview(resource, dimensions) {
                        checkState();
                        var result;
                        // TODO: Consider reusing filter...
                        if (resource.type === 1) {
                        }
                        else {
                            var temp = pcAS.invoke('GetApplicationPreview', resource.appId, resource.id, dimensions.width, dimensions.height);
                            result = 'data:image/png;base64,' + temp[1];
                        }
                        return result;
                    }
                    function shareResource(resource) {
                        checkState();
                        // Probably a try/catch here...
                        // Figure out if we can move control related to another method or extend signature...
                        pcAS.invoke('SetControlAllowed', 1, true, true);
                        if (resource.id !== -1) {
                            pcAS.invoke('SetResourceFilter', resource.filter, 1);
                            pcAS.invoke('SetResourceSharedState', resource.type, resource.id, resource.appId, 1);
                        }
                        else {
                            pcAS.invoke('DisableFilters');
                        }
                        // Figure out if we should allow control over allowing sharing to stop..?
                        pcAS.invoke('CanStopSharing', true);
                    }
                    function unshareResource(resource) {
                        checkState();
                        pcAS.invoke('SetResourceSharedState', resource.type, resource.id, resource.appId, 0);
                    }
                    function disposeSharer() {
                        checkState();
                        pcAS.invoke('DisposeSharer');
                    }
                    function disposeViewer() {
                        checkState();
                        pcAS.invoke('DisposeViewerCore');
                    }
                    return {
                        init: async(init),
                        uninit: uninit,
                        setCallConfig: setCallConfig,
                        setMediaConfig: setMediaConfig,
                        initializeViewer: initializeViewer,
                        connectViewer: connectViewer,
                        createViewerStream: createViewerStream,
                        setViewerWindowSize: setViewerWindowSize,
                        setSmartSizingViewer: setSmartSizingViewer,
                        publishFullScreenState: publishFullScreenState,
                        setOffer: setOffer,
                        setFinalAnswer: setFinalAnswer,
                        setProvisionalAnswer: setProvisionalAnswer,
                        completeNegotiation: completeNegotiation,
                        getShareableResources: getShareableResources,
                        drawTrackingChrome: drawTrackingChrome,
                        removeTrackingChrome: removeTrackingChrome,
                        getResourcePreview: getResourcePreview,
                        shareResource: shareResource,
                        unshareResource: unshareResource,
                        disposeSharer: disposeSharer,
                        disposeViewer: disposeViewer,
                        event: pcAS.event
                    };
                }
                Internal.AppSharing = AppSharing;
                //#endregion
                //#region ShareableWindow
                /**
                 * Encapsulates logic for a shareable window
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {JSON} resource
                 * @param {Property} shared
                 *
                 * @property {Number} id - read only
                 * @property {String} title - read only
                 * @property {Boolean} shared - Gets the shared state of the resource
                 *
                 * @method {String} preview - returns the data URL of the image
                 *
                 */
                function ShareableWindow(options) {
                    var mediaPlugin = options.mediaPlugin, resource = options.resource, shared = options.shared;
                    resource.filter = 2 /* ApplicationFilter */;
                    function preview(dimensions) {
                        return mediaPlugin.getAppSharing().then(function (appSharing) {
                            return appSharing.getResourcePreview(resource, dimensions);
                        });
                    }
                    return Model({
                        id: ConstProperty(resource.id),
                        title: ConstProperty(resource.name),
                        shared: shared,
                        preview: async(preview)
                    });
                }
                //#endregion
                //#region ShareableMonitor
                /**
                 * Encapsulates logic for a shareable monitor
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {JSON} resource
                 * @param {Property} shared
                 *
                 * @property {Number} id - read only
                 * @property {String} title - read only
                 * @property {Boolean} shared - Gets the shared state of the resource
                 * @property {Boolean} selected - Draws/Removes tracking chrome based on selection
                 *
                 */
                function ShareableMonitor(options) {
                    var mediaPlugin = options.mediaPlugin, resource = options.resource, shared = options.shared;
                    if (resource.id !== -1) {
                        resource.name = 'Monitor #' + resource.id;
                    }
                    else {
                        resource.name = 'Desktop Sharing';
                    }
                    resource.filter = 1 /* DesktopFilter */;
                    // draws or removes tracking chrome based on selection state
                    var selected = Property({
                        type: 'Boolean',
                        value: false,
                        set: function (val) {
                            return mediaPlugin.getAppSharing().then(function (appSharing) {
                                if (val) {
                                    appSharing.drawTrackingChrome(resource.id);
                                }
                                else {
                                    appSharing.removeTrackingChrome(resource.id);
                                }
                                return val;
                            });
                        }
                    });
                    return Model({
                        id: ConstProperty(resource.id),
                        title: ConstProperty(resource.name),
                        shared: shared,
                        selected: selected
                    });
                }
                //#endregion
                //#region SharedResources
                /**
                 * Encapsulates AppSharing component to be shared across Models
                 *
                 * @collection {ShareableWindow} windows - available shareable windows
                 * @collection {ShareableMonitor} monitors - available shareable monitors
                 *
                 * @method {Promise} init - initializes/loads shareable resources
                 * @method uninit
                 * @method setShared(id, value) - Sets the shared state value of a resource based on supplied id
                 *
                 */
                function SharedResources(mediaPlugin) {
                    var appSharing, dfdInit, windows = Collection({ get: init, subscribed: init }), monitors = Collection({ get: init, subscribed: init }), sharedProperties = {};
                    /**
                     * Note, that `init` may be called multiple times: the first call
                     * must start initializing the AS component, while subsequent calls
                     * must await the first call. This is achieved by keeping the promise
                     * returned by the first call in a variable `dfdInit` and returning
                     * this `dfdInit` from subsequent calls.
                     */
                    function init() {
                        return dfdInit ? dfdInit : dfdInit = mediaPlugin.initMedia().then(function () {
                            return mediaPlugin.getAppSharing();
                        }).then(function (as) {
                            assert(!appSharing);
                            appSharing = as;
                            appSharing.event(onPluginComponentEvent, 'async');
                            // Skip resource discovery for Mac for now
                            if (!UserAgent().isMac()) {
                                var windowItems = [], monitorItems = [], resources = appSharing.getShareableResources();
                                foreach(resources, function (item) {
                                    if (item.type === 1) {
                                        monitorItems.push(item);
                                    }
                                    else if (item.type === 3) {
                                        windowItems.push(item);
                                    }
                                });
                                updateItems(windowItems, windows);
                                updateItems(monitorItems, monitors);
                            }
                            handleDesktopSharing();
                        });
                    }
                    function uninit() {
                        if (appSharing)
                            appSharing.event.off(onPluginComponentEvent);
                        appSharing = null;
                        dfdInit = null;
                    }
                    /**
                     * Listen for 'ResourceUpdate' component events to determine when resources are added/removed
                     */
                    function onPluginComponentEvent(event) {
                        if (event.type == 'ResourceUpdated') {
                            var action = event.args.splice(7, 1)[0], type = event.args[0], item, resource = {
                                type: event.args[0],
                                id: event.args[1],
                                appId: event.args[2],
                                name: event.args[3],
                                isShared: event.args[4],
                                flags: event.args[5],
                                isResourceAsIsShareable: event.args[6],
                                fIsImmersiveModeApp: event.args[7]
                            }, shared;
                            if (type === 1) {
                                // This is a monitor resource
                                item = GetResourceKey(resource, monitors);
                                if (action === 1) {
                                    // Add
                                    if (!item) {
                                        shared = createSharedProperty(resource);
                                        sharedProperties[resource.id] = shared;
                                        monitors.add(ShareableMonitor({
                                            resource: resource,
                                            mediaPlugin: mediaPlugin,
                                            shared: shared.asReadOnly()
                                        }));
                                    }
                                }
                                else if (action === 2) {
                                    // Delete
                                    if (item) {
                                        monitors.remove(item);
                                        delete sharedProperties[resource.id];
                                    }
                                }
                                handleDesktopSharing();
                            }
                            else if (type === 3) {
                                // This is a window resource
                                item = GetResourceKey(resource, windows);
                                if (action === 1) {
                                    // Add
                                    if (!item && resource.isResourceAsIsShareable) {
                                        shared = createSharedProperty(resource);
                                        sharedProperties[resource.id] = shared;
                                        windows.add(ShareableWindow({
                                            resource: resource,
                                            mediaPlugin: mediaPlugin,
                                            shared: shared.asReadOnly()
                                        }));
                                    }
                                }
                                else if (action === 2) {
                                    // Delete
                                    if (item) {
                                        windows.remove(item);
                                        delete sharedProperties[resource.id];
                                    }
                                }
                            }
                        }
                    }
                    /**
                     * Adds or removes option for sharing entire desktop based on number of monitors
                     */
                    function handleDesktopSharing() {
                        var desktopSharingKey, resource = {
                            type: 4,
                            id: -1,
                            appId: -1
                        }, shared;
                        monitors.each(function (item, key) {
                            if (item.title() === 'Desktop Sharing') {
                                desktopSharingKey = key;
                            }
                        });
                        if (desktopSharingKey) {
                            monitors.remove(desktopSharingKey);
                            delete sharedProperties[resource.id];
                        }
                        shared = createSharedProperty(resource);
                        sharedProperties[resource.id] = shared;
                        monitors.add(ShareableMonitor({
                            resource: resource,
                            mediaPlugin: mediaPlugin,
                            shared: shared.asReadOnly()
                        }));
                    }
                    /**
                     * Find the specific resource key for a value potentially in the collection
                     */
                    function GetResourceKey(value, collection) {
                        var resourceKey;
                        collection.each(function (item, key) {
                            if (item.id() === value.id) {
                                resourceKey = key;
                                return;
                            }
                        });
                        return resourceKey;
                    }
                    /**
                     * Add/Remove resources of a collection
                     */
                    function updateItems(resources, collection) {
                        foreach(resources, function (item) {
                            var skip = false;
                            collection.each(function (obj) {
                                if (item.id === obj.id()) {
                                    skip = true;
                                }
                            });
                            if (!skip) {
                                var shared = createSharedProperty(item);
                                sharedProperties[item.id] = shared;
                                if (item.type === 1) {
                                    collection.add(ShareableMonitor({
                                        resource: item,
                                        mediaPlugin: mediaPlugin,
                                        shared: shared.asReadOnly()
                                    }));
                                }
                                else {
                                    collection.add(ShareableWindow({
                                        resource: item,
                                        mediaPlugin: mediaPlugin,
                                        shared: shared.asReadOnly()
                                    }));
                                }
                            }
                        });
                    }
                    function createSharedProperty(resource) {
                        return Property({
                            value: false,
                            set: function (val) {
                                return mediaPlugin.getAppSharing().then(function (appSharing) {
                                    var obj = {
                                        type: resource.type,
                                        id: resource.id,
                                        appId: resource.appId,
                                        filter: resource.filter
                                    };
                                    if (val)
                                        appSharing.shareResource(obj);
                                    else
                                        appSharing.unshareResource(obj);
                                    return val;
                                });
                            }
                        });
                    }
                    function setShared(id, value) {
                        if (sharedProperties[id]) {
                            sharedProperties[id](value);
                        }
                    }
                    return Model({
                        init: async(init),
                        uninit: uninit,
                        windows: windows.asReadOnly(),
                        monitors: monitors.asReadOnly(),
                        setShared: setShared
                    });
                }
                Internal.SharedResources = SharedResources;
                //#endregion
                /**
                 * Container for media plugin enums
                 */
                var MediaEnum;
                (function (MediaEnum) {
                    MediaEnum.PreferredMediaAddressType = Enum('None', 'Direct', 'Relay');
                    MediaEnum.MediaDeviceType = Enum('MIC', 'SPEAKER', 'PREVIEW', 'RENDER');
                    MediaEnum.VideoFormat = StringEnum('Fit', 'Crop', 'Stretch');
                    MediaEnum.NegotiationStatus = Enum('NS_SUCCESS', 'NS_LOCAL_INTERNAL_ERROR', 'NS_REMOTE_INTERNAL_ERROR', 'NS_OFFER_NOT_ACCEPTABLE', 'NS_OFFER_DECLINED', 'NS_LOCAL_CANCEL', 'NS_REMOTE_CANCEL', 'NS_REMOTE_MIME_UNSPPORTED');
                    MediaEnum.MediaEvent = StringEnum('OFFER_READY', 'CHANNEL_CREATED', 'CHANNEL_DELETED', 'ANSWER_READY', 'CONNECTIVITY_CHECK_STATUS', 'MEDIA_CHANGED', 'INVALID_PROXY_CREDENTIAL');
                    MediaEnum.AVEvent = StringEnum('DEVICE_INTENSITY_CHANGED', 'VIDEO_SIZE_CHANGED', 'NEG_STATUS', 'CHANNEL_DIRECTION_CHANGED', 'CHANNEL_DISCONNECTED', 'QUALITY_CHANGED', 'AUDIO_DEVICE_CHANGED', 'VIDEO_DEVICE_CHANGED', 'DOMINANT_SPEKAER_CHANGED', 'SUBSCRIPTION_STATE_CHANGED', 'CONTRIBUTING_SOURCES_CHANGED', 'VIDEO_CAPABILITY_CHANGED');
                    MediaEnum.StreamState = StringEnum('Stopped', 'Started', 'Inactive', 'Active');
                    MediaEnum.StreamType = Enum('Preview', 'MainRender', 'Render' // video received on an additional video channel
                    );
                    MediaEnum.DtmfTone = Enum('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'Star', 'Pound', 'A', 'B', 'C', 'D', 'Flash');
                })(MediaEnum = Internal.MediaEnum || (Internal.MediaEnum = {}));
            })(Internal = Model_1.Internal || (Model_1.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=media-model.js.map

/// <reference path="./ucwa.ts" />
/// <reference path="./media-model.ts" />
/// <reference path="./telemetry.ts" />
/**
 * The SkypeWeb model layer built on top of the stack layer.
 *
 * The model creates the stack and subscribes to its events.
 * In turn it creates models that are subscribed to stack objects
 * and provides observable properties and collections to which
 * the view model can bind.
 *
 * As an example Model.Person uses Stack.Application to send and
 * receive HTTP requests, Stack.Connection to listen to the event
 * channel and Stack.Repository to have access to the UCWA resource
 * representing the contact.
 *
 * To the view model, the Person offers a set of observable properties:
 * the Person updates these properties when it receive events from
 * the stack layer and the view model gets notified when these properties
 * are changed.
 *
 * Here is an example how the view model can bind to a Person's presence status:
 *
 *      person1.status.changed(function (status) {
 *          console.log("availability: " + status);
 *      });
 *
 * In this example when the view model subscribes to the contact's presence,
 * the contact creates the presence subscription on the server and when the
 * view model unsubscribes from the presence, the contact deletes the
 * presence subscription.
 *
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_1) {
            
            //#region Imports (from the global namespace)
            var global = window.ttt ? window.ttt.window : window;
            var setInterval = global.setInterval;
            var clearInterval = global.clearInterval;
            var Date = global.Date;
            global = null;
            //#endregion
            //#region Imports (from Skype.Web.Telemetry)
            // APIs will work fine if telemetry is not available.
            var record = Skype.Web.Telemetry ? Skype.Web.Telemetry.record : function () { };
            var setTelemetryKey = Skype.Web.Telemetry ? Skype.Web.Telemetry.setKey : function () { };
            var initTelemetry = Skype.Web.Telemetry ? Skype.Web.Telemetry.initTelemetry : null;
            //#endregion
            //#region Imports (from Skype.Web.Stack)
            var UCWA = Skype.Web.Stack.UCWA;
            //#endregion
            //#region Imports (from Skype.Web.Utils)
            var Utils = Skype.Web.Utils;
            var assert = Utils.assert;
            var DataUri = Utils.DataUri;
            var batched = Utils.batched;
            var async = Utils.async;
            var bind = Utils.bind;
            var Command = Utils.Command;
            var EnabledCommand = Utils.EnabledCommand;
            var DisabledCommand = Utils.DisabledCommand;
            var DisabledAsyncCommand = Utils.DisabledAsyncCommand;
            var NumProperty = Utils.NumProperty;
            var BoolProperty = Utils.BoolProperty;
            var Event = Utils.Event;
            var StringEnum = Utils.StringEnum;
            var Enum = Utils.Enum;
            var extend = Utils.extend;
            var contains = Utils.contains;
            var indexOf = Utils.indexOf;
            var guid = Utils.guid;
            var inherit = Utils.inherit;
            var random = Utils.random;
            var setHiddenProperty = Utils.setHiddenProperty;
            var isNotEmptyString = Utils.isNotEmptyString;
            var isString = Utils.isString;
            var isObject = Utils.isObject;
            var isArray = Utils.isArray;
            var isVoid = Utils.isVoid;
            var isPromise = Utils.isPromise;
            var isProperty = Utils.isProperty;
            var isCollection = Utils.isCollection;
            var isModel = Utils.isModel;
            var foreach = Utils.foreach;
            var Property = Utils.Property;
            var ConstProperty = Utils.ConstProperty;
            var Collection = Utils.Collection;
            var isEmptyObject = Utils.isEmptyObject;
            var SequentialStateMachine = Utils.SequentialStateMachine;
            var map = Utils.map;
            var isDictionary = Utils.isDictionary;
            var check = Utils.check;
            var Exception = Utils.Exception;
            var EInvalidArgument = Utils.EInvalidArgument;
            var EInvalidState = Utils.EInvalidState;
            var EDoesNotExist = Utils.EDoesNotExist;
            var EAlreadyExists = Utils.EAlreadyExists;
            var ENotSupported = Utils.ENotSupported;
            var Task = Utils.Task;
            var debug = Utils.debug;
            var URI = Utils.URI;
            var convertTextToHtml = Utils.convertTextToHtml;
            var convertHtmlToText = Utils.convertHtmlToText;
            var disableHtmlInText = Utils.disableHtmlInText;
            var sanitizeHtml = Utils.sanitizeHtml;
            var clone = Utils.clone;
            var filter = Utils.filter;
            var repeat = Utils.repeat;
            var repeatAndExit = Utils.repeatAndExit;
            var sleep = Utils.sleep;
            var timeStampToDate = Utils.timeStampToDate;
            var dateToTimeStamp = Utils.dateToTimeStamp;
            var getOption = Utils.getOption;
            var keys = Utils.keys;
            var Symbol = Utils.Symbol;
            var size = Utils.size;
            var find = Utils.find;
            var findIndex = Utils.findIndex;
            var SourcedProperty = Utils.SourcedProperty;
            var Model = Utils.Model;
            //#endregion
            /** application[sUCWA] = the UCWA stack for the app */
            var sUCWA = Symbol('ucwa');
            /** Application[sInstances] keeps the list of all created apps */
            var sInstances = Symbol('instances');
            //#region Application
            /**
             * The root object in the object model.
             *
             * One instance of Application creates one UCWA endpoint that
             * can sign in with its own credentials. The constructor
             * is not a singleton as it is possible to create several
             * UCWA endpoints in one web app and make them chat with
             * each other via the UCWA protocol.
             *
             * @member {DevicesManager} devicesManager - All the devices of the current computer.
             * @member {ConversationsManager} conversationsManager
             * @member {PersonsAndGroupsManager} personsAndGroupsManager
             * @member {GeneralPolicies} policies - General settings.
             *
             *      For instance, to check whether photos are enabled for the client, fetch
             *      the value of the `photos` setting:
             *
             *          client.policies.photos.get().then(function (value) {
             *              if (video == 'Enabled')
             *                  ...
             *          });
             *
             *      The value is initially unavailable and a call to `.get` loads
             *      it from the server.
             *
             *      The list of available settings and their descriptions can be found
             *      in the comment for the GeneralPolicies class.
             *
             * @member {MediaPolicies} mediaPolicies - Settings related to media API.
             *
             *      For instance, to check whether video is enabled for the client, fetch
             *      the value of the `video` setting:
             *
             *          client.mediaPolicies.video.get().then(function (value) {
             *              if (video == 'Enabled')
             *                  ...
             *          });
             *
             *      The value is initially unavailable and a call to `.get` loads
             *      it from the server.
             *
             *      The list of available settings and their descriptions can be found
             *      in the comment for the MediaPolicies class.
             *
             * @collection {Conversation} conversations - All active conversations.
             *
             *      Here is a correct way to accept incoming IM invitations:
             *
             *          client.conversations.added(function (conversation) {
             *              var messaging = conversation.chatService;
             *              if (messaging.accept.enabled())
             *                  modality.accept();
             *          });
             *
             *      The only way to remove a conversation from the collection is
             *      to invoke the `remove` method which stops the conversation and
             *      then removes it from the collection:
             *
             *          var cv = client.conversations(5);
             *          client.conversations.remove(cv).then(null, function (err) {
             *              console.log("Failed to remove the conversation: " + err);
             *          });
             *
             *      If the conversation gets stopped because it was terminated on the remote
             *      side or because all participants left, the conversation
             *      object stays in the collection, but its state changes to "Disconnected".
             *
             *      To remove all conversations that get disconnected, use the following
             *      pattern:
             *
             *          client.conversations.added(function (cv) {
             *              cv.state.once('Disconnected', function () {
             *                  client.conversations.remove(cv);
             *              });
             *          });
             *
             * @collection {ShareableWindow} windows - Shareable application windows.
             * @collection {ShareableMonitor} monitors - Shareable monitors.
             *
             * @command {Object} getSnapshot - Returns a snapshot of the client's state.
             *
             *      The snapshot contains the state of the client at the moment:
             *      it contains contacts data, conversations state and so on. It
             *      can be serialized and saved somewhere so that later another
             *      instance of the client can pull data from it and avoid fetching
             *      all the data from the server again.
             *
             *      The returned snapshot is supposed to be saved somewhere
             *      so that later it can be used as a parameter to the constructor
             *      of the client.
             *
             * @command {Promise<Object>} search - Searches for contacts and groups.
             * @command {Promise<Conversation>} startMessaging - Starts an IM conversation.
             * @command {Promise<Conversation>} startAudioVideo - Starts an audio/video call.
             * @command {Promise<Conversation>} startAppSharing - Starts an app-sharing call.
             * @command {Promise<Conversation>} startMeeting - Creates or joins an online meeting.
             * @command {Promise<MyOnlineMeeting>} scheduleMeeting - Schedules an online meeting.
             *
             *      scheduleMeeting doesn't join the created meeting. To join the meeting
             *      use the startMeeting method.
             *
             * @command {Conversation} createConversation - Creates an empty conversation model.
             *
             *      The created conversation model is empty: it has no modalities, no participants
             *      and it's not connected to the server. To make it connected, add modalities,
             *      start them and add participants:
             *
             *          var conversation = client.createConversation();
             *          var messaging = conversation.chatService;
             *
             *          messaging.start({
             *              to: "sip:johndoe@contoso.com"
             *          }).then(function () {
             *              console.log("messaging started");
             *          });
             *
             *      Right after the conversation is created, it appears in the `conversations` collection.
             *
             *      This method is meant to be used by advanced web apps. Simple web apps
             *      may use startMessaging, startAudioVideo, startAppSharing and other
             *      similar methods.
             *
             */
            function Application(settings) {
                settings = settings || {};
                var ConversationsManager = Internal.ConversationsManager, MePerson = Internal.MePerson, PresenceSubscriptionManager = Internal.PresenceSubscriptionManager, ContactManager = Internal.ContactManager, PersonsAndGroupsManager = Internal.PersonsAndGroupsManager, GeneralPolicies = Internal.GeneralPolicies, Conversation = Internal.Conversation, MyOnlineMeeting = Internal.MyOnlineMeeting, ObservableResource = Internal.ObservableResource, MediaPlugin = Internal.MediaPlugin, Devices = Internal.Devices, SharedResources = Internal.SharedResources, MediaPolicies = Internal.MediaPolicies;
                var state = Property(), client = Model(), createConversationsManager = settings.ConversationsManager || ConversationsManager, ucwa = settings.ucwa || UCWA(), guestName = Property(), dfdSignedIn, dfdSignedOut, conversationsManager;
                //#region init
                function init() {
                    var mediaPlugin, devices, sharedResources, me, contactManager, psm, pgm, gcs;
                    state(Application.State.SignedOut);
                    // expose the UCWA stack to simplify debugging
                    // with the dev console, but make it impossible
                    // to use by other js code
                    setHiddenProperty(client, sUCWA, ucwa);
                    // eventually some of these settings might become a part of
                    // the external interface, but for now they remain internal
                    gcs = ObservableResource(ucwa, {
                        source: { rel: 'communication' },
                        properties: {
                            conversationHistory: {}
                        },
                        commands: {
                            joinOnlineMeeting: {}
                        }
                    });
                    me = MePerson(ucwa, {
                        guestName: guestName.asReadOnly(),
                        supportsText: getOption(settings, 'supportsText', true),
                        supportsHtml: getOption(settings, 'supportsHtml', true),
                        supportsMessaging: getOption(settings, 'supportsMessaging', true),
                        supportsAudio: getOption(settings, 'supportsAudio', true),
                        supportsVideo: getOption(settings, 'supportsVideo', true),
                        supportsSharing: getOption(settings, 'supportsSharing', true),
                        supportsConferencing: gcs.joinOnlineMeeting.enabled.asReadOnly()
                    });
                    psm = PresenceSubscriptionManager(ucwa, settings.presenceSubscriptionsBatchSize, settings.presenceSubscriptionDuration);
                    contactManager = ContactManager(ucwa, psm);
                    // media may not be supported by this build
                    mediaPlugin = MediaPlugin && MediaPlugin(ucwa);
                    devices = Devices && Devices(mediaPlugin);
                    sharedResources = SharedResources && SharedResources(mediaPlugin);
                    pgm = PersonsAndGroupsManager({
                        ucwa: ucwa,
                        psm: psm,
                        contactmgr: contactManager,
                        me: me
                    });
                    conversationsManager = createConversationsManager({
                        ucwa: ucwa,
                        me: me,
                        gcs: gcs,
                        listNamesInTopic: settings.listParticipantNamesInConversationTopic,
                        guestName: guestName.asReadOnly(),
                        mediaPlugin: mediaPlugin,
                        contactManager: contactManager,
                        devices: devices,
                        sharedResources: sharedResources
                    });
                    // media may not be included in this build
                    client.mediaPolicies = MediaPolicies && MediaPolicies(ucwa);
                    client.personsAndGroupsManager = pgm;
                    client.conversationsManager = conversationsManager;
                    client.conversations = conversationsManager.conversations;
                    client.devices = devices; // TODO: This has been replaced with .devicesManager.
                    client.windows = sharedResources ? sharedResources.windows : Collection.empty;
                    client.monitors = sharedResources ? sharedResources.monitors : Collection.empty;
                    client.policies = GeneralPolicies(ucwa);
                    client.devicesManager = devices;
                    client.telemetryManager = initTelemetry && initTelemetry(settings.skypeDataUrl);
                    state.when(Application.State.SignedIn, function () {
                        // .connected means connected to the event channel,
                        // so the stack can be signed in but disconnected
                        var sub = ucwa.connected.when(false, function (reason, wasConnected) {
                            // right after sign in the stack may still be connecting
                            if (wasConnected) {
                                debug.log('%c The server has terminated the event channel with this endpoint.', 'color:red;font-weight:bold', reason);
                                state(Application.State.SignedOut, reason);
                            }
                        });
                        // publish the self presence and let others send IMs to this client
                        me.available(true);
                        // the setting can be changed only when the stack is connected
                        // to the server and when rel=communication has an etag value
                        conversationsManager.isHistoryEnabled.set.enabled.once(true, function () {
                            var delay = 4.12;
                            // If the PUT /communication is sent after POST /makeMeAvailable
                            // and before the "communication updated" event with a new etag
                            // value, the PUT will be rejected with a 412.PrecondtitionFailed.
                            // This happens because the POST changes the etag once the server
                            // gets the request, but the client remains unaware of the new etag
                            // value until the "updated" event arrives.
                            repeatAndExit(function (exit) {
                                // without a delay an attempt to enable the conversation history
                                // flag results in a cryptic error: 412 code=PreconditionFailed;
                                // and a delay of 4.12 seconds seems to be good enough to fix it
                                return sleep(delay).then(function () {
                                    delay *= 2;
                                    // unconditionally enable the conversation history feature:
                                    // this will also make UCWA auto-acept IM requests and archive
                                    // them in Exchange; otherwise if this is the only available
                                    // endpoint and it gets an IM request which is not accepted,
                                    // it gets auto-declined and not archived anywhere
                                    return conversationsManager.isHistoryEnabled.set(true).then(exit, function (err) {
                                        // there is a subcode=PreconditionFailed field in the response body,
                                        // but since the status code 412 already means that a precondition
                                        // failed, the subcode is ignored
                                        var is412 = err.code == 'RequestFailed' && err.rsp.status == 412;
                                        if (!is412)
                                            throw err;
                                    });
                                });
                            });
                        });
                        // the telemetry logger extracts the app id from the href
                        setTelemetryKey(ucwa.get({ rel: 'application' }).href);
                        state.once(Application.State.SignedOut, function () {
                            if (mediaPlugin)
                                mediaPlugin.uninitMedia();
                            sub.dispose();
                            ucwa.uninit();
                        });
                    });
                }
                //#endregion
                //#region defineCommand
                function defineCommand(states, fn) {
                    var enabled = Property();
                    var command = Command(fn, enabled);
                    state.changed(function (value) {
                        enabled(indexOf(states, value) >= 0);
                    });
                    return command;
                }
                //#endregion
                //#region defineAsyncCommand
                function defineAsyncCommand(states, fn) {
                    return defineCommand(states, async(fn));
                }
                //#endregion
                //#region signIn
                /**
                 * @param {string} [username] - The user name, e.g. "user@company.com"
                 * @param {string} [password] - The password.
                 * @param {string} [domain] - FQDN of the server.
                 * @param {Function} [auth] - The auth method. OAuth for instance.
                 * @param {string} [root.user] - The href for the user resource to skip auto discovery.
                 * @param {string} [root.xframe] - The href for the xframe to skip auto discovery.
                 * @param {Boolean} [root.internal] - Whether the UCWA root is internal or external.
                 * @param {String} [meeting] - URI of the online meeting to join anonymously.
                 * @param {String} [name] - The name to be displayed in anonymously joined meetings.
                 * @param {Array} [origins] - Custom auto discovery URLs.
                 * @param {String} [client_id] - The client_id parameter for OAuth2. Typically it looks like a GUID.
                 * @param {String} [oauth_uri] - The default OAuth URI. Needed if the server fails to provide this URI.
                 * @param {Number} [throttle=5]
                 *
                 *      If the web app tries to send too many requests to the server
                 *      some of them may be cancelled by the browser and some by the
                 *      server with "HTTP 503 Too Many Requests"
                 *
                 *      To workaround this problem, Transport can keep requests
                 *      in a queue and send to the server up to a certain number
                 *      requests at a time.
                 *
                 * @param {Boolean} [supportsText=true]
                 *
                 *      Whether this client is able to accept messages in the plain text format.
                 *
                 * @param {Boolean} [supportsHtml=true]
                 *
                 *      Whether this client is able to accept messages in the HTML format.
                 *      If the client says that it can accept HTML messages, it should be
                 *      prepared to accept and parse incoming HTML messages and take care
                 *      of scripts that may be embedded into them. If the client is not
                 *      sophisticated enough to process such messages correctly, it can
                 *      tell the server that it accepts plain text only. Consider the
                 *      following code snippet that accepts html message and processes
                 *      them before inserting into the DOM tree:
                 *
                 *          client.conversations(0).chatService.messages.added(function (message) {
                 *              var unsafeHtml = message.html();
                 *              var safeHtml = preprocessHtml(unsafeHtml);
                 *              $("#message5").html(safeHtml);
                 *          });
                 *
                 *      Consider another code snippet in which a client is not able
                 *      to process html messages correctly and thus for security reasons
                 *      it reads text only:
                 *
                 *          client.conversations(0).chatService.messages.added(function (message) {
                 *              var safeText = message.text();
                 *              $("#message5").text(safeText);
                 *          });
                 *
                 * @param {Boolean} [supportsMessaging=true]
                 *
                 *      Tells whether the client can accept incoming messaging requests.
                 *
                 * @param {Boolean} [supportsAudio=true]
                 *
                 *      Tells whether the client can accept incoming audio calls.
                 *
                 * @param {Boolean} [supportsVideo=true]
                 *
                 *      Tells whether the client can accept incoming video calls.
                 *
                 * @param {Boolean} [supportsSharing=true]
                 *
                 *      Tells whether the client can accept incoming screen sharing requests.
                 *
                 * @param {String} [culture="en-us"]
                 *
                 *      The UCWA server will localize some strings (for example error messages)
                 *      in the given language.
                 *
                 * @param {String} [version]
                 *
                 *      The version of the client that registers an endpoint on the UCWA server.
                 *      This version will be added to the SDK's version.
                 *
                 * @param {Number} [maxBatchSize=20]
                 *
                 *      By default our UCWA stack queues all requests and sends them in batches. This parameter
                 *      changes the default batch size of 20 (the UCWA-defined upper limit). If the parameter
                 *      value is higher than the default, the batch size is reset to default. Note that if the
                 *      stack sent batches with over 20 requests these batches would be rejected by UCWA. The stack
                 *      layer does not have any logic to handle this: the model layer will just find that all
                 *      requests sent in that batch failed.
                 *
                 * @param {Number} [presenceSubscriptionsBatchSize=75]
                 *
                 *      To subscribe to presence of several contacts SkypeWeb sends one POST to
                 *      rel=presenceSubscriptions. In the default configuration, UCWA doesn't
                 *      accept more than 75 contact URIs in one request.
                 *
                 * @param {Number} [presenceSubscriptionDuration=11]
                 *
                 *      One presence subscription (which may contain several contact URIs)
                 *      automatically expires after a period given by the client. By default
                 *      SkypeWeb creates every subscription for 11 minutes and then extends it
                 *      by another 11 minutes and so on.
                 *
                 * @param {Dictionary} [snapshot] - Snapshot previously returned by getSnapshot.
                 *
                 *      Tells the client to skip the regular sign in process and use the given
                 *      snapshot of a UCWA endpoint. The snapshot is a set of UCWA resources
                 *      that are required to reconnect to an existing UCWA endpoint. This minimum
                 *      set of resources includes:
                 *
                 *          - rel=application - This is the id of the UCWA endpoint.
                 *          - rel=xframe - This is the transport that allows the client to communicate with UCWA.
                 *          - rel=applications - Used for constructing URLs of contact photos.
                 *
                 *      The snapshot does not contain any authentication related information as it's
                 *      possible to sign in with one auth flow, take a snapshot, create another client,
                 *      tell it to sign in via a different auth flow and use that snapshot:
                 *
                 *          // use IWA to get the web ticket
                 *          client1.signIn({ domain: "contoso.com" });
                 *          ...
                 *
                 *          snapshot1 = client1.getSnapshot();
                 *          sessionStorage.setItem("snapshot", JSON.stringify(snapshot1));
                 *          ...
                 *
                 *          snapshot1 = JSON.parse(sessionStorage.getItem("snapshot"));
                 *          client2 = new Application({ snapshot: snapshot1 });
                 *
                 *          // use basic authentication to get the web ticket
                 *          client2.signIn({ username: "...", password: "..." });
                 *
                 *      The API allows to switch users between these two sessions: to take a snapshot from user A
                 *      and then try to reconnect to the same UCWA endpoint on behalf of user B. The server rejects
                 *      such attempts with HTTP 502 saying that "Policy prevents request from being proxied."
                 */
                var cmdSignIn = defineAsyncCommand([Application.State.SignedOut], function (options) {
                    record('SignIn');
                    if (options.meeting) {
                        if (!options.name)
                            throw EInvalidArgument('name', 'Default display name in anonymous meetings is required.');
                        guestName(options.name);
                    }
                    state(Application.State.SigningIn);
                    // ucwa should have been uninitialized already and thus
                    // a call to .init(...) shouldn't throw any exceptions
                    dfdSignedIn = ucwa.init(options).then(function () {
                        state(Application.State.SignedIn);
                    }, function (err) {
                        state(Application.State.SignedOut, err);
                        throw err;
                    });
                    return dfdSignedIn;
                });
                //#endregion
                //#region signOut
                var cmdSignOut = defineAsyncCommand(keys(Application.State), function () {
                    record('SignOut');
                    switch (state()) {
                        case Application.State.SignedOut:
                            return; // already signed out
                        case Application.State.SigningIn:
                            dfdSignedIn.cancel(Exception('SignedOut'));
                            // suppress all errors as signout must always succeed
                            return dfdSignedIn.catch();
                        case Application.State.SigningOut:
                            return dfdSignedOut;
                        case Application.State.SignedIn:
                            state(Application.State.SigningOut);
                            // even though the DELETE request may fail,
                            // the client still goes to the signed-out state,
                            // because otherwise the client won't be usable at all
                            dfdSignedOut = ucwa.send('DELETE', { rel: 'application' }).then(function (res) {
                                state(Application.State.SignedOut);
                                return res;
                            }, function (err) {
                                state(Application.State.SignedOut, err);
                                throw err;
                            });
                            return dfdSignedOut;
                    }
                });
                //#endregion
                //#region startMessaging
                /**
                 * Starts an IM conversation with a given participant.
                 *
                 * @param {String} to - SIP URI of the participant.
                 * @param {String} [message=""]
                 * @param {String} [priority="Normal"]
                 * @param {String} [topic=""]
                 * @param [context]
                 *
                 * @returns {Promise<Conversation>}
                 *
                 * @example
                 *
                 *      client.startMessaging({
                 *          to: 'sip:johndoe@contoso.com',
                 *          message: 'How are you?',
                 *          topic: 'A very important conversation',
                 *          priority: 'Urgent'
                 *      }).then(function (conversation) {
                 *          console.log('conversation started');
                 *          return conversation.chatService.sendMessage('Hi!');
                 *      }).then(function () {
                 *          console.log('IM sent');
                 *      });
                 */
                var cmdStartMessaging = defineAsyncCommand([Application.State.SignedIn], function (options) {
                    var conversation = client.createConversation({
                        isConference: false,
                        topic: options.topic,
                        priority: options.priority,
                        threadId: options.threadId
                    });
                    var messaging = conversation.chatService;
                    return messaging.start({
                        to: options.to,
                        message: options.message,
                        context: options.context,
                        // these are given by unit tests:
                        boundary: options.boundary,
                        operationId: options.operationId,
                        sessionContext: options.sessionContext
                    }).then(function () {
                        return conversation;
                    });
                });
                //#endregion
                //#region startAudioVideo
                /**
                 * Starts an audio/video call with a given participant.
                 *
                 * @param {String} to - SIP URI of the participant.
                 * @param {Dictionary} [video] - If present start an audio/video call, otherwise start just an audio call.
                 *
                 *      {HTMLElement} container - parent DOM element for video window
                 *
                 * @returns {Promise<Conversation>}
                 *
                 * @example
                 *
                 *      // start audio
                 *      client.startAudioVideo({
                 *          to: 'sip:johndoe@contoso.com'
                 *      }).then(function (conversation) {
                 *          console.log('audio started');
                 *          conversation.audioService.stop();
                 *      }).then(function () {
                 *          console.log('audio stopped');
                 *      });
                 *
                 *      // start audio and video
                 *      client.startAudioVideo({
                 *          to: 'sip:johndoe@contoso.com',
                 *          video: { container: document.getElementById('myVideoWindowContainer') }
                 *      });
                 */
                var cmdStartAudioVideo = defineAsyncCommand([Application.State.SignedIn], function (options) {
                    var conversation = client.createConversation({
                        isConference: false,
                        threadId: options.threadId
                    });
                    var dfd = options.video ?
                        conversation.videoService.start(options) :
                        conversation.audioService.start(options);
                    return dfd.then(function () {
                        return conversation;
                    });
                });
                //#endregion
                //#region startAppSharing
                /**
                 * Starts an app-sharing call with a given participant.
                 *
                 * @param {String} to - SIP URI of the participant.
                 * @param {ShareableWindow} window - Window resource to share
                 * @param {ShareableMonitor} monitor - Monitor resource to share
                 * @param {HTMLElement} container - DOM element used for viewing shared content
                 *
                 * @returns {Promise<Conversation>}
                 *
                 * @example
                 *
                 *      // start app-sharing
                 *      client.startAppSharing({
                 *          to: 'sip:johndoe@contoso.com',
                 *          window: window,
                 *          monitor: monitor,
                 *          container: document.getElementById('appSharingViewer')
                 *      }).then(function (conversation) {
                 *          console.log('app-sharing started');
                 *          var appSharing = conversation.modalities('AppSharing');
                 *          appSharing.stop();
                 *      }).then(function () {
                 *          console.log('app-sharing stopped');
                 *      });
                 */
                var cmdStartAppSharing = defineAsyncCommand([Application.State.SignedIn], function (options) {
                    var conversation = client.createConversation({
                        isConference: false,
                        threadId: options.threadId
                    });
                    var as = conversation.addModality(Conversation.ModalityType.AppSharing);
                    return as.start(options).then(function () {
                        return conversation;
                    });
                });
                //#endregion
                //#region startMeeting
                /**
                 * Creates an online meeting. The created meeting is represented by a
                 * Conversation model with an OnlineMeeting model inside. The created
                 * conversation does not have any modalities, so needed modalities
                 * need to be added first and then needed participants need to be
                 * brought into the meeting:
                 *
                 *      client.startMeeting({
                 *          topic: 'A very important meeting.',
                 *          priority: 'Urgent'
                 *      }).then(function (conversation) {
                 *          conversation.addParticipant('sip:user1@contoso.com');
                 *          conversation.addParticipant('sip:user2@contoso.com');
                 *          conversation.addParticipant('sip:user3@contoso.com');
                 *      });
                 *
                 * Note, that modalities have to be added before participants.
                 * The created conversation has the messaging modality, so it can
                 * be used to send and receive messages right away. To join an existing
                 * meeting with a known URI, specify the "uri" parameter:
                 *
                 *      client.startMeeting({
                 *          uri: "sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:WHBSYO8R"
                 *      }).then(function (conversation) {
                 *          var text = "Hi everybody! I'm " + client.personsAndGroupsManager.mePerson.name() + ".";
                 *          conversation.chatService.sendMessage(text);
                 *      });
                 *
                 * @param {String} [topic=""]
                 * @param {String} [priority="Normal"]
                 * @param {String} [uri] - The URI of an existing meeting to join.
                 * @param {String} [name] - The guest name when joining an online meeting anonymously.
                 *
                 * @returns {Promise<Conversation>}
                 */
                var cmdStartMeeting = defineAsyncCommand([Application.State.SignedIn], function (options) {
                    options = options || {};
                    var conversation = client.createConversation({
                        topic: options.topic,
                        priority: options.priority,
                        threadId: options.threadId
                    });
                    return conversation.addMeeting().start({
                        uri: options.uri,
                        name: options.name
                    }).then(function () {
                        return conversation.chatService.start();
                    }).then(function () {
                        return conversation;
                    });
                });
                //#endregion
                //#region createConversation
                /**
                 * The created conversation has a unique threadId permanently
                 * associated with this conversation. If, however, a subsequent
                 * request to startMessaging/startAudioVideo/etc. fails, the same
                 * id cannot be reused in other calls and thus, despite the conversation
                 * doesn't disappear from the collection, it's essentially ended
                 * and cannot be reused.
                 *
                 * TODO: Maybe a conversation needs to be able to change its id?
                 */
                var cmdCreateConversation = defineCommand([Application.State.SignedIn], function (options) {
                    return conversationsManager.createConversation(options);
                });
                //#endregion
                //#region scheduleMeeting
                /**
                 * Schedules an online meeting. The created meeting is represented by a MyOnlineMeeting
                 * model containing observable properties. The returned model can be used with startMeeting
                 * to start/join the meeting. All parameters are optional:
                 *
                 *      client.scheduleMeeting().then(function (meeting) {
                 *          return client.startMeeting({
                 *              uri: meeting.onlineMeetingUri()
                 *          });
                 *      }).then(function (conversation) {
                 *          return conversation.chatService.sendMessage("Hello");
                 *      });
                 *
                 * @param {String} [accessLevel] - Controls who is let into the meeting.
                 *
                 *  - Everyone
                 *  - Invited - Only users in the attendees/leaders, all others are put in the lobby.
                 *  - Locked - All users except the organizer are put into the lobby.
                 *  - SameEnterprise - Only users from the same enterprise, all others are put in the lobby.
                 *
                 * @param {Array<String>} [attendees] - SIP URIs of users to include as attendees.
                 * @param {String} [automaticLeaderAssignment] - Which participants are automatically promoted to leaders.
                 *
                 *  An online meeting organizer can schedule a meeting so that users are automatically promoted
                 *  to the leader role when they join the meeting. For example, if the meeting is scheduled with
                 *  automatic promotion policy set to "SameEnterprise", then any participants
                 *  from the organizer's company are automatically promoted to leaders when they join the meeting.
                 *  Conference leaders can still promote specific users to the leader role, including anonymous users.
                 *
                 * @param {String} [description] - Purpose of the meeting
                 * @param {String} [entryExitAnnouncement] - The attendance announcements status for the online meeting.
                 *
                 *  When attendance announcements are enabled, the online meeting will announce the names
                 *  of the participants who join the meeting through audio.
                 *
                 * @param {Date} [expirationTime] - The UTC date and time after which the online meeting can be deleted.
                 *
                 *  The day and time must be between one year before, and ten years after,
                 *  the current date and time on the server. If the expiration time is specified,
                 *  it must point to a moment in the future. Consider this example that schedules a meeting
                 *  valid for one day:
                 *
                 *      client.scheduleMeeting({
                 *          expirationTime: new Date(+new Date + 24 * 60 * 60 * 1000)
                 *      });
                 *
                 * @param {Array<String>} [leaders] - Array of SIP URIs of users to include as leaders.
                 *
                 *  The organizer will automatically be added to the leaders list.
                 *
                 * @param {String} [lobbyBypassForPhoneUsers] - When enabled phone users will skip the meeting lobby.
                 * @param {String} [phoneUserAdmission] - Whether participants can join the online meeting over the phone.
                 *
                 *  Setting this property to true means that online meeting participants can join the meeting
                 *  over the phone through the Conferencing Auto Attendant (CAA) service.
                 *
                 * @param {String} [subject] - The subject of the online meeting.
                 *
                 * @returns {Promise<MyOnlineMeeting>}
                 */
                var cmdScheduleMeeting = defineAsyncCommand([Application.State.SignedIn], function (options) {
                    options = options || {};
                    return ucwa.send('POST', { rel: 'myOnlineMeetings' }, {
                        data: {
                            accessLevel: options.accessLevel,
                            attendees: options.attendees,
                            automaticLeaderAssignment: options.automaticLeaderAssignment,
                            description: options.description,
                            entryExitAnnouncement: options.entryExitAnnouncement,
                            expirationTime: options.expirationTime && options.expirationTime.toJSON(),
                            leaders: options.leaders,
                            lobbyBypassForPhoneUsers: options.lobbyBypassForPhoneUsers,
                            phoneUserAdmission: options.phoneUserAdmission,
                            subject: options.subject
                        }
                    }).then(function (r) {
                        return MyOnlineMeeting(ucwa, { source: r.href });
                    });
                });
                //#endregion
                //#region getSnapshot
                var cmdGetSnapshot = defineCommand([Application.State.SignedIn], function () {
                    return ucwa.getSnapshot();
                });
                //#endregion
                Application[sInstances].push(client);
                init();
                return extend(client, {
                    signInManager: Model({
                        state: state.asReadOnly(),
                        createPasswordSignInParameter: EnabledCommand(function (x) { return x; }),
                        createImplicitOAuthSignInParameter: EnabledCommand(function (x) { return x; }),
                        signIn: cmdSignIn,
                        signOut: cmdSignOut
                    }),
                    startMessaging: cmdStartMessaging,
                    startAudioVideo: cmdStartAudioVideo,
                    startAppSharing: cmdStartAppSharing,
                    startMeeting: cmdStartMeeting,
                    createConversation: cmdCreateConversation,
                    scheduleMeeting: cmdScheduleMeeting,
                    getSnapshot: cmdGetSnapshot,
                    conversationsManager: conversationsManager
                });
            }
            Model_1.Application = Application;
            // the app may not want to make these apps accessible to anyone,
            // so to expose this array in the debugging console and yet to
            // not break encapsulation, the array is accessible at a hidden
            // symbol which can be read manually in the dev console, but cannot
            // be read programmatically; note, that in unit tests symbols are
            // plain strings, so tests can access this property directly
            setHiddenProperty(Application, sInstances, []);
            var Application;
            (function (Application) {
                Application.State = StringEnum('SignedOut', 'SignedIn', 'SigningOut', 'SigningIn');
            })(Application = Model_1.Application || (Model_1.Application = {}));
            //#endregion Application
            var Internal;
            (function (Internal) {
                //#region SignInManager
                /**
                 * Encapsulates various auth flows.
                 *
                 * @property {Application.State} state
                 *
                 *      The following code can be used to invoke a particular function whenever
                 *      the client signs in:
                 *
                 *          client.signInManager.state.when("SignedIn", function () {
                 *              console.log("The client has signed in");
                 *          });
                 *
                 *      To determine the reason of being signed out, check Property#reason:
                 *
                 *          client.signInManager.state.when("SignedOut", function (reason) {
                 *              console.log("The client has signed out because " + reason);
                 *              console.log("The client has signed out because " + sm.state.reason);
                 *          });
                 *
                 *      Typically state.reason.code = "ConnectionLost" which indicates
                 *      that the client has lost the event channel connection with UCWA.
                 *
                 * @command {Promise} signIn - Signs in a user with given credentials.
                 *
                 *      To sign in via the basic auth, specify the user name and password in plain text:
                 *
                 *          client.signIn({
                 *              username: 'user1@company.com',
                 *              password: 'password1'
                 *          }).then(function () {
                 *              console.log('Signed in as ' + client.personsAndGroupsManager.mePerson.name());
                 *          });
                 *
                 *      To sign in via IWA and make the browser show a credentials popup specify the domain FQDN:
                 *
                 *          client.signIn({
                 *              domain: 'company.com'
                 *          }).then(function () {
                 *              console.log('Signed in as ' + client.personsAndGroupsManager.mePerson.name());
                 *          });
                 *
                 *      To skip the auto-discovery step specify URLs of rel=user nad rel=xframe UCWA resources:
                 *
                 *          client.signIn({
                 *              auth: OAuth(...),
                 *              root: {
                 *                   user: 'https://lyncweb.company.com/.../user?originalDomain=company.com',
                 *               xframe: 'https://lyncweb.company.com/.../XFrame.html'
                 *               }
                 *          }).then(function () {
                 *                  console.log('Signed in as ' + client.personsAndGroupsManager.mePerson.name());
                 *              });
                 *
                 *      To join an online meeting anonymously specify the meeting URI:
                 *
                 *          client.signIn({
                 *              meeting: "sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:QHJ72TKK"
                 *          }).then(function () {
                 *              console.log("Signed in as " + client.personsAndGroupsManager.mePerson.uri());
                 *          });
                 *
                 *      To sign in via the implicit auth specify the client_id:
                 *
                 *          client.signIn({
                 *              client_id: '123-456',
                 *              oauth_uri: 'https://login.windows-ppe.net/common/oauth2/authorize',
                 *              origins: [{
                 *                  origin: 'https://webdir.tip.lync.com/AutoDiscover/AutoDiscoverservice.svc/root?originalDomain=contoso.com',
                 *                  xframe: 'https://webdir.tip.lync.com/xframe'
                 *              }]
                 *          });
                 *
                 *      To specify a custom authentication function specify the `auth` parameter:
                 *
                 *          client.signIn({
                 *              root: {
                 *                  user: 'https://lyncweb.company.com/.../user?originalDomain=company.com',
                 *                  xframe: 'https://lyncweb.company.com/.../XFrame.html'
                 *              },
                 *              auth: function (request, ajax) {
                 *                  request.headers["Authorization"] = "Bearer cwt=ABC"; // somehow get the web ticket
                 *                  return ajax(request); // this thing returns a promise, so the web ticket may be obtained asynchronously
                 *              }
                 *          });
                 *
                 *      To connect to an existing app's event channel, specify id of that app:
                 *
                 *          client.signIn({
                 *              username: "user1@company.com",
                 *              password: "password1",
                 *              id: "273867-234235-45346345634-345"
                 *          });
                 *
                 * @command {Promise} signOut - Signs out the signed-in user.
                 *
                 *      Signs out by deleting the application resource.
                 *      Cancels the sign in operation if it's pending.
                 *
                 *           client.signOut().then(function () {
                 *               console.log('Signed out');
                 *           });
                 */
                function SignInManager() {
                    // it's used as a placeholder for the jsdoc comment
                }
                //#endregion SignInManager
                //#region GeneralPolicies
                /**
                 * Wraps the rel=policies resource into an observable model.
                 *
                 * rel=policies represents the admin policies that can apply to a user's application.
                 * Policies include information such as whether emoticons are allowed in messages
                 * or photos are enabled for contacts in the user's organization. Note that policies
                 * are set by the admin; they cannot be changed by the user.
                 *
                 * @property callLogArchiving - Whether the admin has enabled client-side call logging by default.
                 *
                 *      If disabled, the user should not be given the choice to enable call logging.
                 *
                 * @property customerExperienceImprovementProgram - Whether Lync mobile users can participate and publish data to Microsoft's CEIP.
                 *
                 *      If customerExperienceImprovementProgram is enabled, the user can participate
                 *      and publish data to Microsoft's Customer Experience Improvement Program. Note that
                 *      this should not require a change in application behavior.
                 *
                 * @property emergencyDialMask - An alternate number for emergency services.
                 *
                 *      If emergencyDialMask is set to 555 and the emergencyDialString is set to 911,
                 *      entering 555 will cause 911 to be dialed. Note that entering 911 will also cause
                 *      911 to be dialed in this scenario.
                 *
                 * @property emergencyDialString - The emergency services number that will be dialed if the number in emergencyDialMask is entered.
                 *
                 *      If emergencyDialMask is set to 555 and the emergencyDialString is set to 911,
                 *      entering 555 will cause 911 to be dialed. Note that entering 911 will also cause
                 *      911 to be dialed in this scenario.
                 *
                 * @property emoticons - Whether the admin has enabled emoticons for the messaging modality.
                 *
                 *      If disabled, emoticons will be turned into their text equivalents before delivery.
                 *
                 * @property clientExchangeConnectivity - This mobile policy parameter allows the mobile user to connect to Exchange from their mobile device.
                 *
                 *      When ExchangeConnectivity is disabled, mobile users will not have the option to connect
                 *      to Exchange from their client on the mobile device. The default value is True, meaning
                 *      that mobile users cannot connect to Exchange from their client on the mobile device. Disabled
                 *
                 * @property exchangeUnifiedMessaging - Whether the user is enabled for Microsoft Exchange Unified Messaging.
                 *
                 *      If exchangeUnifiedMessaging is enabled, the user's contacts and voicemail are stored
                 *      in Exchange rather than in Lync. Note that this should not require a change in application behavior.
                 *
                 * @property htmlMessaging - Whether the admin has enabled HTML messages for the messaging modality.
                 *
                 *      If enabled, the application can choose to pass HTML to ChatService::sendMessage.
                 *
                 * @property logging - Whether the admin has enabled client-side logging by default.
                 *
                 *      If enabled, the user should not be given the choice to disable logging.
                 *      If disabled, the user should be given the choice to enable logging.
                 *
                 * @property loggingLevel - The level of client-side logging that the admin expects, e.g. "Light"
                 * @property messageArchiving - Whether the admin has enabled the archival of client-side message transcripts by default.
                 *
                 *      If disabled, the user should not be given the choice to enable message transcript archival.
                 *
                 * @property messagingUrls - Whether the admin has enabled clickable URLs for the messaging modality.
                 * @property multiViewJoin
                 * @property photos - Whether photos are enabled for all contacts in this organization.
                 * @property saveCallLogs - This mobile policy parameter allows saving the call logs on mobile device.
                 *
                 *      When SavingCallLogs is disabled, call logs will not be saved locally on the mobile device.
                 *      The default value is True, meaning that call logs can be saved locally on mobile device.
                 *
                 * @property saveCredentials - This mobile policy parameter allows the mobile user to save their credentials locally.
                 *
                 *      If savingCredentials is disabled, the user will not have the option to save his credentials
                 *      locally on the mobile device. The default value is Enabled, meaning that user is allowed
                 *      to save his credentials.
                 *
                 * @property saveMessagingHistory - Allows saving the history of IM exchanged from the mobile device.
                 *
                 *      If savingInstantMessagingHistory is disabled, IM history will not be saved locally on the mobile device.
                 *      The default value is True, meaning that IM history can be saved locally on mobile device.
                 *
                 * @property onlineFeedbackUrl - e.g. "https://go.microsoft.com/fwlink/?LinkID=232691"
                 * @property sendFeedbackUrl - e.g. "https://input.microsoft.com/bits/"
                 * @property softwareQualityMetrics - Whether the admin has enabled software quality metrics.
                 *
                 *      Software quality metrics are anonymous metrics used by Microsoft to improve the product.
                 *
                 * @property telephonyMode - Indicates which audio capabilities are possible for this user.
                 *
                 *      This is an advanced API that indicates more granular capabilities including
                 *      whether the user can make a PSTN call. For instance this policy can equal to "Uc".
                 *
                 * @property voicemailUri - The URI to call to check the user's voicemail, e.g. "sip:johndoe@contoso.com;opaque=app:voicemail"
                 *
                 * @property audioOnlyOnWifi
                 * @property videoOnlyOnWifi
                 * @property sharingOnlyOnWifi
                 *
                 */
                function GeneralPolicies(ucwa) {
                    return Internal.ObservableResource(ucwa, {
                        source: { rel: 'policies' },
                        properties: {
                            audioOnlyOnWifi: {},
                            callLogArchiving: {},
                            customerExperienceImprovementProgram: {},
                            emergencyDialMask: {},
                            emergencyDialString: {},
                            emoticons: {},
                            clientExchangeConnectivity: {},
                            exchangeUnifiedMessaging: {},
                            htmlMessaging: {},
                            logging: {},
                            loggingLevel: {},
                            messageArchiving: {},
                            messagingUrls: {},
                            multiViewJoin: {},
                            onlineFeedbackUrl: {},
                            photos: {},
                            saveCallLogs: {},
                            saveCredentials: {},
                            saveMessagingHistory: {},
                            sendFeedbackUrl: {},
                            sharingOnlyOnWifi: {},
                            softwareQualityMetrics: {},
                            telephonyMode: {},
                            videoOnlyOnWifi: {},
                            voicemailUri: {}
                        }
                    });
                }
                Internal.GeneralPolicies = GeneralPolicies;
                //#endregion GeneralPolicies
                //#region MePerson
                /**
                 * Represents the currently signed-in user and is built on top of the "me" resource.
                 *
                 * @param {UCWA} ucwa
                 * @param {Boolean} supportsText
                 * @param {Boolean} supportsHtml
                 * @param {Boolean} supportsMessaging
                 * @param {Boolean} supportsAudio
                 * @param {Boolean} supportsVideo
                 * @param {Boolean} supportsSharing
                 * @param {Property<String>} [guestName]
                 *
                 * @property {String} id - SIP URI
                 * @property {String} displayName - Full name.
                 * @property {String} title - Work title.
                 * @property {String} department - Work department.
                 * @property {String} email - Alias to the first email address in the emails collection.
                 * @property {String} avatarUrl - URL of the photo.
                 * @property {String} note
                 *
                 *      It is important to understand that the .set method sends a request
                 *      to the server to change the value and after the request gets
                 *      accepted, the promise returned by .set gets resolved. The value
                 *      of the property does not change and it changes only after
                 *      the server sends an "updated" event. The reason for not changing
                 *      the local value is that the server aggregates different values from
                 *      multiple endpoints signed in as the same user and broadcasts the
                 *      aggregated value to all endpoints.
                 *
                 *      // to set a custom note
                 *      me.note.set({
                 *          type: 'Personal',
                 *          message: 'Gone fishing',
                 *      });
                 *
                 *      // the "type" parameter defaults to "Personal"
                 *      me.note('Gone fishing...');
                 *
                 *      // to set an out of office note for Exchange
                 *      me.note.set({
                 *          type: 'OutOfOffice',
                 *          message: 'On vacation until the end of January.',
                 *      });
                 *
                 *      // observe the status of the operation
                 *      me.note.set('Gone fishing...').then(
                 *          function () {
                 *              console.log('The request to change the note has been accepted by the server.');
                 *          }
                 *          function (error) {
                 *              console.log('The request to change the note has been rejected by the server.', error);
                 *          });
                 *
                 * @property {String} location
                 *
                 *      It is important to understand that the .set method sends a request
                 *      to the server to change the value and after the request gets
                 *      accepted, the promise returned by .set gets resolved. The value
                 *      of the property does not change and it changes only after
                 *      the server sends an "updated" event. The reason for not changing
                 *      the local value is that the server aggregates different values from
                 *      multiple endpoints signed in as the same user and broadcasts the
                 *      aggregated value to all endpoints.
                 *
                 *      // to change the location text
                 *      me.location('At home.');
                 *
                 * @property {String} status - This property represents the availability of MePerson.
                 *
                 *      The status property usually takes the following values:
                 *          'Online': the user is online (available).
                 *          'Offline': the user is offline (unavailable).
                 *          'Away': the user is away (unavailable)
                 *          'BeRightBack': the user is away (unavailable) but will be back soon.
                 *          'Busy': the user is busy but is reachable.
                 *          'DoNotDisturb': the user is busy and is not reachable.
                 *          'IdleOnline': a user has not been active on her device but is available to communicate.
                 *          'IdleBusy': a user has not been active on her device and is busy.
                 *
                 *      To change the status, invoke the set method of the property:
                 *
                 *          me.status.set("Online");
                 *
                 *      It is safe to invoke this setter multiple times and even mix it with calls
                 *      to other related properties, such as me.activity, because the actual
                 *      POST request is sent at the next event loop and multiple requests are
                 *      merged before sending the final value.
                 *
                 *      It is important to understand that the .set method sends a request
                 *      to the server to change the value and after the request gets
                 *      accepted, the promise returned by .set gets resolved. The value
                 *      of the property does not change and it changes only after
                 *      the server sends an "updated" event. The reason for not changing
                 *      the local value is that the server aggregates different values from
                 *      multiple endpoints signed in as the same user and broadcasts the
                 *      aggregated value to all endpoints.
                 *
                 *      The availability cannot be "Offline". A request to change the availability
                 *      to "Offline" will be rejected by the server with a HTTP 400 Bad Request.
                 *
                 *      After changing the availability to "Away" it is still possible to monitor
                 *      the status of other contacts.
                 *
                 * @property {String} activity - Contains a user-defined text describing the user activity.
                 *
                 *      To change the activity, invoke the set method of the property:
                 *
                 *          me.activity.set("Fishing");
                 *
                 *      It is safe to invoke this setter multiple times and even mix it with calls
                 *      to other related properties, such as me.status, because the actual
                 *      POST request is sent at the next event loop and multiple requests are
                 *      merged before sending the final value.
                 *
                 * @property {String} endpointType
                 * @property {Date} lastSeenAt
                 *
                 * @property {Boolean} available - Whether the endpoint is ready to receive IMs and AV calls.
                 *
                 *      Initially this property is set to "false" and it becomes "true" after
                 *      UCWA processes the POST rel=makeMeAvailable request and all other requests
                 *      required to make the endpoint available for receiving incoming IMs and AV calls.
                 *      An app can wait for this property and display something in the UI when it changes its value:
                 *
                 *          me.available.changed(function(){
                 *              if (me.available())
                 *                  displayTheMeCardAsOnline();
                 *          });
                 *
                 *      If me.available is not set, it is possible to set it: this will result in
                 *      sending the POST to rel=makeMeAvailable and all other steps necessary to
                 *      publish the presence of this SkypeWeb endpoint and to enable it accept incoming
                 *      AV, IM or AS invitations. This property is set internally by the client
                 *      object at a right moment (after sign in).
                 *
                 * @property {Boolean} active - Whether the client periodically reports activity.
                 *
                 *      The client reports activity by sending a POST request to the server
                 *      every 3 minutes. Without such periodic polling the server deletes
                 *      the endpoint. Reporting activity can be stopped at your own risk:
                 *
                 *          me.active.set(false);
                 *
                 *      A possible negative effect of stopping reporting the activity is that
                 *      after 3-4 minutes the server will send an "application deleted" event
                 *      and will terminate the event channel.
                 *
                 * @property {Boolean} supportsHtml - Whether this endpoint is able to accept html messages.
                 * @property {Boolean} supportsText - Whether this endpoint is able to accept text messages.
                 * @property {Boolean} supportsMessaging - Whether this endpoint is able to accept messaging requests.
                 * @property {Boolean} supportsAudio - Whether this endpoint is able to accept audio calls.
                 * @property {Boolean} supportsVideo - Whether this endpoint is able to accept video calls.
                 * @property {Boolean} supportsSharing - Whether this endpoint is able to accept screen sharing requests.
                 *
                 * @member {Capabilities} capabilities - Communication capabilities of the MePerson.
                 *
                 *      Capabilities is an object containing the following sub-properties (all of
                 *      which contain boolean flags indicating whether the MePerson is capable of
                 *      communicating using certain modalities). Most of these values are retrieved
                 *      from the "supportsXXXX" properties:
                 *
                 *          chat: whether the person is capable of chat (supportMessaging).
                 *          audio: whether the person is capable of audio (supportAudio).
                 *          video: whether the person is capable of video (supportVideo).
                 *          screenSharing: whether the person is capable of screen sharing (supportSharing).
                 *          dataCollaboration: whether the person is capable of data collaboration (currently no match in UCWA).
                 *
                 *      var modalities = me.capabilities;
                 *      if (!modalities.audio())
                 *          console.log("audio not supported");
                 *
                 * @collection {Email} emails - all email addresses.
                 *
                 *      Each element of this collection is an Email object with two
                 *      properties:
                 *          type: the type of this email address
                 *                (valid values are: 'Personal', 'Work', 'Other')
                 *          emailAddress: the email address as a string
                 *
                 * @collection {Phone} phoneNumbers - all phone numbers
                 *
                 *      Each element of this collection is a Phone object with three
                 *      properties:
                 *          type: the type of this phone
                 *                (valid values are: 'home', 'work', 'mobile', 'other')
                 *          telUri: the tel uri of this phone
                 *          displayString: the display string of this phone
                 *
                 * @method {Subscription} subscribe - Subscribe to all properties that have been observed.
                 *
                 *      This method should be invoked if the user needs to have the up to date
                 *      values of all the properties that have registered an observer.
                 *
                 *          me.id.changed(fn1);
                 *          me.status.changed(fn2);
                 *          me.location.changed(fn3);
                 *          me.note.text.changed(fn4);
                 *          var sub = me.subscribe();
                 *
                 */
                function MePerson(ucwa, options) {
                    var supportsText = options && !!options.supportsText;
                    var supportsHtml = options && !!options.supportsHtml;
                    var supportsMessaging = options && !!options.supportsMessaging;
                    var supportsAudio = options && !!options.supportsAudio;
                    var supportsVideo = options && !!options.supportsVideo;
                    var supportsSharing = options && !!options.supportsSharing;
                    var supportsConferencing = options && options.supportsConferencing ||
                        ConstProperty(false);
                    var guestName = options && options.guestName;
                    var eReconnecting = Exception('Reconnecting');
                    var dfdGet; // it's tracking the GET rel=me requests
                    var State = Enum('Unavailable', 'Available');
                    var sm = SequentialStateMachine(State.Unavailable);
                    var requests = {}; // requests.note = a GET for /me/note
                    var properties = {};
                    var proto = Model();
                    var self = inherit(proto);
                    options = null; // reduce the scope of "options" to the initialization part
                    var dfdrMe = ucwa.init().then(function () {
                        return ucwa.get({ rel: 'me' });
                    });
                    sm.defineState(State.Available, function () {
                        return makeMeAvailable().then(function () {
                            startReportingActivity();
                            // every time ucwa fails and then gets restored,
                            // most of the state, including the availability,
                            // disappears and needs to be recreated
                            ucwa.restored(function () {
                                available(false, eReconnecting);
                                makeMeAvailable().then(function () {
                                    available(true);
                                });
                            });
                            ucwa.connected.when(false, function () {
                                available(false);
                            });
                        });
                    });
                    //#region properties
                    defineProperty('id', {
                        source: 'uri'
                    });
                    defineProperty('displayName', {
                        source: 'name'
                    });
                    defineProperty('title', {
                        source: 'title'
                    });
                    defineProperty('department', {
                        source: 'department'
                    });
                    defineProperty('emails', {
                        source: 'emailAddresses',
                        isCollection: true,
                        parse: function (value) {
                            return map(value || [], function (email) {
                                return Model({
                                    type: ConstProperty(null),
                                    emailAddress: ConstProperty(email)
                                });
                            });
                        }
                    });
                    defineProperty('email', {
                        source: 'emailAddresses',
                        parse: function (value) {
                            return value && value[0] || '';
                        }
                    });
                    self.phoneNumbers = defineLinkedProperty('phoneNumbers', {
                        source: 'phones',
                        isCollection: true,
                        parse: function (phones) {
                            return map(phones || [], function (phone) {
                                var p = phone.properties, type = p && p.type && p.type.charAt(0).toUpperCase() + p.type.slice(1);
                                return {
                                    type: ConstProperty(type),
                                    telUri: ConstProperty(p.number),
                                    displayString: ConstProperty(null)
                                };
                            });
                        },
                        fetchAll: function (r) {
                            return Task.waitAll(map(r.links('phone'), function (link) {
                                return ucwa.send('GET', link.href);
                            }));
                        }
                    });
                    self.note = Model({
                        text: defineLinkedProperty('note.text', {
                            source: 'note',
                            fetchOnce: true,
                            parse: function (data) {
                                return data && data.message;
                            },
                            compose: function (message) {
                                return message && message.message ? clone(message) :
                                    { message: message, type: self.note.type() || 'Personal' };
                            }
                        }),
                        type: defineLinkedProperty('note.type', {
                            source: 'note',
                            parse: function (data) {
                                return data && data.type;
                            }
                        }).asReadOnly()
                    });
                    self.location = defineLinkedProperty('location', {
                        source: 'location',
                        fetchOnce: true,
                        parse: function (data) {
                            return data && data.location;
                        },
                        compose: function (location) {
                            return { location: location };
                        }
                    });
                    // the location property contains a few sub-properties
                    // (they are not defined by UCWA but needed in jCafe)
                    extend(self.location, {
                        type: ConstProperty('Unknown'),
                        street: ConstProperty(null),
                        city: ConstProperty(null),
                        state: ConstProperty(null),
                        country: ConstProperty(null),
                        postalCode: ConstProperty(null)
                    });
                    self.status = defineLinkedProperty('status', {
                        source: 'presence',
                        value: 'Offline',
                        fetchOnce: true,
                        parse: function (object) {
                            return object ? object.availability : 'Offline';
                        },
                        compose: function (value) {
                            var object = {};
                            object.availability = value;
                            return object;
                        }
                    });
                    self.activity = defineLinkedProperty('activity', {
                        source: 'presence',
                        parse: function (object) {
                            return object && object.activity;
                        }
                    }).asReadOnly();
                    self.endpointType = defineLinkedProperty('endpointType', {
                        source: 'presence',
                        parse: function (object) {
                            return Person.fixDeviceType(object && object.deviceType);
                        }
                    }).asReadOnly();
                    self.isBlocked = ConstProperty(false);
                    self.lastSeenAt = defineLinkedProperty('lastSeenAt', {
                        source: 'presence',
                        parse: function (object) {
                            return object && timeStampToDate(object.lastActive);
                        }
                    }).asReadOnly();
                    self.note.reset = function () {
                        return sm.advanceTo(State.Available).then(function () {
                            return ucwa.send('POST', { rel: 'note' }, { data: {} });
                        });
                    };
                    self.status.reset = function () {
                        return sm.advanceTo(State.Available).then(function () {
                            return ucwa.send('POST', { rel: 'presence' }, { data: {} });
                        });
                    };
                    self.location.reset = function () {
                        return sm.advanceTo(State.Available).then(function () {
                            return ucwa.send('POST', { rel: 'location' }, { data: {} });
                        });
                    };
                    var photo = defineProperty('avatarUrl', {
                        source: 'photo'
                    });
                    var available = BoolProperty(false);
                    // whenever me.available.set(true) is invoked
                    // send a POST request to rel=makeMeAvailable and
                    // only then change the value of me.available
                    self.available = available.fork(function (newValue) {
                        // if this throws, the cached value won't be changed
                        if (available() && !newValue)
                            throw new Error('cannot downgrade the availability by calling me.available(false)');
                        if (!available() && newValue) {
                            return sm.advanceTo(State.Available).then(function () {
                                available(newValue);
                                return newValue;
                            });
                        }
                        // this value will be set to MePerson::available
                        return newValue;
                    });
                    self.active = BoolProperty(true);
                    self.supportsText = ConstProperty(supportsText);
                    self.supportsHtml = ConstProperty(supportsHtml);
                    self.supportsMessaging = ConstProperty(supportsMessaging);
                    self.supportsAudio = ConstProperty(supportsAudio);
                    self.supportsVideo = ConstProperty(supportsVideo);
                    self.supportsSharing = ConstProperty(supportsSharing);
                    // the capabilities object contains 5 sub-properties as an
                    // aggregated view of the supported modalities, and conferencing
                    // to indicate whether the person can join a conference.
                    self.capabilities = Model({
                        chat: self.supportsText,
                        audio: self.supportsAudio,
                        video: self.supportsVideo,
                        screenSharing: self.supportsSharing,
                        dataCollaboration: ConstProperty(undefined),
                        conferencing: supportsConferencing
                    });
                    //#endregion
                    //#region Internal Methods
                    //#region defineProperty
                    /**
                     * @param name - The desired name of the property in the MePerson model.
                     * @param options - An object with the following parameters:
                     * - source - The name of the property in the rel=me resource.
                     * - isCollection - A flag to indicate whether this is a Collection or Property.
                     * - parse
                     *
                     *      Takes the value from the resource and converts it to
                     *      a value that will be published in the model's properties.
                     *
                     * @returns {Property|Collection}
                     */
                    function defineProperty(name, options) {
                        assert(!self[name]);
                        var source = options && options.source;
                        var parse = options && options.parse || function (x) { return x; };
                        var property = (options && options.isCollection ? Collection : Property)({
                            get: function () {
                                // a user can legitimately write something like:
                                //
                                //      me.title.get().then(...);
                                //      me.name.get().then(...);
                                //      me.uri.get().then(...);
                                //      ...
                                //
                                // and will reasonably expect to see only one GET request
                                // to grab all these properties; dfdGet solves this case
                                if (!dfdGet) {
                                    dfdGet = ucwa.init().then(function () {
                                        return ucwa.send('GET', { rel: 'me' });
                                    }).finally(function () {
                                        dfdGet = null;
                                    });
                                }
                                return dfdGet.then(function () {
                                    return property();
                                });
                            }
                        });
                        properties[name] = property;
                        self[name] = property.asReadOnly();
                        dfdrMe.then(function (rMe) {
                            rMe.updated(function () {
                                if (rMe.has(source))
                                    property(parse(rMe.get(source)));
                            });
                            rMe.deleted(function () {
                                //reset properties when resource is deleted
                                property(parse(void 0));
                            });
                        });
                        return property;
                    }
                    //#endregion
                    //#region defineLinkedProperty
                    /**
                     * @param name - The desired name of the property in the MePerson model.
                     * @param type - The type name.
                     * @param source - The rel of the link in the rel=me resource.
                     *
                     * @param parse
                     *
                     *      Takes the value from the resource and converts it to
                     *      a value that will be published in the model's properties.
                     *
                     * @param compose
                     *
                     *      Takes the value from the model's property, when the view specifies the new value,
                     *      and converts it to a format that is acceptable by UCWA.
                     *
                     * @returns {Property}
                     */
                    function defineLinkedProperty(name, options) {
                        assert(!self[name]);
                        var rel = options.source;
                        var source = { rel: rel };
                        var parse = options.parse;
                        var compose = options.compose;
                        var fetchAll = options.fetchAll;
                        var fetchOnce = options.fetchOnce;
                        var expected = {};
                        var property = (options && options.isCollection ? Collection : Property)({
                            subscribed: subscribe,
                            value: options.value,
                            get: function () {
                                // The link appears only after the client sends a POST
                                // to rel=makeMeAvailable. However if the link is already
                                // available, don't send extra requests.
                                return ucwa.init().then(function () {
                                    return ucwa.exists(source) ?
                                        fetch() :
                                        subscribe();
                                });
                            },
                            set: function (value) {
                                if (value === expected) {
                                    expected = {};
                                    return value;
                                }
                                record(rel + '_set');
                                return sm.advanceTo(State.Available).then(function () {
                                    return post(rel, compose(value));
                                }).then(function () {
                                    // Leave the old value in the property.
                                    // It will be updated after the corresponding
                                    // "updated" event from the server.
                                    return property();
                                });
                            }
                        });
                        function set(value) {
                            expected = value;
                            property(value);
                            return value;
                        }
                        function fetch() {
                            // send the GET only once, even if it has been requested many times
                            requests[rel] = requests[rel] || ucwa.send('GET', source).finally(function () {
                                requests[rel] = null;
                            });
                            return requests[rel].then(function (r) {
                                return Task.wait(fetchAll ? fetchAll(r) : r.properties).then(parse).then(set);
                            });
                        }
                        function subscribe() {
                            return sm.advanceTo(State.Available).then(fetch);
                        }
                        ucwa.event(function (event) {
                            if (event.type in { updated: 1, added: 1 } && event.target && event.target.rel == source.rel)
                                fetch();
                            else if (event.type == 'deleted' && event.target && event.target.rel == source.rel) {
                                // reset properties when resource is deleted
                                set(parse(void 0));
                            }
                        });
                        ucwa.init().then(function () {
                            // The linked resource is there in two cases:
                            // 1. The app is being restored from a snapshot.
                            // 2. The app is connecting to an existing endpoint.
                            if (ucwa.exists(source)) {
                                if (!isEmptyObject(ucwa.get(source).properties)) {
                                    // If the linked resource contains some data, the app is being restored
                                    // from a snapshot and the value of the property can be taken from there.
                                    set(parse(ucwa.get(source).properties));
                                }
                                else if (fetchOnce) {
                                    // If the link is there, but the corresponding resource has no data,
                                    // then the app must be connecting to an existing endpoint. If this was
                                    // a regular sign in, the init sequence would be as following:
                                    //
                                    //      POST /applications
                                    //      POST /me/makeMeAvailable
                                    //      GET /me
                                    //
                                    //      me updated
                                    //      note added
                                    //      presence added
                                    //      location added
                                    //
                                    //      GET /me/note
                                    //      GET /me/presence
                                    //      GET /me/location
                                    //
                                    // When the app is forking an endpoint, UCWA gives an already initialized
                                    // endpoint and the sequence changes to:
                                    //
                                    //      POST /applications
                                    //
                                    // Because the returned /me already has /reportMyActivity, the app
                                    // doesn't need to POST /me/makeMeAvailable and UCWA wouldn't send
                                    // these "updated" and "added" events anyway. Instead, it gives an
                                    // already intialized /me resource with all the links: /note, /presence,
                                    // /location, /phones and so on. Since in the regular sign in the
                                    // data from these links are always fetched and since the point of SDK
                                    // is to hide differences between the two types of sign ins, it's reasonable
                                    // to fetch data from these links if the app is forking an endpoint.
                                    fetch();
                                }
                            }
                        });
                        properties[name] = property;
                        return property;
                    }
                    //#endregion
                    //#region post
                    /**
                     * Sends a POST to the given rel.
                     *
                     * The actual POST request at the next event loop to handle the case
                     * when the same or related properties are set multiple times. If this
                     * happens, conflicting requests are merged at the next event loop and
                     * only one POST request is sent.
                     *
                     * @param {String} rel
                     * @param {Object} data
                     *
                     * @returns {Promise}
                     */
                    function post(rel, data) {
                        var resource = ucwa.get({ rel: rel });
                        post[rel] = post[rel] || batched(function (values) {
                            var merged = clone(resource.properties);
                            foreach(values, function (v) {
                                extend(merged, v);
                            });
                            return ucwa.send('POST', { rel: rel }, {
                                data: merged,
                                nobatch: true
                            });
                        }, Infinity);
                        return post[rel](data, 0);
                    }
                    //#endregion
                    //#region makeMeAvailable
                    /**
                     * This lets other users see the presence of this user and
                     * also tells the server to send presence, location and note updates.
                     *
                     * @returns {Promise}
                     */
                    function makeMeAvailable() {
                        var isReconnecting = available.reason === eReconnecting;
                        var formats = [];
                        var modalities = [];
                        if (self.supportsText())
                            formats.push('Plain');
                        if (self.supportsHtml())
                            formats.push('Html');
                        if (self.supportsMessaging())
                            modalities.push('Messaging');
                        if (self.supportsAudio())
                            modalities.push('Audio');
                        if (self.supportsVideo())
                            modalities.push('Video');
                        if (self.supportsSharing())
                            modalities.push('ApplicationSharing');
                        return ucwa.init().then(function () {
                            // if the client is restoring its state from a snapshot,
                            // it must take into account that previously another client
                            // may have sent a POST to rel=makeMeAvailable and UCWA
                            // does not allow to send this request twice; so the intent here
                            // is to check whether that POST request was sent and if it was,
                            // don't send it again
                            if (isReconnecting || !ucwa.exists({ rel: 'reportMyActivity' })) {
                                // in the anonymous mode there is no rel=makeMeAvailable link
                                return ucwa.send('POST', { rel: 'makeMeAvailable' }, {
                                    data: { SupportedModalities: modalities, SupportedMessageFormats: formats },
                                    nobatch: true
                                }).then(function () {
                                    if (!isReconnecting)
                                        return ucwa.send('GET', { rel: 'me' }, { nobatch: true });
                                });
                            }
                        });
                    }
                    //#endregion
                    //#region startReportingActivity
                    /**
                     * To let the server know that the web client is active a POST
                     * request to the "reportMyActivity" resource must be sent every
                     * 3 minutes. Otherwise the user's availability will be changed
                     * to a less available status.
                     */
                    function startReportingActivity() {
                        var id = setInterval(function () {
                            if (self.active()) {
                                ucwa.send('POST', { rel: 'reportMyActivity' }, {
                                    nobatch: true
                                }).catch(function (err) {
                                    // After a long period of inactivity, the connection with UCWA is usually lost.
                                    // While the connection is being restored, MePerson resends POST /makeMeAvailable.
                                    // However this periodic timer doesn't know about that logic and keeps sending
                                    // POST /reportMyActivity as usual. If the timer happens to wake up before the
                                    // /makeMeAvailable is completed, UCWA will reject this /reportMyActivity with a
                                    // 409.MakeMeAvailableRequired error.
                                    if (err && err.code == 'RequestFailed' && err.rsp.status == 409)
                                        return;
                                    debug.log('%c reportMyActivity stopped', 'color:red;font-weight:bold', err);
                                    clearInterval(id);
                                    self.active(false, err);
                                });
                            }
                        }, 3 * 60 * 1000);
                    }
                    //#endregion
                    //#endregion Internal Methods
                    //#region initialization
                    if (guestName)
                        guestName.changed(properties.displayName);
                    dfdrMe.then(function (rMe) {
                        rMe = ucwa.get({ rel: 'me' });
                        setHiddenProperty(proto, Internal.sHref, rMe.href);
                        // the rel=me/photo link may appear after the ctor of MePerson was invoked:
                        // to handle this case MePerson needs to subscribe to rel=me and fetch the photo
                        // when the rel=me/photo link becomes available
                        rMe.updated(function fn() {
                            if (rMe.hasLink('photo') && !photo()) {
                                // no more events needed from rel=me
                                rMe.updated.off(fn);
                                // try to get the actual photo URL and if it's not possible,
                                // use the original href as the URL
                                Person.getPhotoUrl({
                                    ucwa: ucwa,
                                    path: rMe.link('photo').href
                                }).catch(function () {
                                    return rMe.link('photo').href;
                                }).then(function (url) {
                                    photo(url);
                                });
                            }
                        });
                    });
                    //#endregion
                    return extend(self, Person.prototype, {
                        // properties not defined by UCWA yet
                        firstName: ConstProperty(null),
                        lastName: ConstProperty(null),
                        office: ConstProperty(null)
                    });
                }
                Internal.MePerson = MePerson;
                //#endregion MePerson
                //#region Participant
                /**
                 * A participant represents a contact in a conversation.
                 *
                 * In large online meetings there may be hundreds of participants, so to
                 * reduce the network traffic the server sends as little information as
                 * possible. UI needs to choose a small subset of participants that are
                 * currently being displayed to the user and subscribe to only these
                 * participant models:
                 *
                 *      visibleParticipants.forEach(function (participantView) {
                 *          var participant = participantView.getModel();
                 *
                 *          // now subscribe to the participant
                 *          bindProperty(participant.admit.enabled, buttonAdmit);
                 *          bindProperty(participant.reject.enabled, buttonReject);
                 *      });
                 *
                 * A subscription to a participant model tells that model to keep itself
                 * up to date by sending extra requests to the server. Too many such
                 * subscriptions may add too much network traffic.
                 *
                 * @param {String|Property<String>} href
                 *
                 *      The href of the "participant" resource  or a property containing
                 *      a href string for this participant or null. When its value is null,
                 *      its 'get' function should return a promise, which is expected to
                 *      be resolved to a href string.
                 *
                 * @param {Person} [person] - The person model representing this participant.
                 *
                 *      Either href or person can be used to initialize the participant model. When the participant is
                 *      initialized with a Person model href parameter has to be a promise that will be resolved with
                 *      href when that href is received by the client.
                 *
                 * @param {String} [name=""] - The name of the participant.
                 * @param {UCWA} ucwa
                 * @param {ContactManager} contactManager
                 * @param {Boolean} isLocal - Local participant, if true.
                 *
                 * @property {String} displayName - It equals to either the name or the URI.
                 * @property {String} name - The participant's name.
                 * @property {String} uri - The participant's URI.
                 * @property {Participant.SourceNetwork} sourceNetwork
                 * @property {String} workPhoneNumber - The participant's phone (tel) URI.
                 * @property {String} otherPhoneNumber - The participant's other phone.
                 * @property {Boolean} organizer - An organizer can never be locked out of her own meeting.
                 *
                 * @property {Boolean} isAnonymous - Whether the participant is anonymous.
                 * @property {Participant.Role} role - The participant's role, such as Attendee or Leader.
                 * @property {Boolean} chat.isTyping - Tells whether the participant is typing.
                 * @property {"Connected"|"Disconnected"} chat.state - Tells whether the participant can use IM.
                 * @property {String} state - Aggregated state of the participant.
                 *
                 * @member {Person} person - The underlying Person model.
                 * @member {ParticipantChat} chat - Participant's chat modality.
                 * @member {ParticipantAudio} audio - Participant's audio modality.
                 * @member {ParticipantVideo} video - Participant's video modality.
                 *
                 * @command {Promise} admit - Admits the participant into the online meeting.
                 * @command {Promise} reject - Denies the participant access to the online meeting.
                 * @command {Promise} eject - Ejects the participant from the online meeting.
                 * @command {Promise} promote - Promotes the participant from the attendee role to the leader role.
                 * @command {Promise} demote - Demotes the participant from the leader role to the attendee role.
                 *
                 *  Check the `enabled` property of this command to learn whether it can be invoked.
                 *  The `enabled` property is a regular observable property and thus can be bound to UI:
                 *
                 *      participant.demote.enabled.changed(function (isEnabled) {
                 *          buttonAdmit.enabled(isEnabled);
                 *      });
                 *
                 *  If the command is not enabled, an attempt to invoke it throws an exception.
                 *  Note, that a subscription to the `enabled` property causes the model to keep
                 *  its state up to date at the expense of sending more requests to the server.
                 *  To fetch the value of the `enabled` property once, use its `get` method:
                 *
                 *      participant.admit.enabled.get().then(function (isEnabled) {
                 *          ...
                 *      });
                 *
                 *  This doesn't create any subscriptions, but if the actual value of the property
                 *  changes, the only way to get it on time is to subscribe to its `changed` event.
                 *
                 */
                function Participant(options) {
                    var contactManager = options.contactManager;
                    var ucwa = options.ucwa;
                    var href = isString(options.href) ? ConstProperty(options.href) : options.href;
                    var title = options.name;
                    var isLocal = ConstProperty(!!options.isLocal);
                    var convState = options.convState; // state of conversation
                    var rParticipant = href() && ucwa.get(href());
                    var State = Enum('PureHref', 'Fetched');
                    var sm = SequentialStateMachine(State.PureHref);
                    var isTyping = Property({ value: false });
                    var messagingState = Property({ value: 'Disconnected' });
                    var state = Property({ value: 'Disconnected' });
                    var properties = {};
                    var methods = {};
                    var nRefs = 0; // the number of subscriptions to this model
                    var audioState = Internal.AudioVideoModality ? Property({ value: 'Disconnected' }) :
                        ConstProperty(void 0, ENotSupported()), audioMuted = Property({ value: false }), audioOnHold = Property({ value: false }), isSpeaking = Property({ value: false });
                    var videoState = Internal.AudioVideoModality ? Property({ value: 'Disconnected' }) :
                        ConstProperty(void 0, ENotSupported()), vsEmpty = Internal.MediaStream(), videoChannels = Collection(), videoChannel;
                    // these ids are needed for video subsciption in a conference
                    var audioSourceId = Property({ value: -1 }), videoSourceId = Property({ value: -1 }), isInMediaRoster = {};
                    var pContactHref = Property({
                        value: getContactHrefOr(void 0),
                        get: function () {
                            return pContactHref() || getAndFetchParticipantResource().then(function () {
                                // a handler for the rel=participant:updated event
                                // has already updated this model property, so its new value is cached
                                return pContactHref();
                            });
                        }
                    });
                    // There are three ways to get the person model:
                    //
                    //  1. Take it from the ctor args if this is an "outgoing" participant.
                    //  2. Wrap existing /participant/contact link.
                    //  3. Create it without the link and fetch the link later.
                    //
                    // The call to inherit is important: it creates a fork of the original
                    // person object and thus perfectly reflects the state of that object
                    // and even changes if the original object changes, but allows to modify
                    // the forked object without modifying the original person object.
                    var person = inherit(options.person || contactManager.get(pContactHref() || pContactHref));
                    var proto = Model();
                    var self = inherit(proto, {
                        state: state.asReadOnly(),
                        person: person,
                        screenSharing: Model({
                            state: ConstProperty('Disconnected'),
                            isControlling: ConstProperty(false),
                            stream: Model({
                                state: ConstProperty('Stopped'),
                                width: ConstProperty(0),
                                height: ConstProperty(0),
                                source: Model({
                                    sink: Model({
                                        container: ConstProperty(null)
                                    })
                                })
                            })
                        }),
                        chat: Model({
                            isTyping: isTyping.asReadOnly(),
                            state: messagingState.asReadOnly()
                        }),
                        audio: Model({
                            state: audioState.asReadOnly(),
                            isMuted: audioMuted.asReadOnly(),
                            isOnHold: audioOnHold.asReadOnly(),
                            isSpeaking: isSpeaking.asReadOnly()
                        }),
                        video: Model({
                            state: videoState.asReadOnly(),
                            channels: videoChannels
                        })
                    });
                    options = null;
                    videoChannel = Internal.VideoChannel({
                        name: isLocal() ? 'Self Channel' : 'Render Channel'
                    });
                    videoChannel.stream.setSource(vsEmpty);
                    videoChannels.add(videoChannel);
                    //#region properties
                    defineProperty('displayName');
                    defineProperty('name');
                    defineProperty('role');
                    defineProperty('uri');
                    defineProperty('sourceNetwork');
                    defineProperty('workPhoneNumber');
                    defineProperty('otherPhoneNumber');
                    defineProperty('isAnonymous', 'anonymous');
                    defineProperty('organizer');
                    //#endregion
                    //#region methods
                    defineMethod('admit');
                    defineMethod('reject');
                    defineMethod('eject');
                    defineMethod('promote');
                    defineMethod('demote');
                    //#endregion
                    //#region internal methods
                    function replacePersonProperty(personPropertyName, participantPropertyName) {
                        // take a ref to the original person's property and use it
                        // after it gets overridden in the copy of that person
                        var personProperty = person[personPropertyName];
                        var participantProperty = properties[participantPropertyName];
                        // unit tests may create fake person objects without some properties
                        if (personProperty) {
                            // if the person's property appears to have a value and
                            // the participant's property appears to not have a value:
                            // take the value from the person to the participant
                            personProperty.changed(function (value) {
                                participantProperty(participantProperty() || value);
                            });
                            // this property is available in rel=participant
                            // and thus there is no need to fetch /participant/contact
                            // to get its value; note that this assignment
                            // does not modify the original person object that's stored in
                            // the contacts cache because the person object in the participant
                            // is a fork of the original person object
                            person[personPropertyName] = participantProperty.asReadOnly();
                        }
                    }
                    function getContactHrefOr(value) {
                        return rParticipant && rParticipant.hasLink('contact') && rParticipant.link('contact').href || value;
                    }
                    function getParticipantResource() {
                        return href.get().then(function (h) {
                            // It seems strange to check here for existence of the resource,
                            // but there is a special case when this is needed. An attempt to
                            // send a message to an offline contact results in a batch of events:
                            //
                            //      messagingInvitation completed, status=Failure
                            //      localParticipant added
                            //      localParticipant deleted
                            //
                            // The added event makes the conversation object resolve the href promise,
                            // which invokes its .then(...) listeners only after the entire batch of
                            // events is processed, but by that moment the href is no longer valid.
                            // Not checking the existence of the resource makes ucwa.get fail an assert(...)
                            // which is annoying during a debugging session, as this assertion doesn't
                            // indicate any real problem.
                            if (!ucwa.exists(h))
                                throw EDoesNotExist(h);
                            // in case there are multiple href.get() calls at the same time, 
                            // once the first call compelete and have rParticipant available,
                            // the rest calls just need to return the resouce without adding 
                            // listeners again.
                            if (rParticipant)
                                return rParticipant;
                            setHiddenProperty(proto, Internal.sHref, h);
                            rParticipant = ucwa.get(h);
                            rParticipant.updated(function () {
                                foreach(rParticipant.properties, function (value, name) {
                                    if (name in properties)
                                        properties[name](value);
                                });
                                properties.displayName(properties.name() || properties.uri() || '');
                                foreach(methods, function (method, rel) {
                                    method.enabled(rParticipant.hasLink(rel));
                                });
                                pContactHref(getContactHrefOr(pContactHref()));
                                messagingState(rParticipant.hasLink('participantMessaging') ? 'Connected' : 'Disconnected');
                                // TODO: UCWA used to drop participant modality links from the participant resource event if they were
                                // present. This was fixed in UCWA (DEVEX-1999) on 12/12/14, but it takes such a long time to reach our
                                // test servers, so I rely on participantAudio/Video events for now.
                                //audioState(rParticipant.hasLink('participantAudio') ? 'Connected' : 'Disconnected');
                                //videoState(rParticipant.hasLink('participantVideo') ? 'Connected' : 'Disconnected');
                            });
                            rParticipant.memberships.changed(function () {
                                isTyping(rParticipant.memberships.contains(function (m) { return m.rel == 'typingParticipants'; }));
                            });
                            // In online meetings the participant resources may get invalidated
                            // by empty "participant updated" events. The client may not unconditionally
                            // fetch the actual state of the participant resource after every such an
                            // updated event to avoid generating too much traffic. So whenever the
                            // participant resource gets invalidated, the model checks whether the view
                            // is observing this participant model and if it is, it sends a GET to the server.
                            rParticipant.dirty.changed(refreshIfNeeded);
                            return rParticipant;
                        });
                    }
                    function getAndFetchParticipantResource() {
                        return getParticipantResource().then(function () {
                            var p = sm.advanceTo(State.Fetched);
                            p.then(); // creates a dangling promise that prevents cancellation of sm
                            return p.then();
                        });
                    }
                    function defineProperty(name, attr) {
                        attr = attr || name;
                        var p = Property({
                            get: function () {
                                return getAndFetchParticipantResource().then(function () {
                                    // a handler for the rel=participant:updated event
                                    // has already updated this model property, so its new value is cached
                                    return p();
                                });
                            },
                            unsubscribed: decRef,
                            subscribed: function () {
                                incRef();
                                // if the property is in the resource already, do not
                                // send any requests to the server to load this property
                                getParticipantResource().then(function () {
                                    if (!rParticipant.has(attr))
                                        sm.advanceTo(State.Fetched);
                                });
                            }
                        });
                        properties[attr] = p;
                        self[name] = p.asReadOnly();
                    }
                    function defineMethod(name) {
                        var enabled = Property({
                            unsubscribed: decRef,
                            subscribed: function () {
                                incRef();
                                getParticipantResource().then(function () {
                                    if (!rParticipant.hasLink(name))
                                        sm.advanceTo(State.Fetched);
                                });
                            },
                            get: function () {
                                return getParticipantResource().then(function () {
                                    return rParticipant.hasLink(name) || sm.advanceTo(State.Fetched).then(function () {
                                        // the handler of rParticipant.updated has already updated this property
                                        return enabled();
                                    });
                                });
                            }
                        });
                        methods[name] = {
                            enabled: enabled
                        };
                        self[name] = Command(bind(post, name), enabled);
                    }
                    function refreshIfNeeded() {
                        if (rParticipant.dirty() && nRefs > 0)
                            ucwa.send('GET', rParticipant.href);
                    }
                    function post(rel) {
                        return ucwa.send('POST', rParticipant.link(rel).href);
                    }
                    function incRef() {
                        nRefs++;
                    }
                    function decRef() {
                        nRefs--;
                    }
                    function updateState() {
                        if (convState && convState() == 'InLobby')
                            state(convState());
                        else {
                            // videoState check is not needed since AV state is defined by audio
                            state(messagingState() == 'Connected' || audioState() == 'Connected' ?
                                'Connected' : 'Disconnected');
                        }
                    }
                    // extract media source ids from "participantAudio/Video added/updated in
                    // participant/localParticipant" events
                    // for the local participant MSIs are extracted from the event resource,
                    // for the remote one msi is in event.target.title
                    function setMediaSourceId(event) {
                        var target = event.target, resource = event.resource, rel = target.rel, scope = event['in'], scopeRel = scope && scope.rel, type = event.type, modality, res, msiNone = -1, msi;
                        res = /^participant(Audio|Video)$/.exec(rel);
                        if (!res)
                            return;
                        modality = res[1]; // Audio or Video
                        if (type == 'added' || type == 'updated') {
                            res = /^(local)?participant$/i.exec(scopeRel);
                            if (!res)
                                return;
                            self[Internal.sInternal].rAudio = resource;
                            msi = res[1] != 'local' ? +target.title :
                                modality == 'Audio' ?
                                    +resource.get('audioSourceId', -1) :
                                    +resource.get('videoSourceId', -1);
                            if (isNaN(msi))
                                msi = msiNone;
                            if (modality == 'Audio')
                                audioSourceId(msi);
                            else
                                videoSourceId(msi);
                        }
                        else if (type == 'deleted' && modality == 'Video') {
                            // we don't reset audio source id because we need to keep the
                            // pair of audio and video MSIs intact to remove this participant
                            // from the media manager roster. But we do this while processing
                            // 'participantVideo deleted' event, so we can reset both MSIs here.
                            audioSourceId(msiNone);
                            videoSourceId(msiNone);
                        }
                    }
                    //#endregion
                    //#region initialization
                    setHiddenProperty(proto, Internal.sInternal, {
                        state: state,
                        audioState: audioState,
                        videoState: videoState,
                        isSpeaking: isSpeaking,
                        audioSourceId: audioSourceId,
                        videoSourceId: videoSourceId,
                        isInMediaRoster: isInMediaRoster,
                        setMediaSourceId: setMediaSourceId,
                        isLocal: isLocal,
                        audioOnHold: audioOnHold,
                        audioMuted: audioMuted,
                        setVideoStarted: function (val) {
                            assert(videoChannel.isStarted);
                            videoChannel.isStarted._set(val);
                        },
                        setVideoStream: function (vs) {
                            var stream = videoChannel.stream, container = stream.source.sink.container();
                            stream.setSource(vs || vsEmpty);
                            // retain the video container after setting a new video stream
                            stream.source.sink.container(container);
                            debug.log('Participant::SetVideoStream  stream %c' + (vs && vs._id()) + ', ' + properties.displayName(), 'color:green;font-weight:bold');
                        }
                    });
                    audioSourceId.changed(function (newState, reason, oldState) {
                        debug.log('MSI Audio(' + properties.displayName() + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    videoSourceId.changed(function (newState, reason, oldState) {
                        debug.log('MSI Video(' + properties.displayName() + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    videoState.changed(function (newState, reason, oldState) {
                        debug.log('Participant VideoState (' + properties.displayName() + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    if (title)
                        properties.name(title);
                    // this assignment ensures that the inviter participant displayName is available immediately after
                    // the 1:1 conversation is created for the incoming invitation (i.e. we don't have to wait for the next
                    // event cycle in getParticipantResource call below).
                    properties.displayName(properties.name() || properties.uri() || '');
                    replacePersonProperty('displayName', 'displayName');
                    replacePersonProperty('id', 'uri');
                    sm.defineState(State.Fetched, function () {
                        if (isEmptyObject(rParticipant.properties))
                            return ucwa.send('GET', rParticipant.href);
                    });
                    href.changed(function () {
                        rParticipant = null;
                        setHiddenProperty(proto, Internal.sHref, href());
                        sm.reset();
                        getParticipantResource();
                    });
                    messagingState.changed(updateState);
                    audioState.changed(updateState);
                    videoState.changed(updateState);
                    if (convState)
                        convState.changed(updateState);
                    //#endregion
                    return self;
                }
                Internal.Participant = Participant;
                var Participant;
                (function (Participant) {
                    /**
                     * An enumeration that represents the role type of a participant.
                     * These values are taken by the participant.role property.
                     */
                    Participant.Role = StringEnum('Attendee', 'Leader', 'Unknown');
                    /**
                     * An enumeration that represents the source-network type of a participant.
                     * These values are taken by the participant.sourceNetwork property.
                     *
                     * The participant's source network can be the same enterprise as the user's (SameEnterprise),
                     * an organization that is federated with the user's organization (Federated), or the public
                     * internet cloud (PublicCloud). The Everyone value includes SameEnterprise, Federated, and PublicCloud.
                     */
                    Participant.SourceNetwork = StringEnum('Everyone', 'Federated', 'PublicCloud', 'SameEnterprise', 'Unknown');
                })(Participant = Internal.Participant || (Internal.Participant = {}));
                //#endregion Participant
                //#region ActivityItem
                /**
                 * A general purpose activity item like a text message, a video call, etc.
                 *
                 * It takes an existing model as a prototype, creates a derived activity item
                 * object and augments it with missing properties.
                 *
                 * @param {String} type
                 * @param {ActivityItemType} key
                 * @param {Object} prototype
                 *
                 * @property {ActivityItemType} type
                 * @property {String} key
                 * @property {Date} timestamp
                 * @property {ActivityStatus} status
                 * @property {Exception} reason - A reflection of .status.reason
                 * @property {Boolean} isRead - It's writable.
                 *
                 */
                function ActivityItem(type, key, prototype) {
                    var reason = Property();
                    if (prototype.status) {
                        prototype.status.changed(function (newValue, newReason) {
                            reason(newReason);
                        });
                    }
                    // create an object inherited from the prototype and add
                    // missing properties to the create object
                    return inherit(prototype, {
                        type: ConstProperty(type),
                        key: ConstProperty(key),
                        timestamp: ConstProperty(new Date),
                        status: ConstProperty('Succeeded'),
                        reason: reason.asReadOnly(),
                        isRead: BoolProperty(false)
                    }, 'append');
                }
                Internal.ActivityItem = ActivityItem;
                //#endregion
                //#region HistoryService
                /**
                 * Aggregates all the activities in a conversation.
                 *
                 * @param {Collection<Message>} messages
                 *
                 * @collection {ActivityItem} activityItems
                 * @property {Number} unreadActivityItemsCount
                 *
                 * @command {Promise} getMoreActivityItems
                 * @command {Promise} markAllAsRead
                 * @property {Property<Date>} lastModificationTimestamp
                 *
                 */
                function HistoryService(messages) {
                    var id = random();
                    var items = Collection();
                    var unread = NumProperty(0);
                    var lastModificationTimestamp = Property({ value: new Date() });
                    function makeKey(key) {
                        return id + ':' + key;
                    }
                    function markAllAsRead() {
                        // in SkypeWeb it's a synchronous local operation
                        items.each(function (item) {
                            item.isRead(true);
                        });
                    }
                    function updateLastModificationTimestamp(item) {
                        if (item.timestamp && item.timestamp() > lastModificationTimestamp()) {
                            lastModificationTimestamp(item.timestamp());
                        }
                    }
                    // it's assumed that activity items are never removed
                    items.added(function (item) {
                        // it's assumed that if an item gets read, it cannot be un-read
                        if (!item.isRead()) {
                            unread.inc();
                            item.isRead.changed(function (isRead) {
                                if (isRead)
                                    unread.dec();
                            });
                        }
                        updateLastModificationTimestamp(item);
                    });
                    messages.added(function (message, key) {
                        var item = ActivityItem('TextMessage', makeKey(key), message);
                        items.add(item);
                    });
                    return Model({
                        activityItems: items.asReadOnly(),
                        unreadActivityItemsCount: unread.asReadOnly(),
                        isHistoryDisclosed: ConstProperty(true),
                        getMoreActivityItems: EnabledCommand(async(function () { })),
                        markAllAsRead: EnabledCommand(async(markAllAsRead)),
                        lastModificationTimestamp: lastModificationTimestamp.asReadOnly()
                    });
                }
                Internal.HistoryService = HistoryService;
                //#endregion
                //#region Conversation
                /**
                 * An ongoing conversation with one or multiple participants.
                 *
                 * The conversation model consists of
                 *
                 *  - a collection of participants
                 *  - a collection of modalities (addModality adds a new modality)
                 *  - common properties (such as "subject")
                 *
                 * To start an outgoing IM conversation start a modality with a participant:
                 *
                 *      var messaging = conversation.chatService;
                 *
                 *      messaging.start({
                 *          message: 'How are you?',
                 *          to: 'sip:user@company.com'
                 *      });
                 *
                 * Participants can be added later via the addParticipant method:
                 *
                 *      conversation.addParticipant("sip:user2@contoso.com");
                 *      conversation.addParticipant("sip:user3@contoso.com");
                 *      conversation.addParticipant("sip:user4@contoso.com");
                 *
                 * @param {UCWA} ucwa
                 * @param {MePerson} me
                 * @param {ContactManager} contactManager
                 * @param {Property<String>} guestName
                 * @param [listNamesInTopic=false]
                 * @param {MediaPlugin} [mediaPlugin]
                 * @param {Resource} [rInvitation] - Resource of invitation (messaging, audioVideo, onlineMeeting, or applicationSharing).
                 * @param {String} [topic] - Specifies the topic of an outgoing conversation.
                 * @param {String} [priority="Normal"] - Specifies the priority of an outgoing conversation.
                 * @param {String} [href] - The href of the incoming conversation.
                 * @param {String} [threadId] - Used to identify an outgoing conversation.
                 * @param {String} [uri] - Online meeting uri, if this conversation represents a meeting.
                 *
                 * @property {String} topic
                 * @property {String} priority
                 * @property {Conversation.State} state
                 *
                 *      Values for this property are given by the "state" property of the
                 *      "conversation" resource. The initial value of this property is "Created".
                 *
                 * @property {String} avatarUrl - It's the remote participant's photo in 1:1 conversations and null in conferences.
                 *
                 * @property {String} uri - null for a 1:1 conversation, a meeting uri for a multiparty conversation.
                 *
                 *      The uri of a Conversation object is associated with the Conversation.meeting.uri property.
                 *
                 * @property {Boolean} isGroupConversation - true for a multiparty conversation, false for a 1:1 conversation.
                 *
                 *      This property is true if the Conversation object either has a valid uri or its state equals "Conferenced".
                 *
                 * @property {Object} context - Context of the incoming invitation. It is an object or a string.
                 *                              It also contains one following field:
                 *
                 *      property {String} type - Context type. Types supported are 'application/xml', 'application/json',
                 *                               'text/xml', and 'text/json'.
                 *
                 * @collection {Modality} modalities - Modalities in this conversation
                 * @collection {Participant} participants - Participants in the conversation.
                 *
                 * @method {Promise} leave - Leaves and terminates the conversation.
                 *
                 *      Stops all the modalities in the conversation and then terminates
                 *      the conversation itself. In the conferencing mode this results
                 *      in quitting from the multiparty conversation. If the conversation
                 *      is already stopped, this method is a noop.
                 *
                 * @method {Modality} addModality(type) - Adds a modality to the conversation.
                 *
                 * @command {Participant} createParticipant(person) -
                 *      Creates a participant model for a given person model.
                 *
                 * @command {Promise} addParticipant(uri) - Adds a participant to the conversation.
                 *
                 *      Adding a participant to a peer to peer conversation escalates it to
                 *      the multiparty mode and creates an online meeting (conversation.meeting).
                 *      It is safe to invoke this method many times in a row: SkypeWeb will merge
                 *      all the requests into one batch request.
                 *
                 *          conversation.addParticipant("sip:user1@contoso.com");
                 *          conversation.addParticipant("sip:user2@contoso.com");
                 *          conversation.addParticipant("sip:user3@contoso.com");
                 *
                 * @member {HistoryService} historyService
                 * @member {ChatService} chatService
                 * @member {AudioService} audioService
                 * @member {VideoService} videoService
                 *
                 * @member {OnlineMeeting} meeting - If present, the conversation is a multiparty meeting.
                 *
                 *      To accept an invitation to an online meeting the client needs to accept
                 *      the invitation itself and then add necessary modalities, such as the
                 *      messaging modality. Accepting the meeting invitation does not start
                 *      modalities automatically.
                 *
                 *          client.conversation.added(function (conversation) {
                 *              if (conversation.meeting.accept) {
                 *                  conversation.meeting.accept().then(function () {
                 *                     conversation.chatService.start();
                 *                  });
                 *              }
                 *          });
                 *
                 * @member activeModalities - Active modalities of the conversation.
                 *
                 *      It contains the following boolean properties:
                 *
                 *          chat - corresponds to UCWA's Messaging
                 *          audio - corresponds to UCWA's Audio
                 *          video - corresponds to UCWA's Video
                 *          screenSharing - corresponds to UCWA's ApplicationSharing
                 *          dataCollaboration - corresponds to UCWA's DataCollaboration
                 *
                 *      These properties reflect the modalities that are actually present in the
                 *      conversation, and not the services that are started.
                 *
                 *      For example, an online meeting may have two active modalities - Messaging and Audio,
                 *      and both properties will be enabled in the activeModalities model.
                 *      But the app may ignore the audio part of the conversation and not call
                 *      conversation.audioService.start(), so the conversation will have
                 *      only chatService started. activeModalities provides a hint to
                 *      the app when it should start the audio service in an online meeting if it did not
                 *      do it when the conversation was created.
                 *
                 *          conversation.audio.when(true, function () {
                 *              conversation.audioService.start();
                 *          });
                 *
                 * @event changed - Occurs after the object adds or removes own methods or properties.
                 *
                 */
                function Conversation(options) {
                    // a conversation is either incoming, outgoing, meeting by uri, or restored converstion:
                    // 1. incoming conversation is identified by rInvitation
                    // 2. outgoing conversation is identified by the thread id
                    // 3. a meeting is identified by a uri  (called from getConversationByUri)
                    // 4. a restored conversation is identified by href.
                    //#region Locals
                    var ucwa = options.ucwa;
                    var me = options.me;
                    var href = options.href;
                    var contactManager = options.contactManager;
                    var mediaPlugin = options.mediaPlugin;
                    var devices = options.devices;
                    var sharedResources = options.sharedResources;
                    var rInvitation = options.rInvitation;
                    var guestName = options.guestName;
                    var listNamesInTopic = options.listNamesInTopic;
                    // rInvitation is not changed later, so the value of isIncoming remains correct
                    var isIncoming = rInvitation ? rInvitation.get('direction') == 'Incoming' : false;
                    // threadId identifies the conversation: it's specified by the client
                    // when the client starts an outgoing conversation and it's specified
                    // by the server when the client receives an incoming invitation from
                    // the server
                    var threadId = options.threadId || guid();
                    var subject = Property({ value: options.topic || '' });
                    var priority = Property({ value: options.priority || 'Normal' });
                    // the uri of the onlineMeeting (if it exists)
                    var uri = Property({ value: options.uri || null });
                    var participants = options.participants || Collection(); // a unit test may give a collection mock
                    var localParticipant;
                    var isConference = getOption(options, 'isConference', true);
                    var isGroupConversation = Property({
                        value: rInvitation ? rInvitation.rel == 'onlineMeetingInvitation' : isConference
                    });
                    options = null; // no need to use options beyond this point
                    var state = Property({ value: Conversation.State.Created });
                    var topic = !listNamesInTopic ? subject : createPNamesProperty().or(subject);
                    var modalities = Collection();
                    var changed = Event();
                    var rConversation; // rel=conversation
                    var mapping = {
                        'state': state,
                        'importance': priority,
                        'subject': subject
                    };
                    var isChatActive = Property({ value: false });
                    var isAudioActive = Property({ value: false });
                    var isVideoActive = Property({ value: false });
                    var isSharingActive = Property({ value: false });
                    var isCollabActive = Property({ value: false });
                    var canAddParticipant = Property({ value: false });
                    var isConferencing = state.equalsAny(Conversation.State.Conferenced, Conversation.State.Conferencing);
                    var avatarUrl = SourcedProperty();
                    var proto = Model();
                    var self = inherit(proto, {
                        id: ConstProperty(threadId),
                        changed: changed.observer,
                        state: state.asReadOnly(),
                        isJoiningEnabled: ConstProperty(true),
                        topic: topic.fork(Command(function (x) { return x; }, state.equals('Created'))),
                        priority: priority.asReadOnly(),
                        avatarUrl: avatarUrl.asReadOnly(),
                        uri: uri.asReadOnly(),
                        context: getInvitationContext(),
                        modalities: modalities.asReadOnly(),
                        activeModalities: Model({
                            chat: isChatActive.asReadOnly(),
                            audio: isAudioActive.asReadOnly(),
                            video: isVideoActive.asReadOnly(),
                            screenSharing: isSharingActive.asReadOnly(),
                            dataCollaboration: isCollabActive.asReadOnly()
                        }),
                        isGroupConversation: isGroupConversation.asReadOnly(),
                        addModality: addModality,
                        addMeeting: addMeeting,
                        addParticipant: Command(async(addParticipant), canAddParticipant),
                        leave: EnabledCommand(async(stop)),
                        createParticipant: EnabledCommand(createParticipantFromPerson),
                        participantsCount: participants.size,
                        participants: participants.fork({
                            add: Command(addCreatedParticipant, state.equalsAny('Created', 'Connected', 'Conferenced')),
                            remove: EnabledCommand(async(removeParticipant))
                        })
                    });
                    // For a Participant model created and added to the conversation by this client we need to a way to
                    // sneak the participant href received in the "participant added" event after the model was already created.
                    // Also for a coming P2P invitation, the property of participant href needs to be cached in case
                    // this href need to be changed later.
                    var participantHrefs = {}; // <ContactHref|ParticipantHref, Property<ParticipantHref>> map
                    // ditto for a local participant
                    var dfdLocalParticipantHref = Task();
                    var pLocalParticipantHref = Property({
                        get: function (href) {
                            return href || dfdLocalParticipantHref.promise;
                        }
                    });
                    // For a Participant model created and added to the conversation by this client we need to match the
                    // contact or participant href that is used as a key in the participants collection for that a model with the
                    // participant href received in the "participant added" event. Such a mapping is needed so that
                    // we could remove participants from the collection when they leave and we receive "participant deleted"
                    // event that identifies the participant by href.
                    // Also note: when a P2P conversation is disconnected and then reused, the key used for a participant model
                    // could be an expired and old participant href, we need map the current participant href to the expired one.
                    var participantKeys = {}; // <ParticipantHref, ContactHref|old ParticipantHref> map
                    var avm; // AudioVideoModality object
                    var isVideoStartEnabled = BoolProperty(); // enable/disable videoService.start command
                    //#endregion
                    // this function may be called first time when the conversation model is 
                    // initialization (function 'init'), or when this conversation is disconnected 
                    // and then receives a new invitation event.
                    function processInvitation() {
                        var senderHref, pSenderHref;
                        setResource(ucwa.get(rInvitation.link('conversation').href));
                        threadId = rConversation.get('threadId', threadId);
                        // in outgoing invitation /from points to the local participant
                        // which must not be added to the .participants collection
                        if (rInvitation.hasLink('from') && isIncoming) {
                            senderHref = rInvitation.link('from').href;
                            // For a new conversation model, it is necessary to cache the property for the
                            // sender href since the href may be changed later when this participant model be reused.
                            // When a disconnected conversation receives an invitation, the left remote paricipant 
                            // href will be updated in function addParticipantToCollection  when 
                            // a 'participant added' event is received.
                            if (rInvitation.rel == 'messagingInvitation' && state() != 'Disconnected') {
                                pSenderHref = Property({ value: senderHref });
                                participantKeys[senderHref] = senderHref;
                                participantHrefs[senderHref] = pSenderHref;
                                addParticipantToCollection({
                                    href: pSenderHref.asReadOnly(),
                                    name: ucwa.get(senderHref).get('name', void 0)
                                });
                            }
                            else {
                                // TODO: for any other invitations, a property for each participant
                                // href should be created and added into map as well.
                                addParticipantToCollection({
                                    href: ConstProperty(senderHref),
                                    name: ucwa.get(senderHref).get('name', void 0)
                                });
                            }
                        }
                        state(isIncoming ? Conversation.State.Incoming : Conversation.State.Connecting);
                    }
                    // returns a read-only property which always contains the comma-separated
                    // list of participant names (if a participant joins, leaves or changes its
                    // name, the property value gets updated)
                    function createPNamesProperty() {
                        var property = Property();
                        function updateNamesList() {
                            var names = participants().map(function (p) {
                                return p.displayName();
                            }).filter(function (s) {
                                return !!s;
                            });
                            property(names.join(', '));
                        }
                        participants.added(function (p) {
                            updateNamesList();
                            p.displayName.changed(updateNamesList);
                        });
                        participants.removed(function (p) {
                            updateNamesList();
                            p.displayName.changed.off(updateNamesList);
                        });
                        return property.asReadOnly();
                    }
                    //#region Initialization
                    function init() {
                        ucwa.event(onServerEvent);
                        pLocalParticipantHref.changed(function (href) {
                            if (href && dfdLocalParticipantHref) {
                                dfdLocalParticipantHref.resolve(href);
                                dfdLocalParticipantHref = null;
                            }
                        });
                        setHiddenProperty(proto, Internal.sHref, href);
                        setHiddenProperty(proto, Internal.sInternal, {
                            updateParticipants: updateParticipants
                        });
                        if (href) {
                            setResource(ucwa.get(href));
                            threadId = rConversation.get('threadId', threadId);
                            restoreParticipants();
                            restoreMeeting();
                        }
                        else if (rInvitation) {
                            processInvitation();
                        }
                        localParticipant = createParticipant({
                            href: pLocalParticipantHref.asReadOnly(),
                            person: me,
                            ucwa: ucwa,
                            contactManager: contactManager,
                            convState: state,
                            isLocal: true
                        });
                        self.selfParticipant = localParticipant;
                        if (rInvitation && rInvitation.rel == 'onlineMeetingInvitation') {
                            self.meeting = OnlineMeeting({
                                ucwa: ucwa,
                                rInvitation: rInvitation,
                                from: isIncoming ? participants(rInvitation.link('from').href) : localParticipant,
                                contactManager: contactManager
                            });
                        }
                        else if (uri()) {
                            // called from getConversationByUri to create
                            // a meeting based on the meeting's uri
                            self.meeting = OnlineMeeting({
                                ucwa: ucwa,
                                threadId: threadId,
                                subject: subject(),
                                priority: priority(),
                                contactManager: contactManager
                            });
                        }
                        if (self.meeting)
                            self.meeting.uri.changed(uri);
                        self.chatService = ChatService({
                            ucwa: ucwa,
                            guestName: guestName,
                            conversation: self,
                            participantKeys: participantKeys,
                            resource: rInvitation && rInvitation.rel == 'messagingInvitation' && rInvitation,
                            contactManager: contactManager,
                            me: me
                        });
                        // the Created state is for internal use only, map it to Disconnected for external users
                        localParticipant.chat.state = self.chatService.state.map(function (v) {
                            return v == 'Created' ? 'Disconnected' : v;
                        });
                        self.historyService = HistoryService(self.chatService.messages);
                        self.lastModificationTimestamp = self.historyService.lastModificationTimestamp;
                        avm = Internal.AudioVideoModality && Internal.AudioVideoModality({
                            ucwa: ucwa,
                            guestName: guestName,
                            mediaPlugin: mediaPlugin,
                            devices: devices,
                            contactManager: contactManager,
                            participants: participants.asReadOnly(),
                            selfParticipant: localParticipant,
                            threadId: threadId,
                            conversation: self,
                            rConversation: rConversation,
                            me: me,
                            rInvitation: rInvitation
                        });
                        self.audioService = Model({
                            // TODO: do we really need this or should we just rely on callStarted activity item?
                            callStarted: avm ? Property().asReadOnly() : ConstProperty(void 0, ENotSupported()),
                            state: avm ? avm.audioState : ConstProperty(void 0, ENotSupported()),
                            start: avm ? Command(avm.start, avm.audioState.equals(Internal.Modality.State.Disconnected)) : DisabledAsyncCommand(ENotSupported()),
                            stop: avm ? Command(avm.stop, avm.audioState.equalsAny(Internal.Modality.State.Connected, Internal.Modality.State.Connecting)) : DisabledAsyncCommand(ENotSupported()),
                            accept: avm ? Command(avm.accept, avm.audioState.equals(Internal.Modality.State.Notified)) : DisabledAsyncCommand(ENotSupported()),
                            reject: avm ? Command(avm.decline, avm.audioState.equals(Internal.Modality.State.Notified)) : DisabledAsyncCommand(ENotSupported()),
                            sendDtmf: avm ? avm.sendDtmf : DisabledAsyncCommand(ENotSupported())
                        });
                        if (avm) {
                            avm.audioState.changed(function (s) {
                                updateVideoStartEnabled(s, avm.videoState());
                            });
                            avm.videoState.changed(function (s) {
                                updateVideoStartEnabled(avm.audioState(), s);
                            });
                        }
                        self.videoService = Model({
                            state: avm ? avm.videoState : ConstProperty(void 0, ENotSupported()),
                            start: avm ? Command(async(function (options) {
                                return avm.start(extend(options, { video: true }));
                            }), isVideoStartEnabled) : DisabledAsyncCommand(ENotSupported()),
                            stop: avm ? Command(async(function () {
                                return avm.stop('video');
                            }), avm.videoState.equalsAny(Internal.Modality.State.Connected, Internal.Modality.State.Connecting)) : DisabledAsyncCommand(ENotSupported()),
                            accept: avm ? Command(async(function (options) {
                                return avm.accept(extend(options, { video: true }));
                            }), avm.videoState.equals(Internal.Modality.State.Notified)) : DisabledAsyncCommand(ENotSupported()),
                            reject: avm ? Command(avm.decline, avm.videoState.equals(Internal.Modality.State.Notified)) : DisabledAsyncCommand(ENotSupported())
                        });
                        // override properties of the self participant audio excluding isSpeaking
                        extend(localParticipant.audio, {
                            state: avm ? avm.audioState : ConstProperty(void 0, ENotSupported()),
                            isMuted: avm ? avm.muted : ConstProperty(void 0, ENotSupported()),
                            isOnHold: avm ? avm.onHold : ConstProperty(void 0, ENotSupported())
                        });
                        self.creator = self.meeting ? self.meeting.creator :
                            isIncoming ? participants(0).person :
                                rInvitation ? localParticipant :
                                    href ? restoreCreator() :
                                        localParticipant.person; // P2P outgoing conversation
                        participants.size.changed(function (n) {
                            avatarUrl.setSource(n == 1 ?
                                // in 1:1 conversations the conversation's picture = the remote participant's photo
                                participants(0).person.avatarUrl :
                                // in conferences the conversation's picture is null as UCWA doesn't have this concept
                                ConstProperty(null));
                        });
                        [state, uri, participants.size].forEach(function (p) {
                            p.changed(updateIsGroupConversation);
                        });
                    }
                    //#endregion
                    //#region Internal Methods
                    function updateIsGroupConversation() {
                        if (!!uri()) {
                            isGroupConversation(true);
                        }
                        else {
                            switch (state()) {
                                case Conversation.State.Created:
                                    // we defer to the initial status even when there are no remote participants to
                                    // 1) avoid property change after a participant is added to a conversation
                                    // created with {isConference: false) parameter
                                    // 2) to support starting a conv. service with {to: sipUri} parameter 
                                    isGroupConversation(participants.size() <= 1 ?
                                        isConference : true);
                                    break;
                                case Conversation.State.Connecting:
                                case Conversation.State.Connected:
                                    isGroupConversation(false);
                                    break;
                                case Conversation.State.Conferencing:
                                case Conversation.State.Conferenced:
                                    isGroupConversation(true);
                                    break;
                            }
                        }
                    }
                    // videoService.start command will be enabled if and only if videoState
                    // is Disconnected and audioState is either Connected or Disconnected.
                    // In other words, if a conversation of audioService is in the
                    // transitioning state of being established, it is not allowed to start
                    // videoService
                    function updateVideoStartEnabled(as, vs) {
                        isVideoStartEnabled(vs == Internal.Modality.State.Disconnected &&
                            (as == Internal.Modality.State.Connected || as == Internal.Modality.State.Disconnected));
                    }
                    // this is the only function that should be called internally to
                    // create participants (both self and remote)
                    function createParticipant(options) {
                        var p = Participant(options), selfEnabled = Property(), remoteEnabled = Property();
                        // show or remove participant video
                        function participantVideo(val) {
                            var dfd = val ?
                                avm.showParticipantVideo(p) :
                                avm.removeParticipantVideo(p);
                            return dfd.then(function () {
                                return val;
                            });
                        }
                        // show or remove self participant video
                        function selfVideo(val) {
                            switch (p.video.state()) {
                                case Internal.Modality.State.Disconnected:
                                case Internal.Modality.State.Notified:
                                    return val;
                                case Internal.Modality.State.Connected:
                                    return participantVideo(val);
                                default:
                                    throw Exception('InvalidState');
                            }
                        }
                        if (options.isLocal) {
                            //TODO: convert to p.video.state.map(...)
                            p.video.state.changed(function (v) {
                                selfEnabled(v != Internal.Modality.State.Connecting);
                            });
                            p.video.channels(0).isStarted = Property({
                                set: Command(selfVideo, selfEnabled)
                            });
                        }
                        else {
                            // videoChanel.isStarted.set should be enabled for a remote participant only in a conference,
                            // so we need to observe both participant video state and conversation state changes.
                            p.video.state.changed(function (v) {
                                remoteEnabled(isConferencing() && v == Internal.Modality.State.Connected);
                            });
                            isConferencing.changed(function (v) {
                                remoteEnabled(v && p.video.state() == Internal.Modality.State.Connected);
                            });
                            p.video.channels(0).isStarted = Property({
                                set: Command(participantVideo, remoteEnabled)
                            });
                        }
                        return p;
                    }
                    function getInvitationContext() {
                        var href = rInvitation && rInvitation.relatedHref('customContent');
                        var data, context, dataUri = DataUri(href || 'data:,');
                        try {
                            data = JSON.parse(dataUri.data);
                        }
                        catch (_) {
                            data = dataUri.data;
                        }
                        context = ConstProperty(data);
                        context.type = ConstProperty(dataUri.mime);
                        return context;
                    }
                    function restoreParticipants() {
                        var rParticipants = ucwa.find(function (r) {
                            return r.rel == 'participant' &&
                                r.hasLink('conversation') &&
                                r.link('conversation').href == rConversation.href;
                        });
                        rParticipants.forEach(function (rParticipant) {
                            if (rParticipant.get('local', false)) {
                                pLocalParticipantHref(rParticipant.href);
                            }
                            else {
                                addParticipantToCollection({
                                    href: ConstProperty(rParticipant.href),
                                    name: rParticipant.get('name', void 0)
                                });
                            }
                        });
                    }
                    function restoreMeeting() {
                        if (rConversation.hasLink('onlineMeeting')) {
                            self.meeting = OnlineMeeting({
                                ucwa: ucwa,
                                rMeeting: ucwa.get(rConversation.link('onlineMeeting').href),
                                contactManager: contactManager
                            });
                        }
                    }
                    function restoreCreator() {
                        var rInvitations = ucwa.find(function (r) {
                            return /Invitation$/.test(r.rel) &&
                                r.hasLink('conversation') &&
                                r.get('direction') == 'Incoming' &&
                                r.link('conversation').href == rConversation.href;
                        });
                        return rInvitations.length > 0 ?
                            participants(0).person :
                            self.selfParticipant.person;
                    }
                    function setResource(r) {
                        href = r.href;
                        rConversation = r;
                        self[Internal.sHref] = href; // make it available to the messaging modality
                        rConversation.deleted(function () {
                            self[Internal.sHref] = null;
                            href = null;
                            rConversation = null;
                            rInvitation = null;
                            state(Conversation.State.Disconnected);
                        });
                        rConversation.updated(function () {
                            for (var p in mapping)
                                if (rConversation.has(p)) {
                                    // if the property isn't available in rel=conversation,
                                    // do not change the corresponding model property
                                    mapping[p](disableHtmlInText(rConversation.get(p)));
                                }
                        });
                        rConversation.updated(function () {
                            var modalities = rConversation.get('activeModalities', []);
                            isChatActive(indexOf(modalities, 'Messaging') >= 0);
                            isAudioActive(indexOf(modalities, 'Audio') >= 0);
                            isVideoActive(indexOf(modalities, 'Video') >= 0);
                            isSharingActive(indexOf(modalities, 'ApplicationSharing') >= 0);
                            isCollabActive(indexOf(modalities, 'DataCollaboration') >= 0);
                            canAddParticipant(rConversation.hasLink('addParticipant'));
                        });
                    }
                    function onServerEvent(event) {
                        var sender = event.sender, target = event.target, context = event['in'], resource = event.resource, participant, modalityState;
                        if (sender.href == href) {
                            // it's necessary to check the presence of the "in" property, because
                            // if in.rel = "typingParticipants" then the event means that a
                            // participant started or stopped typing, but is still in the
                            // conversation
                            if (!context) {
                                if (event.type == 'deleted' && target.rel == 'participant') {
                                    // Collection::remove is a noop if an nonexistent key is given
                                    // TODO: for conferencing, all participants should also be left in collection.
                                    if (isConferencing()) {
                                        participants.remove(participantKeys[target.href] || target.href);
                                        delete participantKeys[target.href];
                                    }
                                }
                                else if (event.type == 'added' && isParticipantRel(target.rel) && !participants(target.href)) {
                                    // the check !participants(target.href) above is needed because, for example, when we answer
                                    // an incoming meeting invitation the inviter participant is added to the collection with
                                    // href as a key when the conversation is created.
                                    if (target.rel == 'localParticipant') {
                                        pLocalParticipantHref(target.href);
                                    }
                                    else {
                                        addParticipantToCollection({
                                            href: ConstProperty(target.href),
                                            name: target.title
                                        });
                                    }
                                }
                            }
                            else if (event.type == 'added' && context.rel == 'lobby' && isParticipantRel(target.rel)) {
                                // if a participant in lobby event is added, the participant must be in this 
                                // conversation already, and its state should be updated to 'inLobby'.
                                participant = participants(target.href);
                                if (participant)
                                    participant[Internal.sInternal].state('InLobby');
                            }
                        }
                        // if in a peer to peer conversation the remote participant adds
                        // another participant to escalate the conversation to the multiparty
                        // mode, this participant receives a bunch of events with two among them:
                        //
                        //      conversation updated - rel=conversation.state becomes "Conferenced"
                        //      onlineMeeting added in conversation - rel=conversation/rel=onlineMeeting appears
                        //
                        if (event.type == 'added' && target && target.rel == 'onlineMeeting' && context && context.href == href) {
                            // if self.meeting is already there, then the conversation model
                            // was created to react to an onlineMeetingInvitation event, so
                            // no need to recreate it
                            if (!self.meeting) {
                                // TODO: use a sourced model here instead of replacing the member
                                self.meeting = OnlineMeeting({
                                    ucwa: ucwa,
                                    rMeeting: event.resource,
                                    contactManager: contactManager
                                });
                                // TODO: use a sourced model here instead of replacing the member
                                self.creator = self.meeting.creator;
                                self.meeting.uri.changed(uri);
                                changed.fire();
                            }
                        }
                        // for outgoing conversations the client specifies threadId
                        // and the server sends the href of the created "conversation"
                        // resource
                        if (resource && resource.rel == 'conversation' && resource.get('threadId', '') == threadId && !rConversation)
                            setResource(resource);
                        // for incoming invitation with the same threadId from the same sender 
                        // use the disconnected conversation to reprocess this new invitation.
                        if (!href && event.type == 'started' && resource.get('threadId', '') == threadId &&
                            resource.rel == 'messagingInvitation' && resource.get('direction', '') == 'Incoming') {
                            rInvitation = resource;
                            processInvitation();
                        }
                        // in meetings we receive the participantAudio/Video events even if we don't have AudioVideo modality (we
                        // hooked up messaging only). After we add A/V we won't get these events again. Moreover, even if we join
                        // a meeting with A/V right away, 'participantAudio/Video added' events for participants that are already
                        // in the meeting are fired before we even issued an AV invitation. So we need to track MSIs for such
                        // participants here.
                        if (sender.href == href && isConferencing() && context && context.rel == 'participant' &&
                            (target.rel == 'participantAudio' || target.rel == 'participantVideo')) {
                            participant = participants(context.href);
                            if (participant) {
                                // if video is on, a deleted event should be handled by AVModality; otherwise AVModality
                                // won't be able to take this participant out of the media roster because by the 
                                // time it has a chance to process this event the participant media source ids 
                                // will have have already been reset by this handler 
                                if (event.type == 'added' || event.type == 'updated' || !isVideoActive())
                                    participant[Internal.sInternal].setMediaSourceId(event);
                                modalityState = event.type == 'deleted' ?
                                    Internal.Modality.State.Disconnected :
                                    Internal.Modality.State.Connected;
                                if (target.rel == 'participantAudio')
                                    participant[Internal.sInternal].audioState(modalityState);
                                else
                                    participant[Internal.sInternal].videoState(modalityState);
                            }
                        }
                    }
                    // it's invoked in the ctor to restore participants from the snapshot
                    // and also as a reaction to the "participant added" event
                    function addParticipantToCollection(options) {
                        var href = options.href, name = options.name, participantKey;
                        options = null;
                        function createAndAddParticipantToCollection() {
                            // local participant is not a member of the participants collection, so
                            // we should not call this func for a local participant
                            var rParticipant = ucwa.get(href());
                            assert(!rParticipant.get('local', false));
                            var participant = createParticipant({
                                href: href,
                                name: name,
                                contactManager: contactManager,
                                ucwa: ucwa
                            });
                            participants.add(participant, href());
                        }
                        function getContactHref() {
                            var rParticipant = ucwa.get(href());
                            if (rParticipant.rel == 'localParticipant' || rParticipant.get('local', false))
                                return ucwa.get({ rel: 'me' }).href;
                            if (rParticipant.hasLink('contact'))
                                return rParticipant.link('contact').href;
                            return ucwa.send('GET', rParticipant.href).then(function (r) {
                                return r.link('contact').href;
                            });
                        }
                        if (size(participantHrefs) > 0 && !participantHrefs[href()]) {
                            // For a P2P conversation, when a second participant is added by the 'participant added' event,
                            // it must be the case that the conversation was disconnected and re-connected again. 
                            // Thus, try to re-use the 'expired' participant model by updating its href.
                            if (!isGroupConversation() && participants.size() == 1 && participantKeys[participants(0)[Internal.sHref]]) {
                                participantKey = participants(0)[Internal.sHref];
                                if (href() != participantKey) {
                                    participantKeys[href()] = participantKeys[participantKey];
                                    delete participantKeys[participantKey];
                                    participantHrefs[participantKeys[href()]](href());
                                }
                            }
                            else {
                                // If no participants were added to the conversation by this client there is no
                                // need for getting the contact href of this participant to find the matching
                                // Participant model and we can avoid one extra GET per participant which would
                                // be nice when we join a meeting with many participants
                                Task.wait(getContactHref()).then(function (contactHref) {
                                    var key = participantKeys[href()] || contactHref;
                                    var pHref = participantHrefs[key];
                                    if (pHref) {
                                        // this is a participant added to the conversation by this client
                                        pHref(href());
                                        if (!participantKeys[href()])
                                            participantKeys[href()] = contactHref;
                                    }
                                    else {
                                        createAndAddParticipantToCollection();
                                    }
                                });
                            }
                        }
                        else {
                            createAndAddParticipantToCollection();
                        }
                    }
                    // this is the Conversation::createParticipant method
                    function createParticipantFromPerson(person) {
                        var dfd = Task();
                        var href = Property({
                            get: function (href) {
                                return href || dfd.promise;
                            }
                        });
                        href.changed(function (href) {
                            if (href && dfd) {
                                dfd.resolve(href);
                                dfd = null;
                            }
                        });
                        assert(person[Internal.sHref]);
                        participantHrefs[person[Internal.sHref]] = href;
                        return createParticipant({
                            href: href.asReadOnly(),
                            person: person,
                            ucwa: ucwa,
                            contactManager: contactManager
                        });
                    }
                    // this is the Conversation::participants.add method
                    function addCreatedParticipant(participant) {
                        var contactHref = participant.person[Internal.sHref];
                        if (!participantHrefs[contactHref])
                            throw EInvalidArgument('participant', 'is not created by this conversation');
                        participants.add(participant, contactHref);
                        if (state() == 'Connected' || state() == 'Conferenced') {
                            participant[Internal.sInternal].state('Connecting');
                            return addParticipant(participant.uri());
                        }
                    }
                    // this is the Conversation::participants.remove method
                    function removeParticipant(participant) {
                        var href = participant[Internal.sHref], contactHref = participant.person[Internal.sHref], key = participantHrefs[contactHref], cDisconnected = Internal.Modality.State.Disconnected;
                        // if the participant was added by its href, it is a remotely
                        // joined participant and thus can be removed by its eject method;
                        // if the participant was added by its contact href, then it was
                        // added by the client via a POST to /addParticipant.
                        if (participants(href) || participants(contactHref) && key && key())
                            return participant.eject();
                        // removing a participant before any conversation service is started
                        if (participants(contactHref) &&
                            self.chatService.state() == Internal.Modality.State.Created &&
                            self.audioService.state() == cDisconnected &&
                            self.videoService.state() == cDisconnected) {
                            participants.remove(contactHref);
                            delete participantHrefs[contactHref];
                        }
                        // TODO: removing a participant that is being added is not supported yet
                        // either the participant was created by Conversation::createParticipant and hasn't
                        // been added or it was created by another conversation object; either way there is
                        // nothing to remove
                        throw Exception('InvalidState');
                    }
                    function isParticipantRel(rel) {
                        return rel == 'participant' || rel == 'localParticipant';
                    }
                    //#endregion
                    //#region Public Methods
                    //#region addParticipant
                    /**
                     * If the conversation was in the 1:1 (peer-to-peer) mode, it will be
                     * escalated to the 1:N (multiparty) mode. If the conversation was already
                     * in the 1:N mode, it will merely get a new participant.
                     *
                     * The new participant gets added to the Conversation::participants collection
                     * after the server notifies the client that the participant has been successfully
                     * invited.
                     *
                     * The endpoint that is adding a participant observes these events:
                     *
                     *      - participantInvitation started
                     *      - conversation updated (the state changes to "Conferenced")
                     *      - localParticipant updated (the role changes to "Leader")
                     *      - participant added in leaders (the participant denotes the local participant)
                     *      - onlineMeeting added in conversation
                     *      - participant added (the remote participant gets added)
                     *      - participantInvitation completed
                     *
                     * The participant being added observes these events:
                     *
                     *      - onlineMeetingInvitation started
                     *      - conversation added
                     *      - onlineMeeting added in conversation
                     *      - onlineMeetingInvitation completed
                     *
                     * The other participant that has been in the conversation observes these events:
                     *
                     *      - conversation updated (the state changes to "Conferenced")
                     *      - onlineMeeting added in conversation
                     *
                     * @param {String} uri - The SIP URI of the participant.
                     *
                     */
                    function addParticipant(uri) {
                        assert.is(uri, 'NotEmptyString');
                        return ucwa.send('POST', rConversation.link('addParticipant').href, {
                            data: { to: uri }
                        }).then(function (rParticipantInvitation) {
                            return ucwa.wait({
                                type: 'completed',
                                target: { rel: 'participantInvitation', href: rParticipantInvitation.href }
                            });
                        }).then(function (event) {
                            if (event.status != 'Success')
                                throw Internal.EInvitationFailed(event.reason);
                        });
                    }
                    //#endregion
                    //#region updateParticipants (internal)
                    /**
                     * Reconciles participants added to the conversation by the local participant
                     * with the participants that are already in the conversation.
                     *
                     * Called by start() method of a conversation service.
                     *
                     * A typical scenario:
                     *    conv = convManager.createConversation();
                     *    conv.participants.add(p1);
                     *    conv.participants.add(p2);
                     *    conv.chatService.start();
                     *
                     * This results in a conversation model that represents a new online meeting. The
                     * participants p1 and p2 must be added to the conversation after the meeting
                     * is created.
                     *
                     *    conv.chatService.stop();
                     *    ....
                     *    conv.chatService.start();
                     *
                     * If the chat service is stopped participants are still in the conversation. When
                     * the chat service is restarted we should not add participants again.
                     *
                     */
                    function updateParticipants() {
                        participants.each(function (p) {
                            // in an outgoing invitation different modalities may invoke
                            // the method multiple times: the AV modality invokes the method
                            // as a reaction to "conversation updated" and then the IM modality
                            // invokes it as a reaction to "meetingInvitation completed" event
                            if (!p[Internal.sHref] && p.state() == 'Disconnected') {
                                p[Internal.sInternal].state('Connecting');
                                addParticipant(p.person.id()).then(function () {
                                    p[Internal.sInternal].state('Connected');
                                }, function (err) {
                                    p[Internal.sInternal].state('Disconnected', err);
                                });
                            }
                        });
                    }
                    //#endregion
                    //#region addModality
                    /**
                     * Adds a new modality to the conversation.
                     *
                     * @param {Conversation.ModalityType} type
                     * @param {Object} [options] - Options for the constructor of the modality.
                     *
                     * @returns {Modality} - The created modality.
                     */
                    function addModality(type, options) {
                        check(type == Conversation.ModalityType.AppSharing, 'NotImplemented', { modality: type });
                        assert(!modalities(type), 'AlreadyExists', { item: type });
                        var modality;
                        options = options || {};
                        // every modality needs these objects
                        extend(options, {
                            ucwa: ucwa,
                            contactManager: contactManager,
                            participants: participants.asReadOnly(),
                            threadId: threadId,
                            rConversation: rConversation,
                            me: me,
                            topic: subject(),
                            priority: priority()
                        });
                        if (options.resource) {
                            options.invitation = Internal.AppSharingInvitation({
                                resource: options.resource,
                                // TODO: remove once AppSharing is converted to a service
                                createParticipant: function (resource) {
                                    return Participant({
                                        href: resource.href,
                                        ucwa: ucwa,
                                        contactManager: contactManager
                                    });
                                },
                                ucwa: ucwa
                            });
                        }
                        options.mediaPlugin = mediaPlugin;
                        options.sharedResources = sharedResources;
                        modality = Internal.AppSharingModality(options);
                        modalities.add(modality, type);
                        modality.state.when('Disconnected', function () {
                            modalities.remove(type);
                        });
                        return modality;
                    }
                    //#endregion
                    //#region addMeeting
                    function addMeeting() {
                        assert(state() == Conversation.State.Created);
                        assert(!self.meeting);
                        self.meeting = OnlineMeeting({
                            ucwa: ucwa,
                            threadId: threadId,
                            subject: subject(),
                            priority: priority(),
                            contactManager: contactManager
                        });
                        self.meeting.uri.changed(uri);
                        changed.fire();
                        return self.meeting;
                    }
                    //#endregion
                    //#region stop
                    /**
                     * After UCWA accepts all requests to stop the modalities,
                     * it also sends a "conversation deleted" event and this conversation
                     * model disappears from the conversations collection.
                     *
                     * @returns {Promise}
                     *
                     *      A task that resolves after all modalities report
                     *      that they are done with stopping themselves.
                     */
                    function stop() {
                        var tasks = [];
                        if (state() == Conversation.State.Disconnected)
                            return;
                        foreach(modalities(), function (m) {
                            try {
                                tasks.push(m.stop());
                            }
                            catch (err) {
                            }
                        });
                        // ignore all errors from the .stop() call
                        tasks.push(self.chatService.stop().catch());
                        tasks.push(self.audioService.stop().catch());
                        function deleteConversation() {
                            participantHrefs = {};
                            // DELETE rel=conversation to quit the conference;
                            // if the conversation is peer-to-peer, there is no harm in deleting
                            // the rel=conversation resource explicitly
                            if (rConversation)
                                return ucwa.send('DELETE', rConversation.href);
                        }
                        // if we successfully deleted the conversation resource then resolve
                        // even if stopping one of modalities failed
                        return Task.waitAll(tasks).then(deleteConversation, deleteConversation);
                    }
                    //#endregion
                    //#endregion
                    init();
                    return self;
                }
                Internal.Conversation = Conversation;
                var Conversation;
                (function (Conversation) {
                    /**
                     * These are possible values of conversation.state property.
                     */
                    Conversation.State = StringEnum('Created', 'Conferenced', 'Conferencing', 'Connected', 'Connecting', 'Disconnected', 'Disconnecting', 'Incoming', 
                    // InLobby is a transient state while the client is joining an online
                    // meeting anonymously. After an owner of the meeting admits the anonymous
                    // participant, the state goes from InLobby to Conferenced.
                    'InLobby');
                    /**
                     * Represents modality types that can be active in the conversation.
                     * The conversation.modalities collection is indexed with these values:
                     *
                     *      var im = conversation.modalities(Conversation.ModalityType.Messaging);
                     *      im.send("How are you?");
                     */
                    Conversation.ModalityType = StringEnum('Messaging', 'AudioVideo', 'AppSharing', 'DataCollaboration');
                })(Conversation = Internal.Conversation || (Internal.Conversation = {}));
                //#endregion Conversation
                //#region OnlineMeeting
                /**
                 * The OnlineMeeting model encapsulates rel=onlineMeeting and rel=onlineMeetingInvitation
                 * resource objects and belongs to a Conversation model. When the endpoint receives
                 * an "onlineMeetingInvitation started" event, the OnlineMeeting model acts as the invitation
                 * and provides "accept" and "decline" methods. After the online meeting invitation is accepted,
                 * the model represents the rel=onlineMeeting resource object.
                 *
                 * Note, that UCWA has separate resource objects for scheduled online meetings:
                 * rel=myOnlineMeeting and rel=myLargeOnlineMeeting.
                 *
                 * @param {UCWA} ucwa
                 * @param {Resource} [rInvitation] - The rel=onlineMeetingInvitation resource object.
                 * @param {Resource} [rMeeting] - The rel=onlineMeeting resource object.
                 * @param {Participant} [from] - The sender of the invitation.
                 * @param {String} [threadId] - For outgoing meeting invitations.
                 * @param {String} [subject] - For outgoing meeting invitations.
                 * @param {String} [priority] - For outgoing meeting invitations.
                 *
                 * @method {Promise} start - Creates an online meeting.
                 * @method {Promise} accept - Accepts the invitation to the online meeting.
                 * @method {Promise} decline - Declines the invitation to the online meeting.
                 *
                 * @member {Participant} from - The one who invites to the online meeting.
                 *
                 * @property {OnlineMeeting.State} state
                 * @property {String} uri - A meeting URI of the form "sip:user1@contoso.com;gruu;opaque=app:conf:focus:id:1234567"
                 * @property {String} joinUrl - A meeting join URL of the form "https://meet.contoso.com/user1/1234567"
                 * @property {String} subject - A meeting subject set by the organizer.
                 *
                 */
                function OnlineMeeting(options) {
                    //#region Constructor Parameters
                    var ucwa = options.ucwa;
                    var rInvitation = options.rInvitation;
                    var rMeeting = options.rMeeting;
                    var from = options.from;
                    var threadId = options.threadId;
                    var subject = options.subject;
                    var priority = options.priority;
                    var contactManager = options.contactManager;
                    // using options directly should be avoided as
                    // such uses are hard to track and error prone
                    options = null;
                    //#endregion
                    //#region Locals
                    var pState = Property();
                    var pSubject = Property();
                    var pUri = Property();
                    var pJoinUrl = Property();
                    var pPriority = Property();
                    var changed = Event();
                    var tCreatorHref = Task();
                    var pCreatorHref = Property({
                        get: function () {
                            return tCreatorHref.promise;
                        }
                    });
                    var methods = {
                        start: async(start),
                        accept: async(accept),
                        decline: async(decline)
                    };
                    var self = Model({
                        from: from,
                        changed: changed.observer,
                        state: pState.asReadOnly(),
                        subject: pSubject.asReadOnly(),
                        uri: pUri.asReadOnly(),
                        priority: pPriority.asReadOnly(),
                        joinUrl: pJoinUrl.asReadOnly(),
                        availableModalities: Model({
                            messaging: createAvailabilityProperty('Messaging'),
                            audio: createAvailabilityProperty('Audio'),
                            video: createAvailabilityProperty('Video'),
                            appSharing: createAvailabilityProperty('ApplicationSharing')
                        })
                    });
                    //#endregion
                    //#region Initialization
                    pCreatorHref.changed(function (href) {
                        tCreatorHref.resolve(href);
                    });
                    if (rInvitation) {
                        // the meeting model is created to represent
                        // an incoming invitation to a meeting
                        assert(from);
                        pState(OnlineMeeting.State.Notified);
                        self.accept = methods.accept;
                        self.decline = methods.decline;
                        rInvitation.updated(update);
                    }
                    else if (rMeeting) {
                        // the meeting model is created based on
                        // existing rel=onlineMeeting resource
                        pState(OnlineMeeting.State.Connected);
                        rMeeting.updated(update);
                    }
                    else {
                        // the meeting model is built from scratch
                        // to create a new online meeting
                        assert(threadId);
                        pState(OnlineMeeting.State.Created);
                        pSubject(subject);
                        pPriority(priority);
                        self.start = methods.start;
                    }
                    self.creator = contactManager.get(pCreatorHref);
                    //#endregion
                    //#region Private Methods
                    function createAvailabilityProperty(modality) {
                        // it's possible to return a const false property
                        // in some cases, but this optimization will give
                        // nothing, while require more complicated code
                        var property = BoolProperty(false);
                        if (rInvitation) {
                            rInvitation.updated(function () {
                                var modalities = rInvitation.get('availableModalities', []);
                                var value = indexOf(modalities, modality) >= 0;
                                property(value);
                            });
                        }
                        return property.asReadOnly();
                    }
                    /**
                     * At first it listens to rel=onlineMeetingInvitation and once it completes,
                     * it starts listening to rel=onlineMeeting.
                     */
                    function update() {
                        var r = rMeeting || rInvitation;
                        // note, that r can be either rel=onlineMeetingInvitation or rel=onlineMeeting
                        // and their property sets are similar but not identical
                        pSubject(r.get('subject', ''));
                        pUri(r.get('onlineMeetingUri', ''));
                        pJoinUrl(r.get('joinUrl', ''));
                        pPriority(r.get('importance', ''));
                        if (r.hasLink('organizer'))
                            pCreatorHref(r.link('organizer').href);
                    }
                    //#endregion
                    //#region Public Methods
                    //#region start
                    /**
                     * Creates a new persistent online meeting or joins an existing one using its
                     * known URI. In addition to rel=onlineMeeting, UCWA creates a rel=conversation
                     * resource object. The sequence of requests and events is following:
                     *
                     *      - POST rel=startOnlineMeeting
                     *      - onlineMeetingInvitation started
                     *      - conversation added
                     *      - onlineMeeting added in conversation
                     *      - onlineMeetingInvitation completed
                     *
                     * After the meeting is created, the web app is supposed to add modalities.
                     *
                     * Note, that when joining an online meeting anonymously, the "onlineMeetingInvitation completed"
                     * event does not arrive until the owner of the meeting admits the anonymous
                     * guest, so before that moment OnlineMeeting::state is "Connecting" and the
                     * promise returned by OnlineMeeting::start is pending.
                     *
                     * @param {String} [uri] - The URI of an existing meeting to join.
                     * @param {String} [name] - The guest name when joining an online meeting anonymously.
                     *
                     * @returns {Promise}
                     */
                    function start(options) {
                        var uri = options && options.uri;
                        var name = options && options.name;
                        return Task.wait(null).then(function () {
                            var operationId = guid(), dfdRequest, dfdStarted, dfdCompleted, dfdAdded;
                            pState(OnlineMeeting.State.Connecting);
                            // prevent calling start twice
                            delete self.start;
                            changed.fire();
                            // Send a POST to rel=startOnlineMeeting.
                            // The response to this request usually comes
                            // before any events, but this is not guaranteed.
                            if (uri) {
                                dfdRequest = ucwa.send('POST', { rel: 'joinOnlineMeeting' }, {
                                    data: {
                                        operationId: operationId,
                                        threadId: threadId,
                                        anonymousDisplayName: name,
                                        onlineMeetingUri: uri
                                    }
                                });
                            }
                            else {
                                dfdRequest = ucwa.send('POST', { rel: 'startOnlineMeeting' }, {
                                    data: {
                                        operationId: operationId,
                                        threadId: threadId,
                                        subject: subject || '',
                                        importance: priority || 'Normal'
                                    }
                                });
                            }
                            // Wait for "onlineMeetingInvitation started" event.
                            // The only reason to wait for this event is to get the rel=conversation link
                            // and then use that link to find the corresponding "onlineMeeting added" event.
                            // Note, that this event may not arrive at all, if UCWA rejected the attempt
                            // to create an online meeting.
                            dfdStarted = ucwa.wait({
                                type: 'started',
                                target: { rel: 'onlineMeetingInvitation' },
                                resource: { operationId: operationId }
                            }).then(function (event) {
                                assert(!rInvitation);
                                rInvitation = event.resource;
                                rInvitation.updated(update);
                            });
                            // Wait for "onlineMeetingInvitation completed" event.
                            // This event indicates the successful completion of
                            // the operation and this event usually arrives last.
                            // When joining anonymously an online meeting, this event
                            // arrives after the owner of the meeting admits the guest.
                            dfdCompleted = ucwa.wait({
                                type: 'completed',
                                target: { rel: 'onlineMeetingInvitation' },
                                resource: { operationId: operationId }
                            }).then(function (event) {
                                if (event.status != 'Success')
                                    throw Internal.EInvitationFailed(event.reason);
                            });
                            // Wait for "onlineMeeting added in conversation" event.
                            // After the invitation succeeds, UCWA sends a rel=onlineMeeting resource
                            // with the persistent join URL and other information about the meeting,
                            // so the ONlineMeeting model must start using this resource as the source
                            // of data.
                            dfdAdded = ucwa.wait({
                                type: 'added',
                                target: { rel: 'onlineMeeting' },
                                resource: function (r) {
                                    return rInvitation && r.link('conversation').href == rInvitation.link('conversation').href;
                                }
                            }).then(function (event) {
                                assert(!rMeeting);
                                rInvitation.updated.off(update);
                                rMeeting = event.resource;
                                rMeeting.updated(update);
                            });
                            return Task.waitAll([
                                dfdRequest,
                                dfdStarted,
                                dfdCompleted,
                                dfdAdded]);
                        }).then(function () {
                            pState(OnlineMeeting.State.Connected);
                        }).catch(function (error) {
                            // if something went wrong, restore the original state
                            self.start = methods.start;
                            pState(OnlineMeeting.State.Created, error);
                            changed.fire();
                            throw error;
                        });
                    }
                    //#endregion
                    //#region accept
                    /**
                     * Accepts the invitation to the online meeting. To do that this method:
                     *
                     *      - Sends a POST to rel=onlineMeetingInvitation/rel=accept.
                     *      - Waits for "onlineMeeting added" event to get the rel=onlineMeeting resource.
                     *      - Waits for "onlineMeetingInvitation completed" event.
                     *
                     * If the operation succeeds, the final state is:
                     *
                     *      - pState is "Connected"
                     *      - rMeeting is the rel=onlineMeeting resource
                     *
                     * If the operation fails, the final state is:
                     *
                     *      - pState is "Disconnected"
                     *
                     * The operation completes after receiving the "onlineMeetingInvitation completed" event.
                     * After the meeting is accepted, the corresponding conversation adds the messaging
                     * modality.
                     *
                     * @returns {Promise}
                     */
                    function accept() {
                        check.state(pState(), OnlineMeeting.State.Notified);
                        pState(OnlineMeeting.State.Connecting);
                        return Task.wait(null).then(function () {
                            var dfdMeetingAdded; // "onlineMeeting added" event
                            var dfdInvitationCompleted; // "onlineMeetingInvitation completed" event
                            var dfdInvitationRequest; // POST rel=onlineMeetingInvitation/rel=accept
                            dfdInvitationRequest = ucwa.send('POST', rInvitation.link('accept').href);
                            dfdMeetingAdded = ucwa.wait({
                                type: 'added',
                                target: { rel: 'onlineMeeting' },
                                resource: function (r) {
                                    return r.link('conversation').href == rInvitation.link('conversation').href;
                                }
                            }).then(function (event) {
                                assert(!rMeeting);
                                rInvitation.updated.off(update);
                                rMeeting = event.resource;
                                rMeeting.updated(update);
                            });
                            dfdInvitationCompleted = ucwa.wait({
                                type: 'completed',
                                target: { rel: 'onlineMeetingInvitation', href: rInvitation.href }
                            }).then(function (event) {
                                if (event.status != 'Success')
                                    throw Internal.EInvitationFailed(event.reason);
                            });
                            return Task.waitAll([
                                dfdInvitationRequest,
                                dfdMeetingAdded,
                                dfdInvitationCompleted
                            ]);
                        }).then(function () {
                            delete self.accept;
                            delete self.decline;
                            pState(OnlineMeeting.State.Connected);
                            changed.fire();
                        }).catch(function (error) {
                            pState(OnlineMeeting.State.Disconnected, error);
                            throw error;
                        });
                    }
                    //#endregion
                    //#region decline
                    function decline(reason) {
                        return ucwa.send('POST', rInvitation.link('decline').href, {
                            data: { reason: reason || 'Local' }
                        });
                    }
                    //#endregion
                    //#endregion
                    return self;
                }
                Internal.OnlineMeeting = OnlineMeeting;
                var OnlineMeeting;
                (function (OnlineMeeting) {
                    OnlineMeeting.State = StringEnum('Created', 'Notified', 'Connecting', 'Connected', 'Disconnected');
                    OnlineMeeting.AccessLevel = StringEnum('Everyone', 'Invited', 'Locked', 'SameEnterprise');
                    OnlineMeeting.AutomaticLeaderAssignment = StringEnum('Disabled', 'Everyone', 'SameEnterprise');
                    OnlineMeeting.EntryExitAnnouncement = StringEnum('Disabled', 'Enabled');
                    OnlineMeeting.LobbyBypassForPhoneUsers = StringEnum('Disabled', 'Enabled');
                    OnlineMeeting.PhoneUserAdmission = StringEnum('Disabled', 'Enabled');
                })(OnlineMeeting = Internal.OnlineMeeting || (Internal.OnlineMeeting = {}));
                //#endregion OnlineMeeting
                //#region MyOnlineMeeting
                /**
                 * The MyOnlineMeeting model encapsulates rel=myOnlineMeeting resource object and is the result of
                 * scheduling a meeting. It basically takes the resource object and exposing properties as either
                 * settable or read-only using an ObservableResource. The settable properties can trigger an
                 * aggregated update of the underlying resource object if the new values differ. The onlineMeetingUri
                 * property can be used to start/join the meeting.
                 *
                 * @param {UCWA} ucwa
                 * @param source - The rel=myOnlineMeeting resource selector.
                 *
                 * @property {String} accessLevel - Controls who is let into the meeting.
                 *
                 *  - Everyone
                 *  - Invited - Only users in the attendees/leaders, all others are put in the lobby.
                 *  - Locked - All users except the organizer are put into the lobby.
                 *  - SameEnterprise - Only users from the same enterprise, all others are put in the lobby.
                 *
                 * @property {Array<String>} attendees - SIP URIs of users to include as attendees.
                 * @property {String} automaticLeaderAssignment - Which participants are automatically promoted to leaders.
                 *
                 *  An online meeting organizer can schedule a meeting so that users are automatically promoted
                 *  to the leader role when they join the meeting. For example, if the meeting is scheduled with
                 *  automatic promotion policy set to "SameEnterprise", then any participants
                 *  from the organizer's company are automatically promoted to leaders when they join the meeting.
                 *  Conference leaders can still promote specific users to the leader role, including anonymous users.
                 *
                 * @property {String} description - Purpose of the meeting
                 * @property {String} entryExitAnnouncement - The attendance announcements status for the online meeting.
                 *
                 *  When attendance announcements are enabled, the online meeting will announce the names
                 *  of the participants who join the meeting through audio.
                 *
                 * @property {Date} expirationTime - The UTC date and time after which the online meeting can be deleted.
                 *
                 *  The day and time must be between one year before, and ten years after,
                 *  the current date and time on the server.
                 *
                 * @property {Array<String>} leaders - Array of SIP URIs of users to include as leaders.
                 *
                 *  The organizer will automatically be added to the leaders list.
                 *
                 * @property {String} lobbyBypassForPhoneUsers - When enabled phone users will skip the meeting lobby.
                 * @property {String} phoneUserAdmission - Whether participants can join the online meeting over the phone.
                 *
                 *  Setting this property to true means that online meeting participants can join the meeting
                 *  over the phone through the Conferencing Auto Attendant (CAA) service.
                 *
                 * @property {String} subject - The subject of the online meeting.
                 * @property {String} joinUrl - The URL that is used when the online meeting is joined from the web.
                 * @property {String} onlineMeetingId - Identifies this meeting among the other online meetings that are scheduled by the organizer.
                 *
                 *  The online meeting ID is unique within the organizer's list of scheduled online meetings.
                 *
                 * @property {String} onlineMeetingUri - The online meeting URI.
                 *
                 *  The online meeting URI is used by participants to join this online meeting.
                 *  It can be used to join the meeting:
                 *
                 *      client.startMeeting({
                 *          uri: scheduledMeeting.onlineMeetingUri()
                 *      });
                 *
                 * @property {String} organizerUri - he URI of the online meeting organizer: the person who scheduled the meeting.
                 *
                 *  Organizers can enumerate or change only the conferences that they organize.
                 *
                 */
                function MyOnlineMeeting(ucwa, options) {
                    return Internal.ObservableResource(ucwa, {
                        source: options.source,
                        properties: {
                            accessLevel: {},
                            attendees: {},
                            automaticLeaderAssignment: {},
                            description: {},
                            entryExitAnnouncement: {},
                            expirationTime: {
                                parse: timeStampToDate,
                                convert: dateToTimeStamp,
                                prepare: function (val) {
                                    return val && val.toJSON();
                                }
                            },
                            joinUrl: { readOnly: true },
                            leaders: {},
                            lobbyBypassForPhoneUsers: {},
                            onlineMeetingId: { readOnly: true },
                            onlineMeetingUri: { readOnly: true },
                            organizerUri: { readOnly: true },
                            phoneUserAdmission: {},
                            subject: {}
                        }
                    });
                }
                Internal.MyOnlineMeeting = MyOnlineMeeting;
                //#endregion MyOnlineMeeting
                //#region Message
                /**
                 * This is an incoming or an outgoing instant message in a conversation.
                 *
                 * @param {UCWA} ucwa
                 * @param {Property<HRef>|HRef} [href] - The href of the "message" resource.
                 * @param {Participant} [sender]
                 * @param {String} text - The text/plain representation of the message.
                 * @param {String} html - The text/html representation of the message.
                 * @param {Date} [time=new Date]
                 * @param {Property<String>|String} [status="Succeeded"]
                 *
                 * @property {String} text - The text/plain representation of the message.
                 * @property {String} html - The text/html representation of the message.
                 * @property {Date} timestamp
                 * @property {MessageStatus} status
                 * @property {MessageDirection} direction
                 *
                 * @member {Person} sender - Note, that it's a person object, not a participant.
                 *
                 *      It cannot be a participant because the participant may leave the
                 *      conversation, while UI still needs to know who sent the message.
                 *
                 */
                function Message(options) {
                    //#region ctor arguments
                    var ucwa = options.ucwa;
                    var href = options.href || ''; // message from the invitation doesn't have a href
                    var sender = options.sender;
                    var status = options.status || MessageStatus_Succeeded;
                    var time = options.time || new Date;
                    var text = options.text;
                    var html = options.html;
                    options = null;
                    //#endregion
                    // infer text from html
                    if (html && !text) {
                        try {
                            text = convertHtmlToText(html);
                        }
                        catch (err) {
                            text = '';
                        }
                    }
                    // infer html from text
                    if (text && !html) {
                        try {
                            html = convertTextToHtml(text);
                        }
                        catch (err) {
                            html = '';
                        }
                    }
                    if (isString(href))
                        href = ConstProperty(href);
                    if (isString(status))
                        status = Property({ value: status });
                    ucwa.wait({
                        type: 'completed',
                        target: { rel: 'message' },
                        resource: function (r) {
                            // href() is not available immediately
                            return r.href == href();
                        }
                    }).then(function (event) {
                        status(event.status == 'Success' ? MessageStatus_Succeeded : MessageStatus_Failed, event.reason);
                    });
                    return Model({
                        sender: sender.person,
                        text: ConstProperty(disableHtmlInText(text)),
                        html: ConstProperty(sanitizeHtml(html)),
                        isEdited: ConstProperty(false),
                        isDeleted: ConstProperty(false),
                        timestamp: ConstProperty(time),
                        direction: ConstProperty(href() || href() == '' ? MessageDirection_Incoming : MessageDirection_Outgoing),
                        status: status.asReadOnly()
                    });
                }
                Internal.Message = Message;
                var MessageStatus_Pending = 'Pending';
                var MessageStatus_Succeeded = 'Succeeded';
                var MessageStatus_Failed = 'Failed';
                var MessageDirection_Incoming = 'Incoming';
                var MessageDirection_Outgoing = 'Outgoing';
                //#endregion Message
                //#region ChatService
                /**
                 * The ChatService model is one of conversation modalities, which establishes
                 * the channel for participants to send instant messages.
                 *
                 * @param {UCWA} ucwa
                 * @param {Conversation} [conversation] - The parent conversation object.
                 * @param {Property<String>} [guestName]
                 * @param {Resource} [resource] - The underlying "messagingInvitation" resource.
                 *
                 * @member {Object} [toast] - Deprecated.
                 *
                 *      - {Participant} sender - The sender of the invitation.
                 *      - {String} text - The message.
                 *      - {String} priority
                 *      - {String} subject
                 *
                 * @property {Modality.State} state
                 *
                 *      The modality is created in the "Created" state and goes immediately
                 *      to the "Notified" state if it's created to represent an incoming IM
                 *      invitation.
                 *
                 * @collection {Message} messages - Collection of all incoming and outgoing messages.
                 *
                 *      The id/key of outgoing messages can be specified in the `send` or `start` methods.
                 *      The id/key of incoming messages is generated every time and cannot be predicted.
                 *      To observe incoming and outgoing messages one can use the following code snippet:
                 *
                 *          modality.messages.added(function (message) {
                 *              console.log(message.text());
                 *          });
                 *
                 * @collection {Participant} typingParticipants - Participants who are currently typing in the conversation.
                 * @collection {MessageFormat} supportedMessageFormats
                 *
                 * @command {Promise} start - Sends the messaging invitation to the participants.
                 * @command {Promise} stop - Terminates the instant messaging modality in the conversation.
                 * @command {Promise} sendMessage - Sends a message to the conversation.
                 * @command {Promise} reject - Declines the messaging invitation.
                 * @command {Promise} accept - Accepts the new messaging invitation.
                 * @command {Promise} sendIsTyping - Notifies the server that the user is typing a message.
                 *
                 *  This method needs to be called periodically since the server resets the typing status
                 *  of the participant after a few seconds and the client doesn't know when the status is reset.
                 *  Typically this happens after 5-6 seconds. A possible way to invoke this method:
                 *
                 *      var input = document.querySelector('input');
                 *      var typing = false;
                 *
                 *      input.onkeydown = function () {
                 *          if (!typing) {
                 *              messaging.sendIsTyping();
                 *              typing = true;
                 *              setTimeout(function () {
                 *                  typing = false;
                 *              }, 1500);
                 *          }
                 *      };
                 *
                 *  This implementation sends the typing notification every 1.5 seconds while the user is typing.
                 *  A typical mistake in implementing such UI is to send the notification every time the user hits a keystroke.
                 *
                 */
                function ChatService(options) {
                    //#region locals
                    var ucwa = options.ucwa;
                    var conversation = options.conversation;
                    var participantKeys = options.participantKeys || {};
                    var rInvitation = options.resource; // rel=messagingInvitation
                    var guestName = options.guestName;
                    options = null; // no need to use options beyond this point
                    var mtchannel = ucwa.mtchannel('chat');
                    var participants = conversation.participants; // observable collection
                    var localParticipant = conversation.selfParticipant;
                    var subject = conversation.topic; // observable property
                    var priority = conversation.priority; // observable property
                    var threadId = conversation.id; // observable property
                    var messages = Collection();
                    var typingParticipants = Collection();
                    var rMessaging; // rel=messaging
                    var state = Property();
                    var nMessageEvents = 0; // the number of received "message completed" events
                    var sStartingMessaging = {}; // serves as state.reason when state=Connecting
                    // Modality.State.... stuff is too long: to avoid splitting one line into
                    // had to make these shorter aliases; also good for minifying
                    var cCreated = Internal.Modality.State.Created;
                    var cNotified = Internal.Modality.State.Notified;
                    var cConnected = Internal.Modality.State.Connected;
                    var cConnecting = Internal.Modality.State.Connecting;
                    var cDisconnected = Internal.Modality.State.Disconnected;
                    var dfdStart; // promise returned by ChatService::start
                    var negotiatedFormats = Collection({
                        get: function () {
                            var formats = rMessaging.get('negotiatedMessageFormats');
                            var dict = map(formats, function (fmt) {
                                return fmt == 'Plain' ? 'Text' : fmt;
                            });
                            return StringEnum.apply(null, dict);
                        }
                    });
                    var self = Model({
                        state: state.asReadOnly(),
                        messages: messages.asReadOnly(),
                        isAlerting: ConstProperty(true),
                        alertFilters: Collection.empty,
                        supportedMessageFormats: negotiatedFormats.asReadOnly(),
                        typingParticipants: typingParticipants.asReadOnly()
                    });
                    //#endregion
                    //#region internals
                    function makeMultipartRequest(request, context, revision, boundary) {
                        var contentId = '367A2DAE00F7417FB5CEFE6364C97D31';
                        var strRequest = JSON.stringify(extend({}, request, { customContent: 'CID:' + contentId }));
                        var strContext = JSON.stringify(context);
                        var payload = [
                            '--' + boundary,
                            'Content-Type: application/vnd.microsoft.com.ucwa+json',
                            'Content-Length: ' + strRequest.length,
                            '',
                            strRequest,
                            '--' + boundary,
                            'Content-Type: text/json',
                            'Content-Id: ' + contentId,
                            // this specified field allows the multipart content always processed to
                            // the endpoint, which may not regiser 'text/json' as its supported format.
                            'Content-Disposition: render; handling=optional',
                            '',
                            strContext,
                            '--' + boundary + '--',
                            ''
                        ].join('\r\n');
                        return {
                            headers: {
                                'Content-Type': 'multipart/related;boundary=' + boundary + ';type="application/vnd.microsoft.com.ucwa+json"',
                                'Content-Length': payload.length,
                                'X-MS-RequiresMinResourceVersion': revision
                            },
                            data: payload
                        };
                    }
                    function getParticipantKey(href) {
                        return participantKeys[href] || href;
                    }
                    function getMessageData(rMessage, rel) {
                        // "data:text/plain;charset=utf-8,how+are+you%3F" => "how are you?"
                        return DataUri(rMessage.relatedHref(rel) || 'data:,').data || '';
                    }
                    /**
                     * @param {String} format - "Plain" or "Html"
                     */
                    function isMessageFormatNegotiated(format) {
                        try {
                            return indexOf(rMessaging.get('negotiatedMessageFormats'), format) >= 0;
                        }
                        catch (err) {
                            // either rel=messaging is absent or it's missing the list of formats
                            return false;
                        }
                    }
                    /**
                     * The point of this function is to chose one data format to
                     * send to the server based on a set of formats given to SkypeWeb
                     * and a set of formats accepted by the remote participant.
                     *
                     * It's unlikely that SkypeWeb and UCWA will ever support RTF or
                     * other text formats that will be exotic to web clients, so this function
                     * can assume that only two formats exist: text/plain and text/html.
                     *
                     * This function must take into consideration remote clients
                     * that cannot read html (OWA for example).
                     *
                     * @param {Dictionary} message - { text : "...", html : "..." }
                     * @returns {Dictionary} - { type : "text/...", data : "..." }
                     */
                    function chooseMessageFormat(message) {
                        // if this is the very first message in a conversation
                        // that is being started, there will be no rel=messaging
                        // resource and the list of negotiated formats will be empty
                        if ('html' in message)
                            return isMessageFormatNegotiated('Html') || !rMessaging ?
                                { type: 'text/html', data: message.html + '' } :
                                { type: 'text/plain', data: convertHtmlToText(message.html + '') };
                        if ('text' in message)
                            return isMessageFormatNegotiated('Plain') || !isMessageFormatNegotiated('Html') ?
                                { type: 'text/plain', data: message.text + '' } :
                                { type: 'text/html', data: convertTextToHtml(message.text + '') };
                        throw EInvalidArgument('message', 'must contain either `text` or `html` format');
                    }
                    /**
                     * Reads a resource representing an incoming message
                     * and adds a corresponding message model to the collection.
                     */
                    function addIncomingMessage(resource) {
                        var key = getParticipantKey(resource.link('participant').href);
                        var sender = participants(key);
                        var message = Message({
                            href: resource.href,
                            sender: sender,
                            text: getMessageData(resource, 'plainMessage'),
                            html: getMessageData(resource, 'htmlMessage'),
                            time: timeStampToDate(resource.properties.timeStamp),
                            ucwa: ucwa
                        });
                        // don't add the invitation message twice to the collection
                        if (!isInvitationMessage(message))
                            messages.add(message);
                    }
                    function isInvitationMessage(message) {
                        var first = messages(0);
                        return messages.size() == 1 && nMessageEvents == 1 &&
                            first.text() == message.text() &&
                            first.html() == message.html();
                    }
                    function processFirstMessageInInvitation() {
                        var dmsg = DataUri(rInvitation.relatedHref('message') || 'data:,');
                        var text = dmsg.mime == 'text/plain' ? dmsg.data : null;
                        var html = dmsg.mime == 'text/html' ? dmsg.data : null;
                        // inviter is placed in the participants collection when the conversation is
                        // created from the invitation.
                        var sender = isIncoming() ? participants(0) : localParticipant;
                        var message = Message({
                            sender: sender,
                            text: text,
                            html: html,
                            ucwa: ucwa
                        });
                        // sometimes the invitation doesn't contain a message
                        if (text || html)
                            messages.add(message);
                        // TODO: the .toast member is deprecated and will be removed
                        self.toast = Model({
                            sender: sender,
                            text: message.text(),
                            html: message.html(),
                            priority: rInvitation.properties.importance,
                            subject: disableHtmlInText(rInvitation.properties.subject)
                        });
                    }
                    function addOutgoingMessage(options) {
                        var message = Message({
                            href: options.href,
                            sender: localParticipant,
                            text: options.text,
                            html: options.html,
                            status: options.status,
                            ucwa: ucwa
                        });
                        // for outgoing messages the caller may specify the id
                        messages.add(message, options.id || guid());
                        return message;
                    }
                    function onIncomingMessage(event) {
                        var rMessage = event.resource;
                        if (event.type == 'completed' && event.target.rel == 'message' && rMessaging &&
                            rMessage.get('direction') == 'Incoming' && rMessage.link('messaging').href == rMessaging.href) {
                            nMessageEvents++;
                            addIncomingMessage(rMessage);
                        }
                    }
                    function onOutgoingMessage(messaging, message) {
                        if (rMessaging && messaging == rMessaging.href)
                            addOutgoingMessage(message);
                    }
                    function receiveIncomingMessages() {
                        ucwa.event(onIncomingMessage);
                        mtchannel.data(onOutgoingMessage);
                    }
                    function observeMessagingState() {
                        assert(rMessaging, 'rel=messaging must be known before starting observing its state');
                        rMessaging.updated(function () {
                            var newState = rMessaging.get('state', '');
                            if (newState == 'Disconnected')
                                state(Internal.Modality.State.Disconnected);
                            // this triggers the custom getter that pulls the formats
                            // from the resource and updates the collection
                            negotiatedFormats.get();
                        });
                    }
                    function getConversationResource() {
                        // sHref is an internal id available in this file
                        var href = conversation[Internal.sHref];
                        return href ? ucwa.get(href) : null;
                    }
                    function isConferencing() {
                        var rc = getConversationResource();
                        return rc && rc.get('state', '') == 'Conferenced';
                    }
                    function isMessagingActive() {
                        var rc = getConversationResource();
                        var href = rc && rc.hasLink('messaging') && rc.link('messaging').href;
                        var rm = href && ucwa.exists(href) && ucwa.get(href);
                        return rm && rm.get('state', null) == 'Connected';
                    }
                    function isIncomingMeetingRequest() {
                        return conversation.meeting &&
                            conversation.meeting.state() == 'Notified' &&
                            conversation.meeting.availableModalities.messaging();
                    }
                    function isIncoming() {
                        return rInvitation ? rInvitation.get('direction') == 'Incoming' : false;
                    }
                    function onServerEvent(event) {
                        var resource = event.resource;
                        var target = event.target;
                        var context = event['in'];
                        var typingParticipant;
                        // if the event includes the 'in' property, it indicates it is for
                        // a typingParticipant's 'added' or 'deleted' events, other than for a participant's events.
                        if (context && rMessaging && rMessaging.hasLink('typingParticipants') && context.href == rMessaging.link('typingParticipants').href) {
                            if (event.type == 'deleted') {
                                typingParticipants.remove(target.href);
                            }
                            else if (event.type == 'added') {
                                typingParticipant = participants(getParticipantKey(target.href));
                                if (typingParticipant && !typingParticipants(target.href))
                                    typingParticipants.add(typingParticipant, target.href);
                            }
                        }
                        // messaging can be added to an existing 1:1 conversation by the remote participant
                        if (event.type == 'started' && target.rel == 'messagingInvitation' && resource &&
                            resource.has('direction') && resource.get('direction') == 'Incoming' &&
                            resource.link('conversation').href == conversation[Internal.sHref]) {
                            rInvitation = resource;
                            processInvitation();
                        }
                    }
                    function setResource(r) {
                        rMessaging = r;
                        rMessaging.deleted(function () {
                            ucwa.event.off(onServerEvent);
                            ucwa.event.off(onIncomingMessage);
                            mtchannel.data.off(onOutgoingMessage);
                        });
                    }
                    function defineAsyncCommand(name, states, method) {
                        var enabled = Property();
                        self[name] = Command(async(method), enabled);
                        state.changed(function (value) {
                            var isEnabled = contains(states, function (s) {
                                return isArray(s) ?
                                    value == s[0] && state.reason === s[1] :
                                    value == s;
                            });
                            enabled(isEnabled);
                        });
                    }
                    //#endregion
                    //#region start
                    /**
                     * Sends the messaging invitation to participants.
                     * Under the hood it does the following to start messaging:
                     *
                     *      - Sends a POST to rel=startMessaging or rel=conversation/messaging/addMessaging.
                     *      - Waits for "messagingInvitation completed" event.
                     *      - Starts receiving "message completed" events.
                     *
                     * @param {String} to - SIP URI of whom to send the invitation to.
                     * @param {String} [name] - Display name for anonymously joined meetings.
                     * @param {String|Object} [message] - The first message in the conversation.
                     *
                     *  The message can contain the desired id of the first message:
                     *  see comments for the `send` method.
                     *
                     *  To start the conversation with the first plain text message use:
                     *
                     *      im.start('This is a plain text message');
                     *      im.start({ text : 'This is a plain text message' });
                     *
                     *  To start the conversation with the first html message use:
                     *
                     *      im.start({ html : '<b>This is a html message</b>' });
                     *
                     *  Note, that if the first message contains only the html format
                     *  and it's invalid, the .start method will return a rejected promise.
                     *
                     * @param [context] - An arbitrary object that can be serialized.
                     *
                     *  If set, the POST request to UCWA will be sent in a special multipart
                     *  format with all the regular invitation parameters plus this context.
                     *  The context is supposed to describe the invitation, so that the remote
                     *  participant may know why the request is sent.
                     *
                     * @returns {Promise<Message>}
                     */
                    defineAsyncCommand('start', [cCreated, [cConnecting, sStartingMessaging], cDisconnected], function (options) {
                        record('IM_Start');
                        assert.args(options || {}, {
                            to: 'Void|NotEmptyString',
                            message: 'Void|String|Dictionary'
                        });
                        var message = options && options.message;
                        var name = options && options.name || guestName && guestName();
                        var to = options && options.to;
                        var context = options && options.context;
                        var boundary = options && options.boundary; // can be given by unit tests
                        var operationId = options && options.operationId || guid(); // can be given by unit tests
                        var sessionContext = options && options.sessionContext || guid(); // can be given by unit tests
                        options = null;
                        var firstMessage; // firstMessage === await im.start(...)
                        var isMeeting = conversation.isGroupConversation();
                        if (isString(message))
                            message = { text: message };
                        // in p2p mode take URI of the remote participant
                        if (!isMeeting) {
                            if (!to)
                                to = participants(0).uri();
                            else
                                check(participants.size() == 0, 'ambiguous remote party in 1:1 call');
                            check(to, 'the remote participant URI is not specified');
                        }
                        state(Internal.Modality.State.Connecting);
                        return dfdStart = Task.wait(null).then(function () {
                            if (conversation.meeting) {
                                if (conversation.meeting.state() == OnlineMeeting.State.Created) {
                                    return conversation.meeting.start({
                                        name: name,
                                        uri: conversation.uri()
                                    });
                                }
                            }
                            else if (isMeeting) {
                                return conversation.addMeeting().start();
                            }
                        }).then(function () {
                            var rc = getConversationResource();
                            // if there is no existing rel=conversation resource yet,
                            // send the messaging invitation to the global rel=startMessaging link;
                            // otherwise add the messaging modality to an existing conversation by
                            // sending the invitation to rel=conversation/messaging/addMessaging link.
                            if (!rc)
                                return ucwa.get({ rel: 'communication' }).link('startMessaging');
                            return ucwa.send('GET', rc.link('messaging').href).then(function (rMessaging) {
                                return rMessaging.link('addMessaging');
                            });
                        }).then(function (startMessagingLink) {
                            // the next step is to send a POST request to initiate a messaging invitation
                            // and to await the "messagingInvitation started" event that corresponds to
                            // the initiated invitation
                            var status, parameters, dfdPost, dfdCompleted, dfdStarted, content, request;
                            // parameters common for 1:1 and 1:N conversations
                            parameters = {
                                operationId: operationId,
                                threadId: threadId()
                            };
                            // parameters specific to 1:1 conversations
                            if (!isConferencing()) {
                                extend(parameters, {
                                    to: to,
                                    // in 1:N conversations these parameters are set
                                    // on the conversation as a whole, not on the modality
                                    importance: priority() || 'Normal',
                                    subject: subject() || '',
                                    sessionContext: sessionContext
                                });
                            }
                            // check whether the user specified the first message in
                            // the conversation: this message should be embedded into
                            // the messaging invitation
                            if (message) {
                                content = chooseMessageFormat(message);
                                parameters.message = 'data:' + content.type + ',' + DataUri.encodeData(content.data);
                                status = Property();
                                status(MessageStatus_Pending);
                                // add the first message in the conversation to the chat history
                                firstMessage = addOutgoingMessage({
                                    id: message.id,
                                    href: Property(),
                                    text: message.text,
                                    html: message.html,
                                    status: status
                                });
                            }
                            request = context && startMessagingLink.revision >= 2 ?
                                makeMultipartRequest(parameters, context, 2, boundary || random()) :
                                { data: parameters };
                            // UCWA rejects attempts to send the POST request inside a batch request
                            request.nobatch = true;
                            dfdPost = ucwa.send('POST', startMessagingLink.href, request);
                            // if there was a first message sent inside the invitation,
                            // update its status based on the result of the POST request
                            if (status) {
                                dfdPost.then(function () {
                                    status(MessageStatus_Succeeded);
                                }, function (err) {
                                    status(MessageStatus_Failed, err);
                                });
                            }
                            // Wait for the "messagingInvitation started" event to get the invitation resource for the cancellation purpose
                            // even before the 'messagingInvitation completed' arrives
                            dfdStarted = ucwa.wait({
                                type: 'started',
                                target: { rel: 'messagingInvitation' },
                                resource: function (r) {
                                    return r.get('operationId', '') == operationId || r.get('threadId', '') == threadId();
                                }
                            }).then(function (event) {
                                rInvitation = event.resource;
                            });
                            // wait for the "messagingInvitation completed" event that corresponds to the given conversation
                            dfdCompleted = ucwa.wait({
                                type: 'completed',
                                target: { rel: 'messagingInvitation' },
                                resource: function (r) {
                                    return r.get('operationId', '') == operationId || r.get('threadId', '') == threadId();
                                }
                            }).then(function (event) {
                                if (event.status == 'Failure')
                                    throw Internal.EInvitationFailed(event.reason);
                                rInvitation = event.resource;
                                setResource(ucwa.get(rInvitation.link('messaging').href));
                                // if the messaging is started in a conference, UCWA sends
                                // the rel=messagingInvitation/rel=acceptedByParticipant resource
                                // that does not contain the "name" property and contains invalid "uri"
                                // (it points to the URI of the online meeting instead of the participant);
                                // however UCWA returns the correct values if it's asked for them
                                // explicitly - via a GET request to the rel=participant
                                if (isConferencing() && rInvitation.hasLink('acceptedByParticipant'))
                                    ucwa.send('GET', rInvitation.link('acceptedByParticipant').href);
                            });
                            // The intent here is to:
                            //
                            //      1. Send a POST to rel=startMessaging.
                            //      2. Wait for the "messagingInvitation completed" event.
                            //      3. If the event arrives, cancel the POST and proceed.
                            //      4. If the event has not arrived, but the POST failed, stop waiting for the event and fail.
                            //      5. If the POST succeeds, continue waiting for the event.
                            //
                            // Note, that the event may arrive before a response from the POST.
                            // The Task.waitAll below lets achieve 1, 2, 4, 5 but not 3. However, #3
                            // (cancelling the POST if the event arrives first) will not make
                            // any difference, as almost always POST completes before the event arrives.
                            // The problem is what if the POST completes, but the event never arrives:
                            // the task will stuck in this state indefinitely.
                            return Task.waitAll([dfdPost, dfdStarted, dfdCompleted]);
                        }).then(function () {
                            observeMessagingState();
                            // add participants to a meeting created by this start().
                            if (isConferencing())
                                conversation[Internal.sInternal].updateParticipants();
                            // UCWA has accepted the request to start messaging,
                            // so now it's time to wrap everything up: set the
                            // final state and so on.
                            state(Internal.Modality.State.Connected);
                            return firstMessage;
                        }).catch(function (error) {
                            // if something went wrong, set the final state and quit
                            state(Internal.Modality.State.Disconnected, error);
                            if (rInvitation && rInvitation.hasLink('cancel'))
                                ucwa.send('POST', rInvitation.link('cancel').href);
                            // rethrow the error, so that it may be processed by the caller
                            throw error;
                        }).finally(function () {
                            dfdStart = null;
                        });
                    });
                    //#endregion
                    //#region sendMessage
                    /**
                     * Sends a message to all the participants the conversation.
                     *
                     * @param message - The content of the message to send.
                     *
                     *      If the this parameter is a plain string, SkypeWeb
                     *      assumes that it is in the text/plain format.
                     *      If this parameter has the form of { html : "..." }
                     *      then the message is sent as text/html.
                     *
                     *          im.send("This is a plain text message");
                     *          im.send({ text : "This is a plain text message." });
                     *          im.send({ html : "This text is <span style="color:blue">blue</span>." });
                     *
                     *      If several message formats are specified, only one of them
                     *      will be chosen. Note, that if the given html representation
                     *      of the message appears invalid, the .send method returns
                     *      a rejected promise.
                     *
                     * @param [format="text"] - Either "text" or "html".
                     *
                     *      The are two ways to specify the format of the message:
                     *
                     *          im.send("abc", "html");
                     *          im.send({ html: "abc" });
                     *
                     * @param {String} [.text] - The text/plain format of the message.
                     * @param {String} [.html] - The text/html format of the message.
                     * @param {String} [.id] - The unique id of the message.
                     *
                     *      This id will be used as the key to the `messages` collection
                     *      and thus can be used to associated the message object in the
                     *      `messages` collection with the message sent via the `send` method:
                     *
                     *          var id = Math.random();
                     *          var promise = im.sendMessage({ text: "Hi", id: id }); // it's pending
                     *          var msg = im.messages(id); // this is the pending message
                     *          assert.equal(msg.status(), "Processing");
                     *
                     *      If the given `id` conflicts with an existing message id,
                     *      no message will be sent to the server or added to the collection
                     *      and the returned promise will be rejected.
                     *
                     * @returns {Promise<Message>}
                     *
                     *      As usual, this method returns a promise that resolves
                     *      after the operation succeeds or gets rejected after
                     *      the operation fails. To track the progress of the
                     *      operation one can use the following code snippet:
                     *
                     *          im.send(message).then(
                     *              function (msg) { alert("The message has been sent.") },
                     *              function (err) { alert("The message could not be sent.") });
                     *
                     *      The returned promise has the "status" observable
                     *      property that can be used to monitor the progress:
                     *
                     *          im.send(message).status.changed(function (status) {
                     *              console.log("im.send: " + status);
                     *          });
                     *
                     *      It is noteworthy that the message gets added to the `messages`
                     *      collection immediately after the call to `send` and the status of the
                     *      added message is "Pending". Then the server sends an event
                     *      that changes the status to "Succeeded".
                     */
                    defineAsyncCommand('sendMessage', [cCreated, cConnecting, cConnected, cDisconnected], function (message, format) {
                        record('IM_sendMessage');
                        if (isString(message)) {
                            message = format && format.toLowerCase() == 'html' ?
                                { html: message } :
                                { text: message };
                        }
                        if (messages(message.id))
                            throw EAlreadyExists('message.id = ' + message.id);
                        // sendMessage can be used to start conversation
                        if (state() != cConnected) {
                            // there is a pending start, queue the message to be
                            // sent after the connection is established
                            if (dfdStart) {
                                return dfdStart.then(function () {
                                    return self.sendMessage(message);
                                });
                            }
                            return self.start({ message: message });
                        }
                        // the status should be a property here, since it is to be updated
                        // when processing events from the server
                        var status = Property({ value: 'Pending' });
                        var href = Property();
                        var dfd;
                        var content = chooseMessageFormat(message);
                        // The message model should be created and added to the "messages"
                        // collection right away, but at this moment UCWA has neither replied
                        // to the POST request to rel=sendMessage, nor has it sent the
                        // "message completed" event. To handle this difficulty, the message
                        // model is given two properties with no value: the "href" and the
                        // "status" properties. The message model takes them and waits until
                        // the "href" property changes its value: this value is set after
                        // the modality receives a HTTP 201 reply to the POST request - the HTTP 201
                        // contains the Location header with the href of the rel=message resource.
                        var msgobj = addOutgoingMessage({
                            id: message.id,
                            href: href,
                            text: message.text,
                            html: message.html,
                            status: status
                        });
                        dfd = ucwa.send('POST', rMessaging.link('sendMessage').href, {
                            headers: { 'Content-Type': content.type },
                            data: content.data,
                            nobatch: true // UCWA fails with HTTP 500 if an IM is sent inside a batch request
                        });
                        dfd.then(function (rMessage) {
                            // the message model could not receive "message completed" event
                            // and update its status, because it did not know the href of the
                            // message resource; now the href becomes known (it arrives inside
                            // the Location header)
                            href(rMessage.href);
                            mtchannel.broadcast(rMessaging.href, {
                                href: rMessage.href,
                                text: message.text,
                                html: message.html
                            });
                        }, function (err) {
                            status(MessageStatus_Failed, err);
                        });
                        return dfd.then(function () {
                            return msgobj;
                        });
                    });
                    //#endregion
                    //#region stop
                    /**
                     * Terminates the ongoing messaging session.
                     */
                    defineAsyncCommand('stop', [Internal.Modality.State.Connected, Internal.Modality.State.Connecting], function () {
                        if (dfdStart)
                            return dfdStart.cancel();
                        state(Internal.Modality.State.Disconnecting);
                        return ucwa.send('POST', rMessaging.link('stopMessaging').href).then(function () {
                            state(Internal.Modality.State.Disconnected);
                        }, function (error) {
                            // restore the original state
                            state(Internal.Modality.State.Connected);
                            throw error;
                        });
                    });
                    //#endregion
                    //#region reject
                    /**
                     * Rejects the incoming messaging invitation.
                     */
                    defineAsyncCommand('reject', [Internal.Modality.State.Notified], function (reason) {
                        state(Internal.Modality.State.Disconnecting);
                        return Task.wait().then(function () {
                            // in UCWA an incoming meeting request tells which modalities
                            // are available in the meeting; if Messaging is available, then
                            // the chat's reject command can decline the meeting request
                            return isIncomingMeetingRequest() ?
                                conversation.meeting.decline(reason) :
                                ucwa.send('POST', rInvitation.link('decline').href, {
                                    data: { reason: reason || 'Local' }
                                });
                        }).then(function () {
                            state(Internal.Modality.State.Disconnected);
                        }, function (error) {
                            // restore the original state
                            state(Internal.Modality.State.Notified);
                            throw error;
                        });
                    });
                    //#endregion
                    //#region accept
                    /**
                     * To accept the messaging invitation, it does the following:
                     *
                     *      - Sends a POST request to rel=messagingInvitation.
                     *      - Waits for "messagingInvitation completed" event.
                     */
                    defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (args) {
                        state(Internal.Modality.State.Connecting);
                        // in UCWA an incoming meeting request tells which modalities
                        // are available in the meeting; to accept a modality the app
                        // needs to accept the meeting request first and then send to UCWA
                        // a request to start the modality
                        if (isIncomingMeetingRequest()) {
                            return conversation.meeting.accept().then(function () {
                                // enable the .start command
                                state(Internal.Modality.State.Connecting, sStartingMessaging);
                                // args.operationId is set by unit tests
                                return self.start(args);
                            });
                        }
                        // send a POST request to rel=messagingInvitation/accept
                        var dfdAccept = ucwa.send('POST', rInvitation.link('accept').href);
                        // await "messagingInvitation completed" event
                        var dfdCompleted = ucwa.wait({
                            type: 'completed',
                            target: { rel: 'messagingInvitation', href: rInvitation.href }
                        }).then(function () {
                            setResource(ucwa.get(rInvitation.link('messaging').href));
                        });
                        return Task.waitAll([dfdAccept, dfdCompleted]).then(function () {
                            observeMessagingState();
                            // now the invitation is considered to be successfully accepted,
                            // so set the final state, make available certain methods and so on
                            state(Internal.Modality.State.Connected);
                        }).catch(function (error) {
                            // if something went wrong, set the final state and quit
                            state(Internal.Modality.State.Disconnected, error);
                            // rethrow the error, so that it may be catched by the caller
                            throw error;
                        });
                    });
                    //#endregion
                    //#region sendIsTyping
                    /**
                     * To set IsTyping for the function is used to broadcast the user's typing status.
                     * When the function is called, the setIsTyping resource will start a short timer on
                     * the server during which the user will show up in the typingParticipants (UCWA)
                     * for this conversation (UCWA). If the  function is not called again within that time,
                     * the user will be removed from typingParticipants.
                     */
                    defineAsyncCommand('sendIsTyping', [Internal.Modality.State.Connected], function () {
                        return ucwa.send('POST', rMessaging.link('setIsTyping').href, {
                            nobatch: true
                        });
                    });
                    //#endregion
                    function processInvitation() {
                        // if another tab starts a conversation, all other tabs get the outgoing invitation event
                        state(isIncoming() ? cNotified : cConnecting);
                        processFirstMessageInInvitation();
                        // the invitation can be cancelled by the remote party
                        // and this must be somehow reflected in the modality
                        ucwa.wait({
                            type: 'completed',
                            status: 'Failure',
                            target: { rel: 'messagingInvitation', href: rInvitation.href }
                        }).then(function (event) {
                            state(Internal.Modality.State.Disconnected, event.reason);
                        });
                        // the invitation can be accepted by the server without the client's consent
                        ucwa.wait({
                            type: 'completed',
                            status: 'Success',
                            target: { rel: 'messagingInvitation', href: rInvitation.href }
                        }).then(function (event) {
                            // if the state is still Notified and the invitation is incoming,
                            // then the "completed" event is sent because another endpoint has
                            // accepted the request as the accept() method would've changed
                            // the state to Connecting; if the invitation is outgoing because
                            // it was started on another tab, this tab must also recognize the
                            // completion of the invitation and move to the Connected state
                            if (state() == cNotified || state() == cConnecting && !isIncoming()) {
                                setResource(ucwa.get(rInvitation.link('messaging').href));
                                observeMessagingState();
                                state(Internal.Modality.State.Connected, event.reason);
                            }
                        }).catch(function (error) {
                            state(Internal.Modality.State.Disconnected, error);
                        });
                    }
                    //#region init
                    /**
                     * The order of events fired by this method doesn't matter
                     * because it's invoked by the constructor and the state of
                     * the object can be observed only after its constructor succeeds.
                     */
                    function init() {
                        if (isMessagingActive()) {
                            // TODO: restore the messaging history (as of Mar 2014, UCWA doesn't support this)
                            state(Internal.Modality.State.Connected);
                            setResource(ucwa.get(getConversationResource().link('messaging').href));
                            observeMessagingState();
                        }
                        else if (rInvitation) {
                            processInvitation();
                        }
                        else if (isIncomingMeetingRequest()) {
                            // state must be the same in P2P and meeting invitations
                            // to enable writing the same UI code for the two cases;
                            // this also enables .accept and .reject commands
                            state(Internal.Modality.State.Notified);
                        }
                        else {
                            state(Internal.Modality.State.Created);
                        }
                        ucwa.event(onServerEvent);
                        // The reason it's invoked unconditionally here, without waiting
                        // for any action from the caller, is that Dispatcher::wait returns
                        // a task that is resolved asynchronously. When accepting an invitation,
                        // two events arrive:
                        //
                        //  - messagingInvitation completed
                        //  - message completed (the 1-st message)
                        //
                        // If the handler of "messagingInvitation completed" start waiting for
                        // "message completed" events, it will skip the 1-st message, because the
                        // handler is invoked asynchronously and at the time it's invoked,
                        // the "message completed" event is already in past.
                        //
                        // A solution would be to resolve the task synchronously, but that would
                        // break the compatibility with Promises/A+ spec.
                        receiveIncomingMessages();
                        state.changed(function (newState, reason, oldState) {
                            debug.log('ChatService::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                    }
                    //#endregion
                    init();
                    return self;
                }
                Internal.ChatService = ChatService;
                //#endregion ChatService
                //#region PresenceSubscriptionManager (internal)
                /**
                 * Creates, updates and deletes contact presence subscriptions.
                 *
                 * It's mainly responsible for merging several subscriptions into one
                 * which is supposed to reduce the pressure on the server.
                 *
                 * This is the outline of relationships between all involved resources:
                 *
                 *      /presenceSubscriptions
                 *          /presenceSubscription[i]
                 *              /addToPresenceSubscription
                 *              /memberships
                 *                  /presenceSubscriptionMembership[i]
                 *                      /presenceSubscription (link to parent)
                 *                      /contact
                 *      /subscribedContacts (a read-only view)
                 *          /contact[i]
                 *
                 * @method {PresenceSubscription} subscribe(uri)
                 *
                 *      Creates a presence subscription for the given SIP URI.
                 *      The subscription manager may either create a standalone
                 *      subscription or merge it with others to reduce pressure
                 *      on the server.
                 *
                 *          var sub = psm.subscribe("sip:user123@contoso.com");
                 *          setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
                 *
                 *      This method may be invoked multiple times on the same SIP URI:
                 *      the subscriptions manager will handle this correctly.
                 *
                 */
                function PresenceSubscriptionManager(ucwa, maxBatchSize, duration) {
                    var subs = {}, refs = {}, dfds = {}; // all indexed by uri
                    // one presence subscription cannot contain more than 75 URIs
                    var subscribe = batched(function (uris) {
                        var psub = PresenceSubscription(ucwa, uris, duration);
                        psub.size.when(0, function () {
                            foreach(uris, remove);
                        });
                        return psub;
                    }, maxBatchSize || 75);
                    function unsubscribe(uri) {
                        refs[uri]--;
                        if (refs[uri] == 0) {
                            if (subs[uri]) {
                                subs[uri].remove(uri);
                            }
                            else {
                                dfds[uri].cancel();
                                remove(uri);
                            }
                        }
                    }
                    function remove(uri) {
                        delete dfds[uri];
                        delete refs[uri];
                        delete subs[uri];
                    }
                    return {
                        subscribe: function (uri) {
                            var isDisposed = false;
                            if (dfds[uri]) {
                                refs[uri]++;
                            }
                            else if (subs[uri]) {
                                refs[uri]++;
                                subs[uri].add(uri);
                            }
                            else {
                                refs[uri] = 1;
                                dfds[uri] = subscribe(uri, 0).then(function (sub) {
                                    subs[uri] = sub;
                                    dfds[uri] = null;
                                });
                            }
                            return {
                                dispose: function () {
                                    if (!isDisposed) {
                                        isDisposed = true;
                                        unsubscribe(uri);
                                    }
                                }
                            };
                        }
                    };
                }
                Internal.PresenceSubscriptionManager = PresenceSubscriptionManager;
                //#endregion
                //#region PresenceSubscription (internal)
                /**
                 * Creates and keeps a presence subscription to one or multiple SIP URIs.
                 *
                 * @param {String[]} uris
                 *
                 * @method remove(uri)
                 *
                 *      UCWA offers API to add one or multiple SIP URIs to an existing presence
                 *      subscription, but doesn't offer an efficient way to remove a SIP URI.
                 *      Thus this implementation doesn't offer a way to unsubscribe from a SIP URI
                 *      without deleting the entire presence subscription. The remove method
                 *      doesn't unsubscribe the given URI. Instead, it decrements an internal
                 *      counter and when it reaches zero, it deletes the entire presence
                 *      subscription.
                 *
                 * @property {Number} size
                 *
                 *      The number of SIP URIs in this subscription.
                 *
                 */
                function PresenceSubscription(ucwa, uris, duration) {
                    var rSubscription, rep, dfd, active = {}, size = Property();
                    size(uris.length);
                    foreach(uris, function (uri) {
                        active[uri] = true;
                    });
                    // we found that values higher than 11 minutes get rejected by the server
                    duration = duration || 11;
                    dfd = Task.wait(null, 'sync').then(function () {
                        // in the anonymous mode rel=presenceSubscriptions does not exist
                        return ucwa.send('POST', { rel: 'presenceSubscriptions' }, {
                            data: {
                                duration: duration,
                                uris: uris
                            }
                        });
                    }).then(function (r) {
                        rSubscription = r;
                        // this logic should handle a more aggressive approach to extending existing
                        // presence subscription and should make it less likely that an 'updated'
                        // event will appear for this subscription
                        rep = repeat(function () {
                            return sleep((duration - 1) * 60).then(extendDuration);
                        });
                        // UCWA sends an empty "updated" event to warn that the subscription is about to expire
                        rSubscription.dirty.when(true, extendDuration);
                        // if UCWA deletes the subscription, the client should stop trying to extend it
                        rSubscription.deleted(function () {
                            stop();
                            size(0);
                            active = {};
                        });
                    }).finally(function () {
                        dfd = null;
                    });
                    function extendDuration() {
                        return ucwa.send('POST', rSubscription.href, {
                            query: { duration: duration }
                        });
                    }
                    function stop() {
                        if (rep) {
                            rep.cancel();
                            rep = null;
                        }
                    }
                    function add(uri) {
                        if (active[uri]) {
                        }
                        else {
                            active[uri] = true;
                            size(size() + 1);
                        }
                    }
                    function remove(uri) {
                        if (active[uri]) {
                            active[uri] = false;
                            size(size() - 1);
                            if (size() == 0) {
                                if (rSubscription) {
                                    stop();
                                    ucwa.send('DELETE', rSubscription.href);
                                }
                                else if (dfd) {
                                    dfd.cancel();
                                }
                            }
                        }
                    }
                    return {
                        add: add,
                        remove: remove,
                        size: size.asReadOnly()
                    };
                }
                Internal.PresenceSubscription = PresenceSubscription;
                //#endregion
                //#region Person
                /**
                 * A read-only representation of a Person in a contact list or in a search query.
                 *
                 * A Person model is created on top of a "contact" resource from UCWA.
                 * When created, it does not send any HTTP requests to get additional
                 * information about the Person, but waits for the view layer
                 * (or whoever created the Person model) to subscribe to one of the
                 * Person model properties. For example, when the caller starts
                 * listening to Person name changes
                 *
                 *      person1.displayName.changed(function (name) {
                 *          console.log("the contact's name is " + name);
                 *      });
                 *
                 * the Person model checks whether the property is already
                 * available and if so, the Person model does not fetches it
                 * again from the server, If the property value is not available,
                 * the Person model sends all HTTP server requests necessary to obtain
                 * that value. For example for the
                 * code snippet above where someone subscribes to the "displayName" property,
                 * the Person model sends up to one HTTP request to load the resource:
                 *
                 *      GET /contacts/126173
                 *
                 * For more complicated properties, like "status", it may be necessary
                 * to send extra HTTP requests to create a presence subscription. So when
                 * someone starts listening to the "status" property
                 *
                 *      sub = person1.status.subscribe();
                 *      person1.status.changed(onPresenceChanged);
                 *      function onPresenceChanged(presence) {
                 *          console.log("the contact is " + presence.availability);
                 *      }
                 *
                 * the Person model sends a POST request to create a presence subscription
                 * (in addition to all requests that are necessary to get the URL to which
                 * that POST request can be sent):
                 *
                 *      POST /contacts/126173/presencesubscriptions
                 *
                 *      {"Uris":["sip:johndoe@contoso.com"], "Duration":"11"}
                 *
                 * But after the view stops listening to the property
                 *
                 *      sub.dispose();
                 *
                 * the Person model sends a DELETE request to remove the presence subscription:
                 *
                 *      DELETE /contacts/126173/presencesubscriptions/2877816481
                 *
                 * This is why a well written web app should unsubscribe from Person models
                 * after it does not need them. The Person model cannot do this itself, because
                 * in JavaScript there is no concept of "finalizers" or "destructors" and so
                 * the Person model cannot know when it's no longer needed.
                 *
                 * @param {UCWA} ucwa
                 * @param {String|Property<String>} href - The href of a rel=contact resource.
                 * @param {PresenceSubscriptionManager} [psm]
                 *
                 * @property {String} id - a unique id of this person - either a Skype id or a Lync SIP URI.
                 * @property {String} displayName - Display name.
                 * @property {String} firstName - First name of person.
                 * @property {String} lastName - Last name of person.
                 * @property {String} title - Person title.
                 * @property {String} workPhone - Work phone number (as tel uri).
                 * @property {String} office
                 * @property {String} department
                 * @property {String} company
                 * @property {String} sourceNetwork - Can be "SameEnterprise" or "Federated".
                 * @property {String} type - Person type (i.e. "User").
                 * @property {String} avatarUrl - Person avatar URL.
                 * @property {String} status - Person availability.
                 * @property {String} activity - Extracted from the `activity` property.
                 * @property {String} endpointType - The device type on which the contact has been the most active.
                 * @property {Date} lastSeenAt
                 * @property {String} relationship - Privacy relationship (e.g. "Colleagues").
                 * @property {Location} location - Person location.
                 *
                 *      var location = person.location(); // read the location
                 *      person.location.subscribe(); // subscribe to location changes
                 *      person.location.changed(function (location) {
                 *          console.log("new location is " + location);
                 *      });
                 *
                 * @property {Note} note - Person note.
                 *
                 *      The note is not a property, but an object containing the following sub-properties:
                 *
                 *          type: type of note. Valid values are: 'Personal' or 'OutOfOffice'.
                 *          text: the actual note text.
                 *
                 *      Since note is not a property itself, it can not be subscribed to; but its sub-properties can be subscribed to:
                 *
                 *      var note = person.note; // get the note object
                 *      note.text.subscribe(); // subscribe to changes of note.text
                 *      note.text.changed(function (t) {
                 *          console.log("new note is " + t);
                 *      });
                 *
                 * @property {Capabilities} capabilities - Communication capabilities of this person.
                 *
                 *      Like note, the capabilities is not a property, but an object containing
                 *      the following sub-properties (all of which contain boolean flags indicating
                 *      whether the person is capable of communicating using certain modalities):
                 *          chat: whether the person is capable of chat.
                 *          audio: whether the person is capable of audio.
                 *          video: whether the person is capable of video.
                 *          screenSharing: whether the person is capable of screen sharing.
                 *          dataCollaboration: whether the person is capable of data collaboration.
                 *
                 *      var modalities = person.capabilities;
                 *      if (!modalities.audio())
                 *          console.log("audio not supported");
                 *
                 *      Since capabilities is not a property itself, it can not be subscribed to; but its sub-properties can be subscribed to:
                 *
                 *      var modalities = person.capabilities; // get the capabilities object
                 *      modalities.audio.subscribe(); // subscribe to changes of capabilities.audio
                 *      modalities.audio.changed(function (f) {
                 *          console.log("audio modality is " + f ? 'supported' : 'not supported');
                 *      });
                 *
                 * @collection {Phone} phoneNumbers - All phone numbers.
                 *
                 *      Each element of this collection is a Phone object with three properties:
                 *
                 *          type: the type of this phone (valid values are: 'home', 'work', 'cell', 'other')
                 *          telUri: the tel uri of this phone
                 *          displayString: the display string of this phone
                 *
                 * @collection {Email} emails - all email addresses.
                 *
                 *      Each element of this collection is an Email object with two properties:
                 *
                 *          type: the type of this email address (valid values are: 'Personal', 'Work', 'Other')
                 *          emailAddress: the email address as a string
                 *
                 * @method {Subscription} subscribe - Subscribe to all properties that have been observed.
                 *
                 *      This method should be invoked if the user needs to have the up to date
                 *      values of all the properties that have registered an observer.
                 *
                 *          person1.id.changed(fn1);
                 *          person1.status.changed(fn2);
                 *          person1.location.changed(fn3);
                 *          var sub = person1.subscribe();
                 *
                 */
                function Person(spec) {
                    var href = spec.href, ucwa = spec.ucwa, psm = spec.psm || PresenceSubscriptionManager(ucwa), dfdGet, dfdGetLink = {}, PropType = StringEnum('direct', 'linked', 'photo'), 
                    // presence subscription is needed when the Person wants to observe linked properties
                    // (status, activity, note, location, capabilities, relationship):
                    // - subscriptionRefCount tracks the number of observed linked properties and tells the
                    //   Person when to create or delete the subscription.
                    subscriptionRefCount = 0, subscription, properties = {}, 
                    // Property<Resource> which gets the possibly empty rel=contact on demand
                    prContact = (isString(href) ? ConstProperty(href) : href).map(ucwa.get), proto = Model(), self = inherit(proto);
                    spec = null; // no need to use `spec` beyond this point
                    initialize();
                    //#region methods
                    function getPropertyValue(name) {
                        var prop = properties[name];
                        return prContact.get().then(function (r) {
                            // the contact resource may contain an incomplete
                            // set of properties and links: UCWA reserves the right
                            // to return partial resources in certain cases (contact search)
                            var isValueAvailable = prop.type == PropType.direct ?
                                r.has(prop.internalName) :
                                r.hasLink(prop.internalName);
                            if (!isValueAvailable)
                                return fetchContactResource();
                        }).then(function () {
                            switch (prop.type) {
                                case PropType.linked:
                                    return fetchLinkedProperty(prop.link).then(function (result) {
                                        updatePropertyFromResource(prop, result);
                                    });
                                case PropType.photo:
                                    return getPhoto();
                            }
                        }).then(function () {
                            // at this moment the updated value
                            // is in the cache of the property
                            return prop.property();
                        });
                    }
                    /**
                     * Defines a property of this Person.
                     *
                     * @param {string} name - public property name
                     * @param {object} def - an object with the following properties:
                     *
                     *      internalName - a name of this property in the UCWA contact resource.
                     *      type         - property type (can be direct, linked or photo).
                     *      field        - the sub-property of the internal UCWA contact resource.
                     *      element      - the element name in the internal UCWA contact resource
                     *                     if the resource is an array.
                     *      isCollection - whether this property is a Collection or not.
                     *      transform    - a function used to transform the UCWA resource value
                     *                     into a form specifically needed by the property.
                     *
                     * @remark:
                     *
                     *  Fills out the internal properties of a Person model with the UCWA resources' definitions.
                     *
                     *  A value of the direct property can be found in the UCWA contact resource;
                     *  a linked property is accessible only via a link in the UCWA contact resource;
                     *  photo is also a linked property, but we make it a separate type because it
                     *  is retrieved from the server not like other linked properties.
                     *
                     *  Each property also has a "link" field; for linked properties it is the property
                     *  link in the UCWA contact resource; it is null for properties whose values are
                     *  immediately available in the contact resource.
                     *
                     * @returns {Property|Collection}
                     *
                     */
                    function defineProperty(name, def) {
                        assert(isNotEmptyString(name));
                        assert(!def || PropType[def.type]);
                        var property = (def && def.isCollection ? Collection : Property)({
                            get: function () {
                                return getPropertyValue(name);
                            },
                            subscribed: function () {
                                // fetch some properties from the server only when some other object is binding
                                // to those properties for the first time
                                onPropertySubscribed(properties[name]);
                            },
                            unsubscribed: function () {
                                onPropertyUnsubscribed(properties[name]);
                            }
                        });
                        properties[name] = {
                            internalName: def && def.internal || name,
                            type: def && def.type || PropType.direct,
                            field: def && def.field,
                            element: def && def.element,
                            observed: false,
                            dirty: false,
                            link: null,
                            transform: def && def.transform,
                            property: property
                        };
                        return properties[name].property.asReadOnly();
                    }
                    /**
                     * Initializes this Person from the contact resource
                     */
                    function initialize() {
                        // define properties
                        self.id = defineProperty('id', { internal: 'uri', type: PropType.direct });
                        self.sourceNetwork = defineProperty('sourceNetwork');
                        self.company = defineProperty('company');
                        self.department = defineProperty('department');
                        self.office = defineProperty('office');
                        self.title = defineProperty('title');
                        self.emails = defineProperty('emails', {
                            internal: 'emailAddresses',
                            type: PropType.direct,
                            isCollection: true,
                            transform: function (arr) {
                                return map(arr || [], function (email) {
                                    return Model({
                                        type: ConstProperty(null),
                                        emailAddress: ConstProperty(email)
                                    });
                                });
                            }
                        });
                        self.phoneNumbers = defineProperty('phoneNumbers', {
                            // phoneNumbers is an aggregate of 4 UCWA direct resources
                            internal: ['workPhoneNumber', 'homePhoneNumber', 'mobilePhoneNumber', 'otherPhoneNumber'],
                            type: PropType.direct,
                            isCollection: true,
                            transform: function (phones) {
                                // keys are UCWA resource names, values are jCafe phone types
                                var phoneTypes = {
                                    workPhoneNumber: 'Work',
                                    homePhoneNumber: 'Home',
                                    mobilePhoneNumber: 'Mobile',
                                    otherPhoneNumber: 'Other'
                                };
                                /* phones is an array of objects:
                                 * [ {'workPhoneNumber':'xxx-xxx-xxxx'},
                                 *   {'homePhoneNumber':'xxx-xxx-xxxx'},
                                 *   {'mobilePhoneNumber':'xxx-xxx-xxxx'},
                                 *   {'otherPhoneNumber':'xxx-xxx-xxxx'} ]
                                 */
                                return map(filter(phones || [], function (phone) {
                                    var type = null, value = null, k = keys(phone);
                                    if (k.length == 1) {
                                        if (k[0] in phoneTypes) {
                                            type = phoneTypes[k[0]];
                                            value = phone[k[0]];
                                        }
                                    }
                                    return type && value;
                                }), function (phone) {
                                    var k = keys(phone)[0];
                                    return Model({
                                        type: ConstProperty(phoneTypes[k]),
                                        telUri: ConstProperty(phone[k]),
                                        displayString: ConstProperty(null)
                                    });
                                });
                            }
                        });
                        self.workPhone = defineProperty('workPhone', { internal: 'workPhoneNumber', type: PropType.direct });
                        self.homePhone = defineProperty('homePhone', { internal: 'homePhoneNumber', type: PropType.direct });
                        self.mobilePhone = defineProperty('mobilePhone', { internal: 'mobilePhoneNumber', type: PropType.direct });
                        self.otherPhone = defineProperty('otherPhone', { internal: 'otherPhoneNumber', type: PropType.direct });
                        self.type = defineProperty('type');
                        self.displayName = defineProperty('displayName', { internal: 'name', type: PropType.direct });
                        self.avatarUrl = defineProperty('avatarUrl', { internal: 'contactPhoto', type: PropType.photo });
                        self.status = defineProperty('status', { internal: 'contactPresence', type: PropType.linked, field: 'availability' });
                        self.endpointType = defineProperty('endpointType', { internal: 'contactPresence', type: PropType.linked, field: 'deviceType', transform: Person.fixDeviceType });
                        self.lastSeenAt = defineProperty('lastSeenAt', { internal: 'contactPresence', type: PropType.linked, field: 'lastActive', transform: timeStampToDate });
                        self.activity = defineProperty('activity', { internal: 'contactPresence', type: PropType.linked, field: 'activity' });
                        self.relationship = defineProperty('relationship', { internal: 'contactPrivacyRelationship', type: PropType.linked, field: 'relationshipLevel' });
                        self.location = defineProperty('location', { internal: 'contactLocation', type: PropType.linked, field: 'location', transform: disableHtmlInText });
                        // the location property contains a few sub-properties
                        // they are not defined by UCWA but needed in jCafe
                        extend(self.location, {
                            type: ConstProperty(null),
                            street: ConstProperty(null),
                            city: ConstProperty(null),
                            state: ConstProperty(null),
                            country: ConstProperty(null),
                            postalCode: ConstProperty(null)
                        });
                        // the Person#note object contains 2 sub-properties
                        // These properties need to be managed under the properties array
                        // to facilitate property subscription/unsubscription, and they
                        // should NOT be be added as direct properties of the Person model.
                        self.note = Model({
                            type: defineProperty('note.type', { internal: 'contactNote', type: PropType.linked, field: 'type' }),
                            text: defineProperty('note.text', { internal: 'contactNote', type: PropType.linked, field: 'message', transform: disableHtmlInText })
                        });
                        // the Person.capabilities object contains 5 sub-properties
                        // These properties need to be managed under the properties array
                        // to facilitate property subscription/unsubscription, and they
                        // should NOT be be added as direct properties of the Person model.
                        self.capabilities = Model({
                            chat: defineProperty('capabilities.chat', {
                                internal: 'contactSupportedModalities',
                                type: PropType.linked,
                                field: 'modalities',
                                element: 'Messaging'
                            }),
                            audio: defineProperty('capabilities.audio', {
                                internal: 'contactSupportedModalities',
                                type: PropType.linked,
                                field: 'modalities',
                                element: 'Audio'
                            }),
                            video: defineProperty('capabilities.video', {
                                internal: 'contactSupportedModalities',
                                type: PropType.linked,
                                field: 'modalities',
                                element: 'Video'
                            }),
                            screenSharing: defineProperty('capabilities.screenSharing', {
                                internal: 'contactSupportedModalities',
                                type: PropType.linked,
                                field: 'modalities',
                                element: 'ApplicationSharing'
                            }),
                            dataCollaboration: defineProperty('capabilities.dataCollaboration', {
                                internal: 'contactSupportedModalities',
                                type: PropType.linked,
                                field: 'modalities',
                                element: 'DataCollaboration'
                            })
                        });
                        // TODO: the setter of this property should move the contact to the Blocked group
                        self.isBlocked = ConstProperty(false, ENotSupported());
                        // once the rel=contact resource becomes available...
                        prContact.changed(function fn(r) {
                            if (r) {
                                prContact.changed.off(fn);
                                // sHref will be a hidden symbol for Contact objects
                                setHiddenProperty(proto, Internal.sHref, r.href);
                                // listen to contact resource update events;
                                // this will also populate direct properties if we have a non-empty
                                // contact resource in the repository
                                r.updated(function () {
                                    foreach(properties, function (p) {
                                        var v;
                                        if (p.type == PropType.direct) {
                                            if (isArray(p.internalName)) {
                                                v = map(filter(p.internalName, function (iName) {
                                                    return r.properties[iName];
                                                }), function (iName) {
                                                    var obj = {};
                                                    obj[iName] = r.properties[iName];
                                                    return obj;
                                                });
                                            }
                                            else {
                                                v = r.properties[p.internalName];
                                            }
                                            p.property(p.transform ? p.transform(v) : v);
                                        }
                                        else
                                            p.link = r.relatedHref(p.internalName);
                                    });
                                });
                            }
                        });
                        ucwa.event(onSubscriptionEvent);
                        // some linked properties may be available in the resource cache
                        updateLinkedPropsOrGetMissingProperties();
                        // the photo URL may be already available in the resource cache
                        getPhoto();
                    }
                    /**
                     * An internal event handler invoked only when some other object
                     * is binding to a Person property for the first time.
                     */
                    function onPropertySubscribed(p) {
                        p.observed = true;
                        switch (p.type) {
                            case PropType.direct:
                                prContact.get().then(function (r) {
                                    if (!r.has(p.internalName))
                                        fetchContactResource();
                                });
                                break;
                            case PropType.linked:
                                // the link href of the property isn't needed: the subscription
                                // and the consequent updates can be handled without this link
                                createSubscription(p);
                                break;
                            case PropType.photo:
                                // as of Oct 2014 UCWA doesn't have an API to create a subscription
                                // to a contact's photo; if later it gets one, this is the right place
                                // to invoke it; for now creating a subscription to a contact's photo
                                // is no different from fetching it once
                                p.property.get();
                                break;
                        }
                    }
                    function onPropertyUnsubscribed(p) {
                        p.observed = false;
                        if (p.type == PropType.linked)
                            deleteSubscription();
                    }
                    /**
                     * Fetches the rel=contact resource once.
                     * Subsequent calls to this function return
                     * an already resolved promise.
                     */
                    function fetchContactResource() {
                        if (!dfdGet) {
                            dfdGet = prContact.get().then(function (r) {
                                return ucwa.send('GET', r.href);
                            });
                            // if the server returned the rel=contact resource,
                            // don't fetch it again as it's unlikely it will change;
                            // but if the server failed to return the resource,
                            // allow further attempts to fetch it again
                            dfdGet.then(null, function () {
                                dfdGet = null;
                            });
                        }
                        return dfdGet;
                    }
                    /**
                     * Sends only one GET to a linked resource even if invoked multiple times.
                     */
                    function fetchLinkedProperty(link) {
                        // TODO: This is a pretty common pattern which is known as debouncing.
                        if (!dfdGetLink[link]) {
                            dfdGetLink[link] = ucwa.send('GET', link).finally(function () {
                                dfdGetLink[link] = null;
                            });
                        }
                        return dfdGetLink[link];
                    }
                    /**
                     * Fetches Person photo from the server
                     */
                    function getPhoto() {
                        if (properties.avatarUrl.link) {
                            return Person.getPhotoUrl({
                                ucwa: ucwa,
                                path: properties.avatarUrl.link
                            }).then(function (url) {
                                properties.avatarUrl.property(url);
                            });
                        }
                    }
                    function createSubscription(prop) {
                        subscriptionRefCount++;
                        if (subscriptionRefCount == 1) {
                            // fetch the SIP URI if it's not available
                            properties.id.property.get().then(function (uri) {
                                subscription = psm.subscribe(uri);
                            });
                        }
                        else if (prop.dirty) {
                            // subscription already exists but we ignored this property updates so far because
                            // there were no observers of this particular property - so we may not see another
                            // property update event and we need to fetch the property value explicitly.
                            //
                            // the check for subscription is needed to prevent GETs for props subscribed
                            // immediately after the first subscription in the same event cycle:
                            //
                            //    contact.status.changed(...) -> POST subscription
                            //    contact.note.text.changed(...) -> no GET here - we'll get the value from the 'note updated' event.
                            prop.property.get();
                        }
                    }
                    function deleteSubscription() {
                        subscriptionRefCount--;
                        if (subscriptionRefCount == 0 && subscription) {
                            subscription.dispose();
                            subscription = null;
                        }
                    }
                    /**
                     * presence subscription event handler
                     */
                    function onSubscriptionEvent(event) {
                        // prContact can be empty if this rel=contact is supposed to be inside a rel=participant
                        // which doesn't have the /contact link at the moment. However it wouldn't be correct to
                        // require the /contact link here as this event cannot be related to this contact. This
                        // follows from a simple observation: an event like "presence updated in contact" can arrive
                        // only if the model has created a presence subscription and the model creates a presence
                        // subscription only after it gets the /contact.uri value. You might have noticed that the ctor
                        // of the person model can theoretically take the .uri value from the parent rel=participant
                        // resource and create a presence subscription without fetching the rel=contact resource,
                        // but then prContact won't be empty. This event can be relevant while prContact is empty only
                        // if the following conditions are met:
                        //
                        //  1. This rel=contact is supposed to be a link in a rel=participant.
                        //  2. The rel=participant doesn't have the /contact link.
                        //  3. The rel=participant has the .uri value.
                        //  4. The implementation of the person model can take the .uri from the parent participant model.
                        //  5. The implementation of the person model can create a presence subscription without fetching rel=contact.
                        //
                        // This is theoretically possible and might be a good optimization in the future.
                        var r = prContact();
                        var target = event.target;
                        var scope = event['in'];
                        if (target && event.type == 'updated' && scope && r && scope.href == r.href) {
                            // status, activity, note, location, capabilities, relationship changes
                            foreach(properties, function (p) {
                                if (p.type == PropType.linked && target.rel == p.internalName) {
                                    if (p.observed) {
                                        p.property.get();
                                        p.dirty = false;
                                    }
                                    else {
                                        p.dirty = true;
                                    }
                                }
                            });
                        }
                    }
                    /**
                     * Sets linked properties with the values found in the repository.
                     * Those that lack data in the repository are returned by this function as an array.
                     *
                     * @returns An array of linked properties that need to be fetched from the server.
                     */
                    function updateLinkedPropsOrGetMissingProperties() {
                        var missing = [];
                        // check repository first, we may already have linked resources
                        foreach(properties, function (p) {
                            var r;
                            // when joining an online meeting anonymously, UCWA gives a limited
                            // subset of links that are given in the normal mode; e.g. rel=contactPresence
                            // is not available in the anonymous mode
                            if (p.type == PropType.linked && p.link) {
                                r = ucwa.get(p.link);
                                if (!isEmptyObject(r.properties))
                                    updatePropertyFromResource(p, r);
                                else
                                    missing.push(p);
                            }
                        });
                        return missing;
                    }
                    /**
                     * Sets the property with the value from a resource property
                     *
                     * @param {object} p - element of the internal properties collection
                     * @param {Resource} r - resource containing that property data
                     */
                    function updatePropertyFromResource(p, r) {
                        // the following logic specially handles the internal
                        // properties of Person.capabilities
                        var value = !p.field ? r.get() :
                            p.element ? indexOf(r.get(p.field), p.element) >= 0 :
                                r.properties[p.field];
                        p.property(p.transform ? p.transform(value) : value);
                    }
                    //#endregion
                    // return the read-only copy of Person properties
                    return extend(self, Person.prototype, {
                        // properties not defined by UCWA yet
                        firstName: ConstProperty(null),
                        lastName: ConstProperty(null)
                    });
                }
                Internal.Person = Person;
                extend(Person.prototype, {
                    /**
                     * Subscribes to every observed property and collection.
                     * This method is common for MePerson and Person and is
                     * used only by LWX and SWX. It's not meant to be used by
                     * other apps.
                     */
                    subscribe: function () {
                        var subs = [], self = this;
                        foreach(self, function visit(member) {
                            if (isProperty(member) || isCollection(member)) {
                                if (member.observed())
                                    subs.push(member.subscribe());
                            }
                            if (isModel(member))
                                foreach(member, visit);
                        });
                        return {
                            dispose: function () {
                                for (var i = 0; i < subs.length; i++)
                                    subs[i].dispose();
                                subs = [];
                            }
                        };
                    }
                });
                var Person;
                (function (Person) {
                    function fixDeviceType(t) {
                        return { PC: 'Desktop', Mobile: 'Mobile', Web: 'Web' }[t] || 'Unknown';
                    }
                    Person.fixDeviceType = fixDeviceType;
                    ;
                    /**
                     * Takes a path to a Person's photo and returns the photo's URL
                     * that can be used by the <img> element.
                     *
                     * This function completes or fails synchronously in all production
                     * topologies.
                     *
                     * @param {UCWA} ucwa
                     * @param {String} path - href of the "contactPhoto" resource
                     *
                     * @returns {Promise<String>} URL usable by <img> elements.
                     */
                    Person.getPhotoUrl = async(function (options) {
                        var ucwa = options.ucwa;
                        var path = options.path;
                        // Use the URI class to extract the domain name from
                        // the rel=applications href and combine it with the photo's path.
                        // After auto-discovery and authentication steps are passed, SkypeWeb
                        // sends a POST to rel=applications to create a rel=application
                        // resource; in a reply to that POST the server sends a cookie
                        // called cwt_ucwa which is associated with the .../photos path and
                        // thus is used by the browser to download contact photos.
                        // It's important to keep in mind that rel=applications and rel=user
                        // may belong to different pools and a web ticket issued by one pool
                        // may not work in another pool.
                        //
                        // TODO: Use URL or rel=xframe. Both rel=applications and rel=xframe
                        // contain the valid host name in their URLs, so no need to demand
                        // that a web app store rel=applications in a snapshot. Note, that
                        // in some topologies the client is redirected between pools and xframes
                        // during auto discovery and sign in, so the repository may contain
                        // multiple rel=xframe resources.
                        var app = ucwa.get({ rel: 'applications' });
                        var url = URI(app.href).path(path).query('');
                        return url + '';
                    });
                })(Person = Internal.Person || (Internal.Person = {}));
                //#endregion Person
                //#region ConversationsManager
                /**
                 * Contains all current conversations of the signed-in user.
                 *
                 * @param {UCWA} ucwa
                 * @param {MePerson} me
                 * @param {ObservableResource} gcs - rel=communication
                 * @param {Property<String>} [guestName]
                 * @param [listNamesInTopic=false]
                 * @param {ContactManager} contactManager
                 * @param {MediaPlugin} [mediaPlugin]
                 * @param {Devices} [devices]
                 *
                 * @command {Conversation} createConversation - Creates a new multiparty conversation model.
                 *
                 *      The created conversation model represents a new multiparty conversation (meeting).
                 *      To start the conversation add participants (optionally) and start one of the conversation services. If
                 *      no participants are added, the model represents a meeting that is joined by the local participant only.
                 *      This method adds the created conversation to the conversations collection.
                 *
                 *          var conversation = app.conversationsManager.createConversation();
                 *          var remoteParty = conversation.createParticipant(remotePerson);
                 *          conversation.participants.add(remoteParty);
                 *          conversation.chatService.start().then(function () {
                 *              console.log("chat started");
                 *          });
                 *
                 * @command {Conversation} getConversation - Finds an existing 1:1 conversation model or creates a new one.
                 *
                 *      This method finds or creates a conversation with a given Person. Our API allows multiple 1:1 conversations with
                 *      the same person, so while looking for an existing conversation we simply pick the first one found among such
                 *      ongoing conversations. We ignore disconnected (ended) conversations that may still linger in the
                 *      conversations collection. This method adds the newly created conversation to the conversations collection.
                 *
                 * @command {Conversation} getConversationByUri - Finds an existing multiparty conversation model or creates a new one.
                 *
                 *      A conversation uri has a meaning only for a multiparty conversation - it is a meeting uri.
                 *      A conversation model with such a uri represents the client's view of this meeting. Note that
                 *      initially such a model is just an empty conversation model which has a non-null uri property;
                 *      the client joins the meeting only when one of the conversation services is started. This method
                 *      adds the newly created conversation to the conversations collection.
                 *
                 * @command {ConversationSearchQuery} createSearchQuery - Creates a query object for searching conversations.
                 *
                 * @collection {Conversation} conversations
                 * @property {Boolean} isHistoryEnabled
                 *
                 */
                function ConversationsManager(options) {
                    var ucwa = options.ucwa;
                    var me = options.me;
                    var gcs = options.gcs;
                    var contactManager = options.contactManager;
                    var mediaPlugin = options.mediaPlugin;
                    var devices = options.devices;
                    var sharedResources = options.sharedResources;
                    var guestName = options.guestName;
                    var listNamesInTopic = options.listNamesInTopic;
                    options = null;
                    // Conversations are indexed by threadId.
                    // It's debatable whether this collection
                    // should be emptied at sign out.
                    var conversations = Collection();
                    var isHistoryEnabled = (gcs ? gcs.conversationHistory : ConstProperty(null)).map(function (value) { return value == 'Enabled'; }, function (isEnabled) { return isEnabled ? 'Enabled' : 'Disabled'; }); // the unmapping function
                    //#region initialization
                    function init() {
                        ucwa.event(onConversationEvent);
                        ucwa.init().then(function () {
                            restoreConversations();
                        });
                    }
                    function createConversationModel(options) {
                        extend(options, {
                            ucwa: ucwa,
                            me: me,
                            guestName: guestName,
                            listNamesInTopic: listNamesInTopic,
                            sharedResources: sharedResources,
                            contactManager: contactManager,
                            mediaPlugin: mediaPlugin,
                            devices: devices
                        });
                        return Conversation(options);
                    }
                    function restoreConversations() {
                        var connected = ucwa.find({
                            rel: 'conversation'
                        }).filter(function (rConversation) {
                            return rConversation.get('state', '') in { Connected: 1, Conferenced: 1 };
                        });
                        foreach(connected, function (rConversation) {
                            var conversation = createConversationModel({
                                href: rConversation.href,
                                threadId: rConversation.get('threadId')
                            });
                            conversations.add(conversation, rConversation.get('threadId'));
                        });
                    }
                    //#endregion
                    //#region public methods
                    function createConversation(options) {
                        assert(isVoid(options) || isDictionary(options));
                        options = options || {};
                        var conversation = createConversationModel({
                            isConference: getOption(options, 'isConference', true),
                            threadId: options.threadId || guid(),
                            topic: options.topic,
                            priority: options.priority,
                            participants: options.participants // unit tests may give a collection mock
                        });
                        addConversation(conversation);
                        return conversation;
                    }
                    function getConversationByUri(uri) {
                        assert(isNotEmptyString(uri));
                        var conversation = find(conversations(), function (conv) {
                            return conv.uri() == uri;
                        });
                        if (!conversation) {
                            conversation = createConversationModel({
                                uri: uri
                            });
                            addConversation(conversation);
                        }
                        return conversation;
                    }
                    function getConversation(person, options) {
                        assert(isVoid(options) || isDictionary(options));
                        options = options || {};
                        var conversation, participant;
                        var convs = filter(conversations(), function (conv) {
                            // Disconnected conversations are excluded because they cannot be reused.
                            // Multiparty conversations with one remote participant are excluded per interface contract:
                            // this method is supposed to return a 1:1 conversation only (the single Skype conversation).
                            // Moreover, in a meeting a participant may have a person object without the contact href,
                            // or other unique properties so we would have to fetch the contact ref thus making this
                            // method async.
                            return conv.participants.size() == 1 && !conv.isGroupConversation() &&
                                conv.participants(0).person[Internal.sHref] == person[Internal.sHref] &&
                                conv.state() != 'Disconnected';
                        });
                        if (convs.length > 0) {
                            // There may be multiple ongoing conversations with the same participant,
                            // so we return the first one.
                            conversation = convs[0];
                        }
                        else {
                            conversation = createConversationModel({
                                isConference: false,
                                threadId: options.threadId || guid(),
                                topic: options.topic,
                                priority: options.priority
                            });
                            addConversation(conversation);
                            participant = conversation.createParticipant(person);
                            conversation.participants.add(participant);
                        }
                        return conversation;
                    }
                    //#endregion
                    //#region events
                    function onConversationEvent(event) {
                        var resource = event.resource || {};
                        // media API may not be supported by this build
                        if (resource.rel == 'audioVideoInvitation' && !Internal.AudioVideoInvitation ||
                            resource.rel == 'applicationSharingInvitation' && !Internal.AppSharingInvitation)
                            return;
                        // modality invitation event - create or update the conversation object
                        if (event.type == 'started' && /^(messaging|audioVideo|onlineMeeting|applicationSharing)Invitation$/.test(resource.rel))
                            createOrUpdateConversation(resource);
                    }
                    // TODO: the Update part of this function will go away once all modalities are converted to
                    // services; the method will become createIncomingConversation()
                    //
                    // Creates a conversation on the first incoming invitation. All subsequent invitiations for other
                    // modalities should be handled by the respective services. For example, this func creates a
                    // new conversation when an audio/video invitation is received. Later, when the remote party adds
                    // messaging the messagingInvitation is not handled here but is processed by the conversation's
                    // chat service.
                    //
                    // In the multitab scenario this method is used to react on an outgoing invitation sent by another
                    // tab: that tab starts a conversation, while other tabs receive the same sequence of events and
                    // create matching conversation objects.
                    function createOrUpdateConversation(invitation) {
                        var threadId = invitation.get('threadId');
                        var conversation = conversations(threadId);
                        if (!conversation) {
                            conversation = createConversationModel({
                                rInvitation: invitation,
                                threadId: threadId,
                                topic: disableHtmlInText(invitation.get('subject', '')),
                                priority: invitation.get('importance', 'Normal')
                            });
                            conversations.add(conversation, threadId);
                        }
                        // TODO: this is the update part that will go away once we have ScreenSharing service
                        if (invitation.rel == 'applicationSharingInvitation')
                            conversation.addModality(Conversation.ModalityType.AppSharing, { resource: invitation });
                    }
                    function addConversation(conversation) {
                        if (!conversations(conversation.id()))
                            conversations.add(conversation, conversation.id());
                    }
                    function removeConversation(conversation) {
                        return conversation.leave().then(function () {
                            conversations.remove(conversation.id());
                        });
                    }
                    //#endregion
                    init();
                    // All these commands are enabled only when signed in.
                    // Some commands can be theoretically enabled any time,
                    // but then they will need a more sophisticated implementation.
                    return Model({
                        conversations: conversations.asWritable({
                            add: EnabledCommand(addConversation),
                            remove: EnabledCommand(removeConversation)
                        }),
                        isHistoryEnabled: isHistoryEnabled,
                        createConversation: EnabledCommand(createConversation),
                        getConversation: EnabledCommand(getConversation),
                        getConversationByUri: EnabledCommand(getConversationByUri),
                        getMoreConversations: DisabledCommand(ENotSupported()),
                        createSearchQuery: EnabledCommand(bind(ConversationSearchQuery, conversations))
                    });
                }
                Internal.ConversationsManager = ConversationsManager;
                //#endregion ConversationsManager
                //#region ContactManager (internal class)
                /**
                 * Contains all contacts known to the client.
                 *
                 * @param {UCWA} ucwa
                 *
                 * @method {Person} get
                 */
                function ContactManager(ucwa, psm) {
                    var contacts = {}; // contacts[href] = Person(...)
                    /**
                     * Finds or creates a Person model by its rel=contact href.
                     *
                     * @param {String|Property<String>} href
                     */
                    function get(href) {
                        var createPerson = bind(Person, {
                            href: href,
                            ucwa: ucwa,
                            psm: psm
                        });
                        if (isString(href)) {
                            if (!contacts[href])
                                contacts[href] = createPerson();
                            return contacts[href];
                        }
                        else {
                            return createPerson();
                        }
                    }
                    return {
                        get: get
                    };
                }
                Internal.ContactManager = ContactManager;
                //#endregion ContactManager
                //#region PersonsAndGroupsManager
                /**
                 * It holds a root group, which contains the list of all clients and groups known to the client.
                 *
                 * @param {UCWA} ucwa
                 * @param {ContactManager} contactmgr
                 * @param {PresenceSubscriptionManager} psm
                 * @param {MePerson} me
                 *
                 * @member {MePerson} mePerson - Represents signed in user.
                 *
                 *      Here is a correct way to display the availability state of the user:
                 *
                 *          client.signInManager.state.when("SignedIn", function () {
                 *              var tag = $("<span>").appendTo($("body"));
                 *              client.personsAndGroupsManager.mePerson.availability.subscribe();
                 *              client.personsAndGroupsManager.mePerson.availability.changed(function (availability) {
                 *                  tag.text(availability);
                 *              });
                 *          });
                 *
                 * @member {Group} all - The root group contains a list of all contacts and groups.
                 *
                 *      This is the root group contains 'persons' as  a collection  of all contacts, and
                 *      'groups' as a collection of all groups (user-created groups, server created groups and
                 *      relationship groups).
                 *
                 * @command {PersonSearchQuery} createPersonSearchQuery
                 * @command {GroupSearchQuery} createGroupSearchQuery
                 * @command {Group} createGroup
                 *
                 */
                function PersonsAndGroupsManager(options) {
                    var ucwa = options.ucwa;
                    var psm = options.psm;
                    var cm = options.contactmgr;
                    var me = options.me;
                    var root = RootGroup({
                        ucwa: ucwa,
                        contactmgr: cm
                    });
                    return Model({
                        mePerson: me,
                        all: root,
                        // These two commands are enabled only when signed in.
                        // This simplifies implementation of the search query models.
                        createPersonSearchQuery: EnabledCommand(function () {
                            return PersonSearchQuery({
                                ucwa: ucwa,
                                psm: psm,
                                contactmgr: cm,
                                me: me
                            });
                        }),
                        createGroupSearchQuery: EnabledCommand(function () {
                            return GroupSearchQuery({
                                ucwa: ucwa,
                                psm: psm,
                                contactmgr: cm
                            });
                        }),
                        createGroup: root.createGroup
                    });
                }
                Internal.PersonsAndGroupsManager = PersonsAndGroupsManager;
                //#endregion
                //#region RootGroup
                /**
                 * The root group holds the list of all contacts and all groups known to the client.
                 * Those groups include the user-created,  server-created and relationship groups.
                 *
                 * @param {UCWA} ucwa
                 * @param {ContactManager} contactmgr
                 *
                 * @collection {Person} persons - Collection of all contacts in the contact list.
                 *
                 *      This collection is represented by a resource with rel "myContacts".
                 *      Here is a correct way to display names of all contacts in the contact list:
                 *          client.personsAndGroupsManager.all.persons.subscribe();
                 *          client.personsAndGroupsManager.all.persons.added(function (person) {
                 *              var tag = $("<p>").appendTo($("body"));
                 *              person.name.get().then(function (name) {
                 *                  tag.text(name);
                 *              });
                 *          });
                 *
                 *      If the contact list is not loaded and UI needs to display it,
                 *      it may request to load the contact list once, without creating
                 *      a subscription:
                 *
                 *          client.personsAndGroupsManager.all.persons.get().then(function (persons) {
                 *              // `persons` is an array, so we can use Array::forEach here
                 *              persons.forEach(function (person) {
                 *                  // the `name` may not be loaded at the moment
                 *                  person.name.get().then(function (name) {
                 *                      console.log(name);
                 *                  });
                 *              });
                 *          });
                 *
                 *      To inspect the list of contacts available in the local cache:
                 *
                 *          var persons = client.personsAndGroupsManager.all.persons();
                 *          // `persons` is an array, so we can use Array::forEach here
                 *          persons.forEach(function (person) {
                 *              // `name` may be undefined at the moment
                 *              var name = person.name();
                 *              console.log(name);
                 *          });
                 *
                 *      To remove a contact from the contact list use the async `remove` method:
                 *
                 *          client.personsAndGroupsManager.all.persons.remove(person1).then(null, function (err) {
                 *              console.log("The contact cannot be removed: " + err);
                 *          });
                 *
                 *      This sends a request to the server to remove the contact. It gets actually
                 *      removed from the collection after the server sends the corresponding event.
                 *      To handle this subscribe to the `removed` event of the collection.
                 *
                 * @collection {Group} groups
                 *
                 *      This is a collection of user-created, server-created, and relationship groups.
                 *      The user-created groups have user-defined names.
                 *      The server created groups are "Others" and "Favorites" and these groups exist always.
                 *      The relationship groups are a set of 5 server-defined groups. These groups do not have
                 *      the "name" attribute. Instead they have the "relationshipLevel" attribute which takes
                 *      one of the following values:
                 *
                 *         - Blocked
                 *         - Colleagues
                 *         - Workgroup
                 *         - External
                 *         - FriendsAndFamily
                 *
                 *      When implementing the UI to display the list of groups, take into account
                 *      the "added" event that the collection provides. When a handler is attached
                 *      to this event, it's invoked for each item in the collection that existed
                 *      before the handler was attached and for each item that is added after it was
                 *      attached, so the following code will display the list of groups no matter
                 *      when they were added to the collection - before this code was executed or after:
                 *
                 *          client.personsAndGroupsManager.all.groups.added(function (group) {
                 *              var span = $('<span>').appendTo($('body'));
                 *              group.name.changed(function (name) {
                 *                  span.text(name);
                 *              });
                 *          });
                 *
                 *      To get only privacy relationship groups, use Collection::filter which
                 *      constructs an observable collection with only relationship groups:
                 *
                 *          var prs = all.groups.filter(g => g.type() == "PrivacyRelationship");
                 *          prs.added((group, key) => ...);
                 *          prs.removed((group, key) => ...);
                 *
                 */
                function RootGroup(options) {
                    var ucwa = options.ucwa;
                    var contactmgr = options.contactmgr;
                    var groupRels = ['group', 'pinnedGroup', 'distributionGroup', 'defaultGroup'];
                    var persons = Collection({
                        get: loadContacts,
                        subscribed: function () {
                            subscribe();
                            // get the list of contacts from the server and do this only once
                            // when the view subscribes to the model
                            loadContacts();
                        },
                        unsubscribed: unsubscribe
                    });
                    var groups = Collection({
                        get: loadGroups,
                        subscribed: function () {
                            subscribe();
                            // get the list of groups from the server and do this only once
                            // when the view subscribes to the model
                            loadGroups();
                        },
                        unsubscribed: unsubscribe
                    });
                    var groupMgmtEnabled = BoolProperty(false); // enable/disable group management APIs
                    // these 2 arrays are used to manage delayed loading of locally
                    // created (pending) groups. A pending group is a Group object
                    // created by the 'PersonsAndGroupsManager.createGroup' method
                    // (which delegates to the 'createLocalGroup' method). A pending group
                    // is not assigned an href until the user requests to add it to ucwa
                    // successfully, and receives the 'group added' event from ucwa.
                    // See the 'createLocalGroup' method for detailed explanations.
                    var pendingHrefs = [];
                    var pendingGroups = [];
                    var rSubscriptions; // rel=myContactsAndGroupsSubscription
                    var rGroupMemberships; // rel=myGroupMemberships
                    var rContacts; // rel=myContacts
                    var rGroups; // rel=myGroups
                    var rPrivacyRelationships; // rel=myPrivacyRelationships
                    var hTimer; // renews subscription
                    var dtSubscription = 30; // minutes
                    var nSubscriptions = 0; // avoid duplicate (un)subscriptions
                    function createGroup(source) {
                        return Group({
                            source: source,
                            ucwa: ucwa,
                            contactmgr: contactmgr,
                            subscribe: subscribe,
                            unsubscribe: unsubscribe,
                            groupMemberships: rGroupMemberships
                        });
                    }
                    function loadContacts() {
                        return ucwa.init().then(function () {
                            return ucwa.send('GET', { rel: 'myContacts' }).then(importContacts);
                        });
                    }
                    function loadGroups() {
                        return ucwa.init().then(function () {
                            return Task.waitAll([
                                ucwa.send('GET', { rel: 'myGroups' }).then(importGroups),
                                ucwa.send('GET', { rel: 'myPrivacyRelationships' }).then(importRelationships)
                            ]).then(function () {
                                return;
                            });
                        });
                    }
                    function importContacts(r) {
                        foreach(r.related.contact || [], function (link) {
                            if (!persons(link.href))
                                persons.add(contactmgr.get(link.href), link.href);
                        });
                    }
                    function importGroups(r) {
                        foreach(groupRels, function (rel) {
                            foreach(r.links(rel), function (link) {
                                if (!groups(link.href))
                                    groups.add(createGroup(link.href), link.href);
                            });
                        });
                    }
                    function importRelationships(r) {
                        foreach(r.links('myPrivacyRelationship'), function (link) {
                            if (!groups(link.href))
                                groups.add(createGroup(link.href), link.href);
                        });
                    }
                    /*
                    * Add method is currently not supported for the contact list.
                    *
                    * This method is not supported because contact list is the sum of all
                    * other groups therefore adding a contact to it is ambiguous - it is
                    * not clear which group the contact should be added to.
                    */
                    function addContactToContactList() {
                        throw ENotSupported();
                    }
                    //#region removeContactFromAllGroups
                    /*
                     * Remove a contact from all groups.
                     *
                     * removeContactFromAllGroups is a POST request of the form:
                     * "POST /groupMemberships/removeContactFromAllGroups?contactUri=..."
                     * where the href is obtained via the 'removeContactFromAllGroups' link.
                     *
                     * Note: the contact may not have been deleted when this request returns.
                     * It is actually removed from the group after UCWA sends the "contact deleted"
                     * event.
                     *
                     * Note: UCWA allows contact to be removed from certain (but not all)
                     * groups. We will let UCWA respond to operations that are not allowed.
                     *
                     * @param {Contact} contact - a Person object
                     * @returns {Promise}
                     */
                    function removeContactFromAllGroups(contact) {
                        record('Contact_Remove');
                        if (!contact || !contact.id)
                            throw EInvalidArgument('contact', 'the given value is not a Person model');
                        return contact.id.get().then(function (uri) {
                            // always load myGroupMemberships to prevent out of sync with UCWA
                            // TODO: batch process multiple remove requests in sequence
                            return ucwa.send('GET', rGroupMemberships.href).then(function () {
                                return initGroupMgmtAPI();
                            }).then(function () {
                                return ucwa.send('POST', rGroupMemberships.link('removeContactFromAllGroups').href, {
                                    query: { contactUri: uri },
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemovePersonFromAllGroups */ }
                                });
                            });
                        });
                    }
                    //#endregion
                    function fetchLink(rel) {
                        return ucwa.exists({ rel: rel }) ?
                            Task.wait({ href: ucwa.get({ rel: rel }).href }) :
                            ucwa.send('GET', rSubscriptions.href).then(function (r) {
                                return r.link(rel);
                            });
                    }
                    function subscribe() {
                        nSubscriptions++;
                        if (nSubscriptions > 1)
                            return;
                        ucwa.init().then(function () {
                            fetchLink('startOrRefreshSubscriptionToContactsAndGroups').then(function (link) {
                                function renew() {
                                    return ucwa.send('POST', link.href, {
                                        query: { duration: dtSubscription }
                                    });
                                }
                                renew(); // subscribe once
                                hTimer = setInterval(function () {
                                    renew().then(null, unsubscribe); // and cancel subscription if something went wrong
                                }, dtSubscription * 60 * 1000);
                            });
                        });
                    }
                    function unsubscribe() {
                        nSubscriptions--;
                        if (nSubscriptions > 0)
                            return;
                        ucwa.init().then(function () {
                            clearInterval(hTimer);
                            fetchLink('stopSubscriptionToContactsAndGroups').then(function (link) {
                                return ucwa.send('POST', link.href);
                            });
                        });
                    }
                    /* A typical scenario to create a group and add it to the server
                     * consists of 4 steps: (pgm = client.personsAndGroupsManager)
                     *  1) Create a local group: g = pgm.createGroup()
                     *  2) Set the name of group: g.name("G1")
                     *  3) Request to add on server: pgm.all.groups.add(g)
                     *  4) Handling "group added" event: g is finally added
                     *
                     * These problems need to be solved to implement this scenario:
                     *  - both step 3 and step 4 are async
                     *  - the group is not added until after step 4
                     *  - the event in step 4 does not contain the group object in the
                     *    previous 3 steps
                     *  - the group object g is created in step 1 but loaded in step 4
                     *
                     * So the main issue is to correlate group g with the "group added"
                     * event, and load group resource when the right event is received.
                     *
                     * To solve the problem, we use a pattern used in the Conversation
                     * and Participant models (for adding a Participant object to the
                     * Conversation and load it later). The basic idea is as follows:
                     *
                     *  in step 1): create promise p to pass to Group constructor,
                     *      which will attach any resource-dependent operations with the
                     *      then clause of the promise. In addition, add p to an array
                     *      pendingHrefs and g to another array pendingGroups
                     *  in step 4): retrieve groupName from event; iterate pendingGroups
                     *      to locate g by name; add g to the groups collection; resolve
                     *      corresponding promise p in pendingHrefs (which will load the
                     *      group resource for g); deleting g from pendingGroups and p
                     *      from pendingHrefs
                     */
                    function createLocalGroup() {
                        record('Group_CreateLocal');
                        var dfd = Task(), group = createGroup(dfd.promise);
                        pendingHrefs.push(dfd);
                        pendingGroups.push(group);
                        return group;
                    }
                    /*
                     * Add a user defined group to the contact list.
                     *
                     * The group specified is either a locally created group object
                     * or a group object obtained from search. This operation is to
                     * request UCWA to add the group to the contact list.
                     *
                     * It is a POST request of the form:
                     * "POST /people/groups"
                     * where the body of the request shall contain an object:
                     * { 'displayName': 'group name' }.
                     *
                     * @param {Group} group - the Group object to be created on UCWA
                     * @returns {Promise}
                     */
                    function addNewGroup(group) {
                        var name = group.name();
                        assert.is(name, 'NotEmptyString');
                        return initGroupMgmtAPI().then(function () {
                            return ucwa.send('POST', { rel: 'myGroups' }, {
                                data: { displayName: name },
                                headers: { 'X-MS-RequiresMinResourceVersion': 2 /* AddGroup */ }
                            });
                        });
                    }
                    /*
                     * Add an existing distribution group to the contact list.
                     *
                     * add operation is a POST request of the form:
                     * "POST /people/groups/addToContactList?displayName=<dlname>&smtpAddress=<group@sample.com>"
                     * where the actual link used in this operation must exist on this group resource.
                     *
                     * @param {Group} group - the Group object to be added
                     * @returns {Promise}
                     */
                    function addDG(group) {
                        var link = ucwa.get(group[Internal.sHref]).link('addToContactList');
                        return ucwa.send('POST', link.href);
                    }
                    /*
                     * Depending on the argument specified, either create a new user defined
                     * group in the contact list, or add an existing distribution group to
                     * the contact list.
                     *
                     * @param {Group} group - the Group object to be added
                     * @returns {Promise}
                     */
                    function addGroup(group) {
                        record('Group_Add');
                        return group.type() == 'Distribution' ? addDG(group) : addNewGroup(group);
                    }
                    /*
                     * Delete a user defined group from the contact list.
                     *
                     * delete operation is a DELETE request of the form:
                     * "DELETE /people/groups/<groupId>"
                     * where the actual link used in this operation is the href of this group resource.
                     *
                     * @param {Group} group - the Group object to be deleted
                     * @returns {Promise}
                     */
                    function deleteGroup(group) {
                        return initGroupMgmtAPI().then(function () {
                            return ucwa.send('DELETE', group[Internal.sHref], {
                                headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemoveGroup */ }
                            });
                        });
                    }
                    /*
                     * Remove a distribution group from the contact list.
                     *
                     * add operation is a POST request of the form:
                     * "POST /people/groups/removeFromContactList?<groupId=mygid>"
                     * where the actual link used in this operation must exist on this group resource.
                     *
                     * @param {Group} group - the Group object to be added
                     * @returns {Promise}
                     */
                    function removeDG(group) {
                        var link = ucwa.get(group[Internal.sHref]).link('removeFromContactList');
                        return ucwa.send('POST', link.href);
                    }
                    /*
                     * Depending on the argument specified, either delete a user defined
                     * group from the contact list, or remove a distribution group from
                     * the contact list.
                     *
                     * @param {Group} group - a Group object to be removed
                     * @returns {Promise}
                     */
                    function removeGroup(group) {
                        record('Group_Remove');
                        var rel = ucwa.get(group[Internal.sHref]).rel;
                        if (rel == 'group')
                            return deleteGroup(group); // delete a user defined group
                        else if (rel == 'distributionGroup')
                            return removeDG(group); // remove a distribution group
                        else
                            throw ENotSupported({ groupType: rel });
                    }
                    /*
                     * Enable person and group management APIs if supported.
                     */
                    function initGroupMgmtAPI() {
                        return ucwa.getRevisionOf(rGroupMemberships).then(function () {
                            if (!groupMgmtEnabled())
                                throw ENotSupported();
                        });
                    }
                    ucwa.init().then(function () {
                        // all these resources are missing in the anonymous mode
                        rGroupMemberships = ucwa.get({ rel: 'myGroupMemberships' }, null);
                        rSubscriptions = ucwa.get({ rel: 'myContactsAndGroupsSubscription' }, null);
                        rContacts = ucwa.get({ rel: 'myContacts' }, null);
                        rGroups = ucwa.get({ rel: 'myGroups' }, null);
                        rPrivacyRelationships = ucwa.get({ rel: 'myPrivacyRelationships' }, null);
                        if (rContacts)
                            importContacts(rContacts);
                        if (rGroups)
                            importGroups(rGroups);
                        if (rPrivacyRelationships)
                            importRelationships(rPrivacyRelationships);
                        if (rGroupMemberships) {
                            rGroupMemberships.updated(function () {
                                // enable group management APIs properly if the resource
                                // revision is already loaded; otherwise enable the APIs
                                // so that they can be called, at which point the resource
                                // revision will be loaded and the APIs will be enabled
                                // or disabled properly
                                var rev = rGroupMemberships.link('self').revision;
                                groupMgmtEnabled(!(+rev || rGroupMemberships.dfdDebounced) || rev >= 2);
                            });
                        }
                    });
                    // the server tells over the event channel when a group gets added or removed;
                    // these events are not available for the relationship groups
                    ucwa.event(function (event) {
                        var scope = event['in'] || {}, link = event.target || {}, href = link.href;
                        // these events are not available for the relationship groups
                        if (indexOf(groupRels, link.rel) >= 0) {
                            if (scope.rel == 'myGroups') {
                                if (event.type == 'deleted') {
                                    // nothing will happen if the href is not in the collection
                                    groups.remove(href);
                                }
                                else if (event.type == 'added' && !groups(href)) {
                                    if (pendingGroups.length > 0) {
                                        Task.wait(null).then(function () {
                                            if (!ucwa.get(href).has('name'))
                                                return ucwa.send('GET', href);
                                        }).then(function () {
                                            var i = findIndex(pendingGroups, function (g) {
                                                return g.name() == ucwa.get(href).get('name');
                                            });
                                            if (i >= 0) {
                                                pendingHrefs[i].resolve(href);
                                                groups.add(pendingGroups[i], href);
                                                pendingGroups.splice(i, 1);
                                                pendingHrefs.splice(i, 1);
                                            }
                                            else {
                                                groups.add(createGroup(href), href);
                                            }
                                        });
                                    }
                                    else {
                                        groups.add(createGroup(href), href);
                                    }
                                }
                            }
                            else if (link.rel == 'group' && event.type == 'updated' && groups(href)) {
                                // group updated, get its latest values, the group model will
                                // be updated automatically once the resource arrives
                                ucwa.send('GET', href);
                            }
                        }
                        if (scope.rel == 'myContacts') {
                            if (event.type == 'added' && !persons(href)) {
                                persons.add(contactmgr.get(href), href);
                            }
                            else if (event.type == 'deleted') {
                                persons.remove(href);
                            }
                        }
                    });
                    return Model({
                        name: ConstProperty(null),
                        uri: ConstProperty(null),
                        avatarUrl: ConstProperty(null),
                        type: ConstProperty('Root'),
                        relationshipLevel: ConstProperty('None'),
                        createGroup: createLocalGroup,
                        // these commands are disabled when not signed in to
                        // simplify their implementation
                        persons: persons.asWritable({
                            // disable add method: currently not supported
                            add: DisabledCommand(addContactToContactList),
                            remove: Command(removeContactFromAllGroups, groupMgmtEnabled)
                        }),
                        groups: groups.asWritable({
                            add: Command(addGroup, groupMgmtEnabled),
                            remove: Command(removeGroup, groupMgmtEnabled)
                        })
                    });
                }
                Internal.RootGroup = RootGroup;
                var RootGroup;
                (function (RootGroup) {
                    ;
                })(RootGroup = Internal.RootGroup || (Internal.RootGroup = {}));
                //#endregion RootGroup
                //#region Group
                /**
                 * A group that holds a collection of contacts and nested groups.
                 *
                 * An instance of Group represents a group of contacts, which
                 * can come from one of many sources:
                 *
                 *      -   the contact list that includes all contacts
                 *      -   a distribution group
                 *      -   a relationship group like Colleagues, Workgroup, Blocked
                 *      -   a user-created or a server-created group of contacts
                 *
                 * These sources are similar in a sense that they encapsulate a contact list,
                 * but the access path to that list may differ:
                 *
                 *     -    myContacts / contact[i]
                 *     -    myPrivacyRelationship / contact[i]
                 *     -    distributionGroup / contact[i]
                 *     -    pinnedGroup / groupContacts / contact[i]
                 *     -    defaultGroup / groupContacts / contact[i]
                 *     -    group / groupContacts / contact[i]
                 *
                 * For instance to get the list of rel=contact resources for a rel=group,
                 * the model at first gets rel=group, then it finds rel=groupContacts link
                 * in it, sends a GET to that link and finds rel=contact links in the response.
                 * To get the list of contacts for rel=myContacts and rel=myPrivacyRelationship
                 * it's enough to send a GET to these resources; in case of rel=distributionGroup
                 * the model sends a GET to distributionGroup/expandDistributionGroup.
                 *
                 * @param {UCWA} ucwa
                 * @param {ContactManager} contactmgr
                 * @param {String} source - The href/rel of the group.
                 *
                 * @collection {Group} groups - Nested groups.
                 *
                 *      A distribution group may have nested distribution groups.
                 *      This collection may initially be empty, as the UI may not need
                 *      to display the nested groups, but can be loaded from the server
                 *      either via a call to `groups.get` or via a subscription to
                 *      the `groups:added` event.
                 *
                 *      To get the list of names of nested groups without
                 *      sending requests to the server:
                 *
                 *          var nestedGroups = thisGroup.groups();
                 *          nestedGroups.forEach(function (group) {
                 *              console.log(group.name());
                 *          });
                 *
                 *      To request the list of nested groups from the server:
                 *
                 *          thisGroup.groups.get().then(function (nestedGroups) {
                 *              // now these groups in the local cache, so
                 *              // nestedGroups == thisGroup.groups()
                 *
                 *              nestedGroups.forEach(function (group) {
                 *                  console.log(group.name());
                 *              });
                 *          });
                 *
                 *      To observe the collection of nested groups:
                 *
                 *          thisGroup.groups.added(function (group) {
                 *              console.log(group.name() + " has been added");
                 *          });
                 *
                 *          thisGroup.groups.removed(function (group) {
                 *              console.log(group.name() + " has been removed");
                 *          });
                 *
                 * @collection {Person} persons - All the contacts in this group.
                 *
                 *      The constructor does not populate this collection
                 *      because the UI may not need to display the contacts
                 *      immediately. Instead it waits until someone subscribes to the
                 *      collection and then loads contacts from the server.
                 *
                 *      When writing UI controls on top of this class, consider
                 *      the following approach of reading contacts:
                 *
                 *          group.persons.added(function(contact){
                 *              contact.displayName.changed(function(displayName){
                 *                  $('.displayName').text(...);
                 *              });
                 *          });
                 *
                 *      The handler attached to the "added" event will be invoked for
                 *      all contacts in the collection even if they were added to it
                 *      before the handler is attached.
                 *
                 *      To get the list of contacts once from the server use the async `get`
                 *      method that sends a GET request(s) to the server and resolves the
                 *      returned promise to the array of Person models. In addition to
                 *      that it saves the list of Person models in the cache, so next
                 *      time these contacts can be retrieved without the need to go to the server.
                 *
                 *          group.persons.get().then(function (contacts) {
                 *              contacts.forEach(function (contact) {
                 *                  console.log(group.name() + " contains " + contact.displayName());
                 *              });
                 *          });
                 *
                 *      To add or remove a contact use the async add/remove methods:
                 *
                 *          group.persons.add(contact1).then(null, function (err) {
                 *              console.log("The contact cannot be added: " + err);
                 *          });
                 *
                 *          group.persons.remove(contact2).then(null, function (err) {
                 *              console.log("The contact cannot be removed: " + err);
                 *          });
                 *
                 *      These methods send a request to the server to add or remove a contact.
                 *      The contact gets actually removed or added after the server sends a
                 *      corresponding event that can be observed in the `added` and `removed`
                 *      events of the collection.
                 *
                 *      Not all groups support adding and removing contacts. For instance
                 *      distribution groups discovered via search cannot be edited this way.
                 *
                 * @property {String} name
                 *
                 *      This property is defined for user-created, server-created and distribution groups.
                 *
                 *      There are two predefined groups created by the server, with the following names:
                 *             - Other Contacts
                 *             - Pinned Contacts
                 *               ("Pinned Contacts" corresponds to the "Favorites" group.)
                 *
                 *      The setter of the name attribute can be used to rename the group, which
                 *      leads to a "PUT" request being sent to UCWA. This "PUT" request, upon
                 *      success (with a 204 response), results in a new group being created by
                 *      UCWA (indicated by a "group added" event) with the new name, and the
                 *      old group (with the old name) being deleted by UCWA (indicated by a
                 *      "group deleted" event). For this reason, such a setter call will
                 *      return the (old) name of the old group, since the caller would still
                 *      hold the reference to the old group object (which will be deleted when
                 *      the "group deleted" event arrives).
                 *
                 *      Consider this example to rename a group:
                 *
                 *          // assume getGroupByName returns the Group object by its name
                 *          var group = getGroupByName("oldName");
                 *
                 *          client.personsAndGroupsManager.all.groups.added(function (g) {
                 *              g.name.get().then(function (a) {
                 *                  // the new group with the new name has been created
                 *                  // update the reference if want to reuse it
                 *                  if (a == "newGroup") group = g;
                 *              });
                 *          });
                 *
                 *          client.personsAndGroupsManager.all.groups.removed(function (g) {
                 *              g.name.get().then(function (a) {
                 *                  // the old group with the old name has been deleted
                 *                  // the old reference is no long valid if not updated yet
                 *                  // so renew it to point to the new group object
                 *                  if (a == "oldGroup") group = getGroupByName("newName");
                 *              });
                 *          });
                 *
                 *          group.name.set("newName").then(function (a) {
                 *              // a should be the name "oldName" of the old group
                 *              console.log(a);
                 *          });
                 *
                 *          // at this moment, the group reference is likely still pointing
                 *          // to the old group, with name "oldName"
                 *          console.log(group.name());
                 *          // ...
                 *          // some moments later, after the "group added" event is received
                 *          // the group reference has been updated to point to the new group
                 *          // with name "newName"
                 *          console.log(group.name());
                 *
                 *      TODO: this behavior is confusing
                 *
                 * @property {String} uri
                 *
                 *      Distribution groups have this id. This id looks like "sales@contoso.com"
                 *
                 * @property {String} relationshipLevel
                 *
                 *      This property is defined for the relationship groups. These groups are created by the server
                 *      and have the following relationship levels:
                 *
                 *          - Blocked
                 *          - Colleagues
                 *          - Workgroup
                 *          - External
                 *          - FriendsAndFamily
                 *
                 * @property {String} id
                 *
                 *      Relationship groups do not have this id. All other groups do.
                 *
                 */
                function Group(options) {
                    var ucwa = options.ucwa;
                    var source = options.source;
                    var contactmgr = options.contactmgr;
                    var subscribe = options.subscribe;
                    var unsubscribe = options.unsubscribe;
                    // source can be the href string or Promise<String>
                    var rGroup = source && !isPromise(source) && ucwa.get(source);
                    var self = Model();
                    var properties = {};
                    var rGroupMemberships = options.groupMemberships, personMgmtEnabled = BoolProperty(false); // enable/disable person management APIs
                    var persons = Collection({
                        get: loadContactsAndNestedGroups,
                        subscribed: subscribeContactsAndGroups,
                        unsubscribed: unsubscribeContactsAndGroups
                    });
                    var groups = Collection({
                        get: loadContactsAndNestedGroups,
                        subscribed: subscribeContactsAndGroups,
                        unsubscribed: unsubscribeContactsAndGroups
                    });
                    var types = {
                        group: 'Custom',
                        defaultGroup: 'Others',
                        pinnedGroup: 'Favorites',
                        distributionGroup: 'Distribution',
                        myPrivacyRelationship: 'PrivacyRelationship'
                    };
                    var dfdInfo; // tracks the progress of `loadInfo`
                    var dfdContacts; // tracks the progress of `loadContactsAndNestedGroups`
                    function subscribeContactsAndGroups() {
                        if (subscribe)
                            subscribe();
                        loadContactsAndNestedGroups();
                    }
                    function unsubscribeContactsAndGroups() {
                        if (unsubscribe)
                            unsubscribe();
                    }
                    function importContacts(resource) {
                        // TODO: the list of contacts on the server may be a subset
                        // of the list of contacts known to the client; in this case
                        // some contacts must be deleted from the list
                        foreach(resource.related.contact || [], function (link) {
                            if (!persons(link.href))
                                persons.add(contactmgr.get(link.href), link.href);
                        });
                    }
                    function importGroups(r) {
                        foreach(r.links('distributionGroup'), function (link) {
                            var nestedGroup;
                            if (!groups(link.href)) {
                                nestedGroup = Group({
                                    source: link.href,
                                    ucwa: ucwa,
                                    contactmgr: contactmgr,
                                    subscribe: subscribe,
                                    unsubscribe: unsubscribe
                                });
                                groups.add(nestedGroup, link.href);
                            }
                        });
                    }
                    function getContactUri(contact) {
                        if (!contact || !(isObject(contact) || isNotEmptyString(contact)))
                            throw EInvalidArgument('contact', 'the given value is not a Person model or valid URI');
                        return Task.wait(null).then(function () {
                            return contact.id ? contact.id.get() : contact;
                        });
                    }
                    /*
                     * Add a contact to this Group.
                     *
                     * add operation is a POST request of the form:
                     * "POST /groupMemberships?groudId=...&contactUri=..."
                     * where the href is obtained via the 'myGroupMemberships' link, and
                     * the 'groupId=<gid>' query part can be omitted for the default group.
                     *
                     * Note: UCWA allows contact to be added to certain (but not all)
                     * groups. We will let UCWA respond to operations that are not allowed.
                     *
                     * @param {String|Person} contact - a contact URI or Person object
                     * @returns {Promise}
                     */
                    function addContact(contact) {
                        record('Contact_Add');
                        return getContactUri(contact).then(function (uri) {
                            return Task.wait(null).then(function () {
                                return self.id.get();
                            }).then(function () {
                                return rGroup.get('id');
                            }).then(function (gid) {
                                return initPersonMgmtAPI().then(function () {
                                    return ucwa.send('POST', { rel: 'myGroupMemberships' }, {
                                        headers: { 'X-MS-RequiresMinResourceVersion': 2 /* AddPerson */ },
                                        // no need to pass the gid if this is the default group
                                        query: rGroup.rel == 'defaultGroup' ?
                                            { contactUri: uri } :
                                            { groupId: gid, contactUri: uri }
                                    });
                                });
                            }, function (error) {
                                // the group does not have an id
                                // wrap the ucwa error inside an ENotSupported error
                                throw ENotSupported(error);
                            });
                        });
                    }
                    /*
                     * Filter the myGroupMembership resources that match the current group
                     * and the contact href passed in.
                     *
                     * @param {String} contactHref - the contact href
                     * @returns {Array<Resource>} - an array of matched resources
                     */
                    function filterMembershipLinks(contactHref) {
                        return filter(rGroupMemberships.links('myGroupMembership'), function (link) {
                            var gm = ucwa.get(link.href);
                            return gm.hasLink(rGroup.rel) &&
                                gm.link(rGroup.rel).href == rGroup.href &&
                                gm.link('contact').href == contactHref;
                        });
                    }
                    /*
                     * Retrieve the link to remove a contact from this Group.
                     *
                     * @param {Person} contact - a Person object
                     * @returns {Promise<String>} - a promise containing the link href
                     */
                    function getMembershipLink(contact) {
                        if (!contact || !contact.id)
                            throw EInvalidArgument('contact', 'the given value is not a Person model');
                        // always load myGroupMemberships to prevent out of sync with UCWA
                        // TODO: batch process multiple remove requests in sequence
                        return ucwa.send('GET', rGroupMemberships.href).then(function () {
                            // exactly one link needs to be available
                            var membershipLinks = filterMembershipLinks(contact[Internal.sHref]);
                            if (membershipLinks.length != 1) {
                                if (rGroup.rel == 'distributionGroup' ||
                                    rGroup.rel == 'myPrivacyRelationship') {
                                    // contact management is currently not supported for
                                    // DG and privacy relationship, so throw a more
                                    // meaningful error. Need to remove this special
                                    // handling once support becomes available
                                    throw ENotSupported(EDoesNotExist(contact));
                                }
                                else {
                                    throw EDoesNotExist(contact);
                                }
                            }
                            return membershipLinks[0].href;
                        });
                    }
                    /*
                     * Remove a contact from this Group.
                     *
                     * remove operation is a DELETE request of the form:
                     * "DELETE /groupMemberships/...,..."
                     * where the href must be one of the 'myGroupMembership' links, and
                     * the comma separated parts are group ID and contact uri.
                     *
                     * Note: UCWA allows contact to be removed from certain (but not all)
                     * groups. We will let UCWA respond to operations that are not allowed.
                     *
                     * @param {Person} contact - a Person object
                     * @returns {Promise}
                     */
                    function removeContact(contact) {
                        record('Contact_Remove');
                        return getMembershipLink(contact).then(function (href) {
                            return initPersonMgmtAPI().then(function () {
                                return ucwa.send('DELETE', href, {
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemovePerson */ }
                                });
                            });
                        });
                    }
                    //#region rename
                    /*
                     * Rename a group.
                     *
                     * renaming group is a PUT request of the form:
                     * "PUT /people/groups/<groupId>"
                     * where the data passed in the request contains the following properties:
                     * {
                     *      rel: 'group',
                     *      name: 'new group name',
                     *      id: '<group id>',
                     *      etag: '<some etag>',
                     *      <some-guid>: 'please pass this in a PUT request'
                     * }
                     * Except for the new name, all other properties should be directly
                     * associated with and obtained from the current group resource. The
                     * etag value will be inserted as the 'if-match' value in the header
                     * of the PUT request.
                     *
                     * Note: UCWA allows renaming for certain (but not all) groups. We will
                     * let UCWA respond to operations that are not allowed.
                     *
                     * @param {String} name - the new name specified
                     * @returns {Promise}
                     */
                    function rename(name) {
                        record('Group_Rename');
                        assert.is(name, 'NotEmptyString');
                        return !rGroup ? name : loadInfo().then(function () {
                            return initPersonMgmtAPI();
                        }).then(function () {
                            return ucwa.send('PUT', rGroup.href, {
                                headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RenameGroup */ },
                                data: extend(rGroup.getSnapshot(), { name: name })
                            }).then(function () {
                                // currently this PUT request results in a new group
                                // created with the new name and the old group deleted.
                                // The on success promise of this request will be used to
                                // update the name of the old group, so we need to return
                                // the name of the old group to make that update correct.
                                return rGroup.get('name');
                            });
                        });
                    }
                    /*
                     * Enable person and group management APIs if supported.
                     */
                    function initPersonMgmtAPI() {
                        return ucwa.getRevisionOf(rGroupMemberships).then(function () {
                            if (!personMgmtEnabled())
                                throw ENotSupported();
                        });
                    }
                    //#endregion
                    /**
                     * Expands the group by sending a GET request to the server
                     * and returns a promise that tracks the progress of that request.
                     * Note, that big distribution groups cannot be expanded, as
                     * the server returns a HTTP 403 with a "too many contacts" message
                     * in the response body.
                     *
                     * @returns {Promise}
                     */
                    function expand() {
                        // for regular groups
                        if (rGroup.hasLink('groupContacts'))
                            return ucwa.send('GET', rGroup.link('groupContacts').href);
                        // for distribution groups
                        if (rGroup.hasLink('expandDistributionGroup'))
                            return ucwa.send('GET', rGroup.link('expandDistributionGroup').href);
                        return Task().reject(new Error('Missing the group expansion link.')).promise;
                    }
                    /**
                     * Adds a new observable property to the instance of Group.
                     * The given setter defines how to update the property.
                     */
                    function define(name, set) {
                        assert(!self[name]);
                        var p = Property({
                            subscribed: loadInfo,
                            get: function () {
                                return loadInfo().then(function () {
                                    // a handler for the rGroup:updated event
                                    // has already updated this property
                                    return p();
                                });
                            },
                            set: set
                        });
                        properties[name] = p;
                        self[name] = set ? p : p.asReadOnly();
                    }
                    function loadInfo() {
                        return Task.wait(source).then(function (href) {
                            dfdInfo = dfdInfo || ucwa.send('GET', href);
                            return dfdInfo;
                        });
                    }
                    function loadContactsAndNestedGroups() {
                        dfdContacts = dfdContacts || loadInfo().then(function () {
                            importContacts(rGroup);
                            importGroups(rGroup);
                            // these two group types do not need to be expanded
                            // since they do not have expansion links
                            if (rGroup.rel != 'myPrivacyRelationship' && rGroup.rel != 'myContacts') {
                                return expand().then(function (r) {
                                    importContacts(r);
                                    importGroups(r);
                                });
                            }
                        });
                        return dfdContacts;
                    }
                    function handleUcwaEvent(event) {
                        var scope = event['in'] || {};
                        var link = event.target || {};
                        if (scope.href == rGroup.href) {
                            if (event.type == 'deleted') {
                                // if the contact does not exist in the collection,
                                // nothing will happen
                                persons.remove(link.href);
                            }
                            if (event.type == 'added') {
                                if (!persons(link.href))
                                    persons.add(contactmgr.get(link.href), link.href);
                            }
                        }
                    }
                    define('name', rename);
                    define('uri');
                    define('relationshipLevel');
                    define('id');
                    Task.wait(source, 'sync').then(function (href) {
                        rGroup = rGroup || ucwa.get(href);
                        if (rGroup.rel != 'myPrivacyRelationship')
                            properties.relationshipLevel('None');
                        rGroup.updated(function () {
                            foreach(properties, function (p, name) {
                                if (name in rGroup.properties)
                                    p(rGroup.properties[name], Property.sUpdated);
                            });
                        });
                        rGroupMemberships = rGroupMemberships || ucwa.get({ rel: 'myGroupMemberships' });
                        rGroupMemberships.updated(function () {
                            // enable person management APIs properly if the resource
                            // revision is already loaded; otherwise enable the APIs
                            // so that they can be called, at which point the resource
                            // revision will be loaded and the APIs will be enabled
                            // or disabled properly
                            var rev = rGroupMemberships.link('self').revision;
                            personMgmtEnabled(!(+rev || rGroupMemberships.dfdDebounced) || rev >= 2);
                        });
                        // the server tells over the event channel when a contact gets
                        // added to the group or removed from it
                        ucwa.event(handleUcwaEvent);
                        rGroup.deleted(function () {
                            ucwa.event.off(handleUcwaEvent);
                        });
                        try {
                            // import immediate contacts from rel=this/rel=contact[i]
                            importContacts(rGroup);
                        }
                        catch (err) {
                            debug.log('Failed to import persons for ' + rGroup.href + ': ' + err);
                        }
                        try {
                            // import immediate groups from rel=this/rel=distributionGroup[i]
                            importGroups(rGroup);
                        }
                        catch (err) {
                            debug.log('Failed to import groups for ' + rGroup.href + ': ' + err);
                        }
                        try {
                            // import indirect persons from rel=this/rel=groupContacts/rel=contact[i]
                            importContacts(ucwa.get(rGroup.link('groupContacts').href));
                        }
                        catch (_) {
                        }
                        // sHref will be a hidden symbol for Group objects
                        setHiddenProperty(self, Internal.sHref, rGroup.href);
                    });
                    // The add/remove methods of a Group object need to be overridden
                    // to do different things:
                    // 1) For a regular Group, add/remove are used to add/remove a
                    //    contact to/from the group.
                    // 2) For the root group that represents the "contact list", i.e.,
                    //    client.personsAndGroupsManager.all.persons, the add method is
                    //    not supported, and the remove method is used to remove a contact
                    //    from all groups.
                    return extend(self, {
                        avatarUrl: ConstProperty(null),
                        type: ConstProperty(types[rGroup && rGroup.rel || 'group']),
                        groups: groups.asReadOnly(),
                        persons: persons.asWritable({
                            add: Command(addContact, personMgmtEnabled),
                            remove: Command(removeContact, personMgmtEnabled)
                        })
                    });
                }
                Internal.Group = Group;
                //#endregion
                //#region SearchQuery
                /**
                 * The base class for PersonOrGroupSearchQuery and ConversationSearchQuery
                 *
                 * @property {Number} sources - Local, remote or all.
                 *
                 *      This purpose of this property is only to support the JCafe API, and
                 *      The value does not affect any search results in the current version.
                 *
                 * @property {String} text - The text string contains the search query.
                 *
                 * @property {Number} limit - Max number of results to be fetched by one getMore call.
                 *
                 */
                function SearchQuery() {
                    var Scope = StringEnum('Local', 'Remote', 'All');
                    var limit = Property({
                        value: 1,
                        check: function (value) {
                            if (!(value > 0 && (value | 0) == value))
                                throw EInvalidArgument('limit', '`limit` must be a positive integer');
                        }
                    });
                    var text = Property({
                        check: function (value) {
                            if (!isNotEmptyString(value))
                                throw EInvalidArgument('text', '`text` must be set as a no empty query string before searching.');
                        }
                    });
                    var sources = Property({
                        value: Scope.All,
                        check: function (value) {
                            //if (value in Scope)
                            if (value != Scope.Local && value != Scope.Remote && value != Scope.All)
                                throw EInvalidArgument('sources', '`sources` value must be set as Local, Remote, or All.');
                        }
                    });
                    return Model({
                        text: text,
                        limit: limit,
                        sources: sources
                    });
                }
                Internal.SearchQuery = SearchQuery;
                //#endregion
                //#region PersonOrGroupSearchQuery
                /**
                 * Inherited from SearchQuery, it represents a search query for
                 * searching persons or groups. The search results will be provided
                 * after the request of searching query is resolved by server.
                 *
                 * @param {UCWA} ucwa
                 * @param {ContactManager} contactmgr
                 * @param {PresenceSubscriptionManager} psm
                 * @param {String} type - The type of searching object.
                 *
                 *      The value can be 'person'or 'group'.
                 *
                 * @property {String} sources - Local search, directory search or both.
                 *
                 *      The value is null, since it is not supported.
                 *
                 * @property {String} text - The text string contains the search query.
                 *
                 *      This search query will be used to search for persons
                 *      or groups. This query can be anything like user name,
                 *      email, SIP URI, phone number and so on. Since UCWA
                 *      supports the lookup a contact by email at version 2.0,
                 *      the text may start with the substring 'id:' to find
                 *      a person in a more efficient way. For example,
                 *      text = 'id:johndoe@contoso.com'.
                 *
                 * @property {Number} limit - Max number of results to be fetched by one getMore call.
                 *
                 *      The search method 'getMore' gets 'limit' results from the server,
                 *      and the server tells whether more results are available beyond
                 *      the specified limit.
                 *
                 * @property {Boolean} moreResultsAvailable
                 *
                 *      It indicates whether more results are available after
                 *      the getMore is called with the specified limit amd text.
                 *
                 * @collection {String} supportedKeywords - A read-only collection of supported search keywords.
                 *
                 *      The 'id' is the only supported search keyword for now to search persons by email.
                 *
                 * @member {Dictionary} keywords - The value pairs in the search query.
                 *
                 *      It may contain all supportedKeywords as keys, users should
                 *      provide values for those keys when needed. Any provided keys are not
                 *      included in supportedKeywords will be ignored in the search.
                 *
                 * @collection {Object} results - Found results.
                 *
                 *      Each object in the collection contains the following three fields:
                 *
                 *          - {Person | Group} result - Single searching result as one 'Person' or 'Group' object.
                 *          - {Dictionary} matches - An empty dictionary, since it is not supported.
                 *          - {Number} relevance - A property wtih null value, since it is not supported.
                 *
                 *      You may occasionally observe in search results contacts with SIP URIs
                 *      like "sip:...@anonymous.invalid" - these are users joined online
                 *      meetings anonymously.
                 *
                 * @command {Promise} getMore
                 *
                 *      This method is to start the search and returns a promise. Once it is resolved,
                 *       the search results will be available in the collection 'results'.
                 *
                 *      This method will be disabled after it is called first time. If more search
                 *      attempts are needed, new search queries should be created first.
                 *
                 * @returns {SearchResult[]} - An array of new results when the getMore call is resolved.
                 *
                 * @example
                 *
                 *      // search for persons
                 *      var searchQuery = client.personsAndGroupsManager.createPersonSearchQuery();
                 *      searchQuery.text("John");
                 *      searchQuery.limit(10);
                 *      searchQuery.getMore().then(function () {
                 *          if (searchQuery.getMore.enabled())
                 *              console.log("More results are available on the server");
                 *          else
                 *              console.log("No more results are available on the server");
                 *
                 *          searchQuery.results().forEach(function (r) {
                 *              console.log("person:", r.result.name());
                 *          });
                 *      });
                 *
                 */
                function PersonOrGroupSearchQuery(options) {
                    var ucwa = options.ucwa;
                    var type = options.type;
                    var contactmgr = options.contactmgr;
                    var psm = options.psm;
                    var me = options.me;
                    var self = SearchQuery();
                    var supportedKeywords = Collection();
                    var keywords = {};
                    var results = Collection();
                    var moreResultsAvailable = Property({ value: false });
                    var enabled = BoolProperty(true);
                    supportedKeywords.add('id');
                    function getMore() {
                        record('Search');
                        var sLink = ucwa.get({ rel: 'people' }).link('search');
                        var email = keywords['id'] || self.text() && self.text().slice(0, 3).toLowerCase() == 'id:' &&
                            self.text().slice(3);
                        var request = {};
                        var newResults = [];
                        function isMe(res) {
                            // we can use for comparison .uri property directly,
                            // as GET /search returns all found contacts with URI loaded
                            return res.properties.uri === me.id();
                        }
                        function addSearchResult(res) {
                            var item = {
                                result: res,
                                matches: {},
                                relevance: ConstProperty(null)
                            };
                            results.add(item);
                            newResults.push(item);
                        }
                        enabled(false);
                        if (email && email.length >= 1) {
                            // starting from search.revision=2 UCWA supports lookup by email
                            if (sLink.revision >= 2) {
                                request.headers = { 'X-MS-RequiresMinResourceVersion': 2 };
                                request.query = { mail: email };
                            }
                            else {
                                //fallback to lookup by query text.
                                request.query = { query: email, limit: 1 };
                            }
                        }
                        else
                            request.query = { query: isVoid(self.text()) ? '' : self.text(), limit: self.limit() };
                        // GET /search?query=abcdef&limit=50
                        return ucwa.send('GET', sLink.href, request).then(function (sr) {
                            foreach(sr.embedded, function (resource) {
                                if (type == 'person' && resource.rel == 'contact') {
                                    // if it's a contact (excluding yourself), create a Person model,
                                    // but do not put it in any cache, since most likely
                                    // this search result will be shown only once in
                                    // the UI and then will be dismissed
                                    if (!isMe(resource)) {
                                        addSearchResult(Person({
                                            href: resource.href,
                                            ucwa: ucwa,
                                            psm: psm
                                        }));
                                    }
                                }
                                else if (type == 'group' && resource.rel == 'distributionGroup') {
                                    // if it's a group, create a group model,
                                    // but do not put it in any cache, since most likely
                                    // this search result will be shown only once in
                                    // the UI and then will be dismissed
                                    addSearchResult(Group({
                                        ucwa: ucwa,
                                        contactmgr: contactmgr,
                                        source: resource.href
                                    }));
                                }
                            });
                            moreResultsAvailable(!!sr.properties.moreResultsAvailable);
                            return newResults;
                        }, function (error) {
                            enabled(true);
                            throw error;
                        });
                    }
                    return extend(self, {
                        supportedKeywords: supportedKeywords.asReadOnly(),
                        keywords: keywords,
                        moreResultsAvailable: moreResultsAvailable.asReadOnly(),
                        getMore: Command(async(getMore), enabled),
                        results: results.asReadOnly()
                    });
                }
                Internal.PersonOrGroupSearchQuery = PersonOrGroupSearchQuery;
                //#endregion
                //#region PersonSearchQuery
                /**
                 * It represents a search query for searching persons.
                 *
                 *      It inherits from class PersonOrGroupSearchQuery with
                 *      an additional parameter type = 'person' in the 'options'.
                 *
                 */
                function PersonSearchQuery(options) {
                    options.type = 'person';
                    return PersonOrGroupSearchQuery(options);
                }
                Internal.PersonSearchQuery = PersonSearchQuery;
                //#endregion
                //#region GroupSearchQuery
                /**
                 * It represents a search query for searching groups.
                 *
                 *      It inherits from class PersonOrGroupSearchQuery with
                 *      an additional parameter type = 'group' in the 'options'.
                 *
                 */
                function GroupSearchQuery(options) {
                    options.type = 'group';
                    return PersonOrGroupSearchQuery(options);
                }
                Internal.GroupSearchQuery = GroupSearchQuery;
                //#endregion
                //#region ConversationSearchQuery
                /**
                 * Inherited from SearchQuery, it represents a search query for searching conversations locally.
                 *
                 * @param {Collection<Conversation>} conversations - The collection of conversations available in ConversationsManager
                 *
                 * @property {String} sources - Local search, directory search or both.
                 *
                 *      The value is null, since it is not supported.
                 *
                 * @property {String} text - The text string contains the search query.
                 *
                 *      This is the search query for searching conversations in any supported fields.
                 *      Those supported fields are specified in supportedKeywords, which currently include
                 *      conversation's uri, topic, and participant names.
                 *
                 *      The search term takes the whole string of  'text' property. All search will be case insensitive.
                 *      A search for conversation is considered as a 'match' only when:
                 *
                 *            - Any supported fields of this conversation contains the search term 'text',
                 *            - And every specified value in keywords has a 'match' in its corresponding supported field.
                 *
                 *       For example, for a given text = 'scrum meeting', and keywords['topic'] = 'design',
                 *       the conversation is considered as a 'match' when:
                 *
                 *            -  Any supported fields, such as 'uri', 'topic' or 'participant' contains 'scrum meeting',
                 *            - And 'topic' of this conversation must contain 'design'.
                 *
                 * @property {Number} limit - Max number of results to be fetched by one getMore call.
                 *
                 *      It is a read-only property since it is not meaningful for searching conversations locally
                 *
                 * @property {Boolean} moreResultsAvailable -  Whether more results are available after the getMore is called
                 *
                 *      It is read-only property and the value is always as 'false' for searching conversation.
                 *
                 * @collection {String} supportedKeywords - A read-only collection of supported search keywords.
                 *
                 *      The following keywords are supported:
                 *
                 *          - uri
                 *          - topic
                 *          - participant
                 *
                 * @member {Dictionary} keywords - The value pairs in the search query.
                 *
                 *      It may contain all supportedKeywords as keys, users should
                 *      provide values for those keys when needed. Any provided keys are not
                 *      included in supportedKeywords will be ignored in the search.
                 *
                 * @collection {Object} results - Found results.
                 *
                 *      Each object in the collection contains the following three fields:
                 *
                 *          - {Conversation} result - Single searching result as one 'Conversation' object.
                 *          - {Dictionary} matches - A empty dictionary, since it is not supported.
                 *          - {Number} relevance - A property wtih null value, since it is not supported.
                 *
                 * @command {Promise} getMore
                 *
                 *      This method is to start the search and returns a promise. Once it is resolved,
                 *      the search results will be available in the collection of 'results'.
                 *
                 *      This method is always enabled.
                 *
                 * @returns {SearchResult[]} - an array of new results when the getMore call is resolved.
                 *
                 * @example
                 *
                 *      var searchQuery = client.conversationsManager.createSearchQuery();
                 *      searchQuery.text("scrum planning");
                 *      searchQuery.keywords['participant'] = 'frank';
                 *      searchQuery.getMore().then(function () {
                 *          searchQuery.results().forEach(function (r) {
                 *              console.log("conversation  uri:", r.result.id());
                 *          });
                 *      });
                 *
                 *
                 */
                function ConversationSearchQuery(conversations) {
                    var self = SearchQuery();
                    var results = Collection();
                    var supportedKeywords = Collection();
                    var keywords = {};
                    // It is a unique exception object to be thrown in the
                    // comparing function when no 'match' is found.
                    var ne = {};
                    // An array of dictionaries, each of which has one conversation's field as the key,
                    // and its corresponding searching functions as the value.
                    // To add a new searching field for the conversation in the future,
                    // simply add a new dictionary with a new supported key and its searching function.
                    var supportedInternal = [
                        {
                            key: 'uri',
                            call: function (conv, txt) {
                                return containsStr(conv.uri.get(), txt);
                            }
                        },
                        {
                            key: 'topic',
                            call: function (conv, txt) {
                                return containsStr(conv.topic.get(), txt);
                            }
                        },
                        {
                            key: 'participant',
                            call: function (conv, txt) {
                                return conv.participants.get().then(function (pts) {
                                    pts.push(conv.selfParticipant);
                                    return containsAny(pts, txt, function (value, participant) {
                                        return containsStr(participant.name.get(), value);
                                    });
                                });
                            }
                        },
                        {
                            key: 'group',
                            call: function (conv, boolFlag) {
                                return Task.wait(conv.isGroupConversation() != boolFlag).then(function (result) {
                                    if (result)
                                        throw ne;
                                });
                            }
                        }
                    ];
                    /**
                     * It returns a promise, which will be resolved when 'stringA' contains 'stringB'.
                     *
                     * @param {Promise|String} stringA - A promise to be resolved as a string, or a string object.
                     *
                     * @param {Promise|String} stringB - A promise to be resolved as a string, or a string object.
                     *
                     * @returns {Promise} - Resolved when 'stringA' contains 'stringB'
                     *
                     *      An unique exception 'ne' will be thrown if 'stringA' does not contain 'stringB'.
                     *
                     */
                    function containsStr(stringA, stringB) {
                        return Task.waitAll([stringA, stringB]).then(function (resolved) {
                            if (resolved[0].toLowerCase().indexOf(resolved[1].toLowerCase()) < 0)
                                throw ne;
                        });
                    }
                    /**
                     * It returns a promise, which will be resolved if any one in 'objects' contains 'stringA'
                     *
                     * @param {Promise|Collection} objects - A promise to be resolved a collection, or a collection object.
                     *
                     * @param {Promise|String} stringA - A promise to be resolved as a string,  or a object string.
                     *
                     * @param {Function} compareFunction - A function to compare the  one object's property with 'stringA'
                     *
                     *      It should throw the 'ne' exception if the object's property does not contain 'stringA'.
                     *
                     * @returns {Promise} - Resolved if any object contains 'stringA'.
                     *
                     *      An unique exception 'ne' will be thrown if none of objects contains 'stringA'.
                     *
                     */
                    function containsAny(objects, stringA, compareFunction) {
                        return Task.waitAll([objects, stringA]).then(function (resolved) {
                            //if objects is null, consider it as there is no 'match' found.
                            if (resolved[0].length == 0)
                                throw ne;
                            return Task.waitAny(map(resolved[0], bind(compareFunction, resolved[1])));
                        });
                    }
                    // Returns a promise, which will be resolved if the conversation
                    // has a 'match' for the search query and keywords. Otherwise,
                    // it throws the unique 'ne' exception.
                    function compareConversation(conv) {
                        //check whether any one of conversation's fields contains 'text'
                        var pText = Task.waitAny(map(supportedInternal, function (field) {
                            return field.call(conv, self.text());
                        }));
                        //check whether each conversation's field contains its corresponding keyword's value if provided.
                        var pKW = Task.waitAll(map(supportedInternal, function (field) {
                            if (!isVoid(keywords[field.key])) {
                                return field.call(conv, keywords[field.key]);
                            }
                        }));
                        //promise to wait both a 'match' in text property AND a 'match' in all provided keywords
                        return Task.waitAll([pText, pKW]);
                    }
                    function getMore() {
                        var newResults = [];
                        return conversations.get().then(function (convs) {
                            var mConvs = map(convs, function (conv) {
                                return compareConversation(conv).then(function () {
                                    var item = {
                                        result: conv,
                                        matches: {},
                                        relevance: ConstProperty(null)
                                    };
                                    results.add(item);
                                    newResults.push(item);
                                }, function (error) {
                                    if (error != ne)
                                        throw error;
                                });
                            });
                            return Task.waitAll(mConvs).then(function () {
                                return newResults;
                            });
                        });
                    }
                    foreach(supportedInternal, function (field) {
                        supportedKeywords.add(field.key);
                    });
                    return extend(self, {
                        supportedKeywords: supportedKeywords.asReadOnly(),
                        keywords: keywords,
                        limit: ConstProperty(null),
                        moreResultsAvailable: ConstProperty(false),
                        getMore: EnabledCommand(async(getMore)),
                        results: results.asReadOnly()
                    });
                }
                Internal.ConversationSearchQuery = ConversationSearchQuery;
            })(Internal = Model_1.Internal || (Model_1.Internal = {}));
            // export as an AMD module
            try {
                define('jCafe',{
                    Application: Application,
                    version: Skype.Web.version,
                    settings: Skype.Web.Settings
                });
            }
            catch (_) {
            }
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
//# sourceMappingURL=lync.js.map


;
define('build/SDK-build',['require','jCafe'],function (require) {
    

    var jCafe = require('jCafe'),
        exports = {};

    exports.init = function init(configWrapper, onSuccess) {
        var api = {
            application: jCafe.Application
        };

        onSuccess(api);
    };

    window.Skype.onExperienceLoaded(exports);

});

require(["build/SDK-build"]);
